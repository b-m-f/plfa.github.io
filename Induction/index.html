<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Induction</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Induction.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Induction: Proof by Induction</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Induction-86" class="Keyword">module</a> <a id="plfa_plfa-part1-Induction-93" href="../Induction/#" class="Module">plfa.part1.Induction</a> <a id="plfa_plfa-part1-Induction-114" class="Keyword">where</a>
</pre><blockquote><p>Induction makes you feel guilty for getting something out of nothing … but it is one of the greatest ideas of civilization. – Herbert Wilf</p></blockquote><p>Now that we’ve defined the naturals and operations upon them, our next step is to learn how to prove properties that they satisfy. As hinted by their name, properties of <em>inductive datatypes</em> are proved by <em>induction</em>.</p><h2 id="imports">Imports</h2>We require equality as in the previous chapter, plus the naturals and some operations upon them. We also require a couple of new operations, <code>cong</code>, <code>sym</code>, <code>_≡⟨⟩_</code> and <code>_≡⟨_⟩_</code>, which are explained below:<pre class="Agda"><a id="plfa_plfa-part1-Induction-722" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-729" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Induction-767" class="Symbol">as</a> <a id="plfa_plfa-part1-Induction-770" class="Module">Eq</a>
<a id="plfa_plfa-part1-Induction-773" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-778" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Induction-781" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-787" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-788" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Induction-791" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-793" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Induction-797" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-799" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="plfa_plfa-part1-Induction-803" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-805" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="plfa_plfa-part1-Induction-808" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-810" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-815" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a> <a id="plfa_plfa-part1-Induction-830" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-836" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-837" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin_</a><a id="plfa_plfa-part1-Induction-843" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-845" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">step-≡-∣</a><a id="plfa_plfa-part1-Induction-853" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-855" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">step-≡-⟩</a><a id="plfa_plfa-part1-Induction-863" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-865" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">_∎</a><a id="plfa_plfa-part1-Induction-867" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-869" class="Keyword">open</a> <a id="plfa_plfa-part1-Induction-874" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-881" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Induction-890" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-896" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-897" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-898" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-900" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-904" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-906" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Induction-909" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-911" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Induction-914" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-916" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Induction-919" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-921" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#4456" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Induction-924" class="Symbol">;</a><a id="plfa_plfa-part1-Induction-925" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#6561" class="Function Operator">_^_</a><a id="plfa_plfa-part1-Induction-928" class="Symbol">)</a>
</pre><p>(Importing <code>step--∣</code> defines <code>_≡⟨⟩_</code> and importing <code>step-≡-⟩</code> defines <code>_≡⟨_⟩_</code>.)</p><h2 id="properties-of-operators">Properties of operators</h2><p>Operators pop up all the time, and mathematicians have agreed on names for some of the most common properties.</p><ul><li><p><em>Identity</em>. Operator <code>+</code> has left identity <code>0</code> if <code>0 + n ≡ n</code>, and right identity <code>0</code> if <code>n + 0 ≡ n</code>, for all <code>n</code>. A value that is both a left and right identity is just called an identity. Identity is also sometimes called <em>unit</em>.</p></li><li><p><em>Associativity</em>. Operator <code>+</code> is associative if the location of parentheses does not matter: <code>(m + n) + p ≡ m + (n + p)</code>, for all <code>m</code>, <code>n</code>, and <code>p</code>.</p></li><li><p><em>Commutativity</em>. Operator <code>+</code> is commutative if order of arguments does not matter: <code>m + n ≡ n + m</code>, for all <code>m</code> and <code>n</code>.</p></li><li><p><em>Distributivity</em>. Operator <code>*</code> distributes over operator <code>+</code> from the left if <code>m * (p + q) ≡ (m * p) + (m * q)</code>, for all <code>m</code>, <code>p</code>, and <code>q</code>, and from the right if <code>(m + n) * p ≡ (m * p) + (n * p)</code>, for all <code>m</code>, <code>n</code>, and <code>p</code>.</p></li></ul><p>Addition has identity <code>0</code> and multiplication has identity <code>1</code>; addition and multiplication are both associative and commutative; and multiplication distributes over addition.</p><p>If you ever bump into an operator at a party, you now know how to make small talk, by asking whether it has a unit and is associative or commutative. If you bump into two operators, you might ask them if one distributes over the other.</p><p>Less frivolously, if you ever bump into an operator while reading a technical paper, this gives you a way to orient yourself, by checking whether or not it has an identity, is associative or commutative, or distributes over another operator. A careful author will often call out these properties—or their lack—for instance by pointing out that a newly introduced operator is associative but not commutative.</p><h4 id="operators">Exercise <code>operators</code> (practice)</h4><p>Give another example of a pair of operators that have an identity and are associative, commutative, and distribute over one another. (You do not have to prove these properties.)</p><p>Give an example of an operator that has an identity and is associative but is not commutative. (You do not have to prove these properties.)</p><h2 id="associativity">Associativity</h2><p>One property of addition is that it is <em>associative</em>, that is, that the location of the parentheses does not matter:</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>Here <code>m</code>, <code>n</code>, and <code>p</code> are variables that range over all natural numbers.</p>We can test the proposition by choosing specific numbers for the three variables:<pre class="Agda"><a id="plfa_plfa-part1-Induction-3453" href="../Induction/#plfa_plfa-part1-Induction-3453" class="Function">_</a> <a id="plfa_plfa-part1-Induction-3455" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-3457" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-3458" class="Number">3</a> <a id="plfa_plfa-part1-Induction-3460" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3462" class="Number">4</a><a id="plfa_plfa-part1-Induction-3463" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-3465" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3467" class="Number">5</a> <a id="plfa_plfa-part1-Induction-3469" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-3471" class="Number">3</a> <a id="plfa_plfa-part1-Induction-3473" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3475" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-3476" class="Number">4</a> <a id="plfa_plfa-part1-Induction-3478" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3480" class="Number">5</a><a id="plfa_plfa-part1-Induction-3481" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-3483" class="Symbol">_</a> <a id="plfa_plfa-part1-Induction-3485" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-3489" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-3499" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-3500" class="Number">3</a> <a id="plfa_plfa-part1-Induction-3502" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3504" class="Number">4</a><a id="plfa_plfa-part1-Induction-3505" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-3507" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3509" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-3513" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-3521" class="Number">7</a> <a id="plfa_plfa-part1-Induction-3523" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3525" class="Number">5</a>
  <a id="plfa_plfa-part1-Induction-3529" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-3537" class="Number">12</a>
  <a id="plfa_plfa-part1-Induction-3542" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-3550" class="Number">3</a> <a id="plfa_plfa-part1-Induction-3552" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3554" class="Number">9</a>
  <a id="plfa_plfa-part1-Induction-3558" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-3566" class="Number">3</a> <a id="plfa_plfa-part1-Induction-3568" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3570" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-3571" class="Number">4</a> <a id="plfa_plfa-part1-Induction-3573" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-3575" class="Number">5</a><a id="plfa_plfa-part1-Induction-3576" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-3580" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Here we have displayed the computation as a chain of equations, one term to a line. It is often easiest to read such chains from the top down until one reaches the simplest term (in this case, <code>12</code>), and then from the bottom up until one reaches the same term.</p><p>The test reveals that associativity is perhaps not as obvious as first it appears. Why should <code>7 + 5</code> be the same as <code>3 + 9</code>? We might want to gather more evidence, testing the proposition by choosing other numbers. But—since there are an infinite number of naturals—testing can never be complete. Is there any way we can be sure that associativity holds for <em>all</em> the natural numbers?</p><p>The answer is yes! We can prove a property holds for all naturals using <em>proof by induction</em>.</p><h2 id="proof-by-induction">Proof by induction</h2><p>Recall the definition of natural numbers consists of a <em>base case</em> which tells us that <code>zero</code> is a natural, and an <em>inductive case</em> which tells us that if <code>m</code> is a natural then <code>suc m</code> is also a natural.</p><p>Proof by induction follows the structure of this definition. To prove a property of natural numbers by induction, we need to prove two cases. First is the <em>base case</em>, where we show the property holds for <code>zero</code>. Second is the <em>inductive case</em>, where we assume the property holds for an arbitrary natural <code>m</code> (we call this the <em>inductive hypothesis</em>), and then show that the property must also hold for <code>suc m</code>.</p><p>If we write <code>P m</code> for a property of <code>m</code>, then what we need to demonstrate are the following two inference rules:</p><pre><code>------
P zero

P m
---------
P (suc m)</code></pre><p>Let’s unpack these rules. The first rule is the base case, and requires we show that property <code>P</code> holds for <code>zero</code>. The second rule is the inductive case, and requires we show that if we assume the inductive hypothesis—namely that <code>P</code> holds for <code>m</code>—then it follows that <code>P</code> also holds for <code>suc m</code>.</p><p>Why does this work? Again, it can be explained by a creation story. To start with, we know no properties:</p><pre><code>-- In the beginning, no properties are known.</code></pre><p>Now, we apply the two rules to all the properties we know about. The base case tells us that <code>P zero</code> holds, so we add it to the set of known properties. The inductive case tells us that if <code>P m</code> holds (on the day before today) then <code>P (suc m)</code> also holds (today). We didn’t know about any properties before today, so the inductive case doesn’t apply:</p><pre><code>-- On the first day, one property is known.
P zero</code></pre><p>Then we repeat the process, so on the next day we know about all the properties from the day before, plus any properties added by the rules. The base case tells us that <code>P zero</code> holds, but we already knew that. But now the inductive case tells us that since <code>P zero</code> held yesterday, then <code>P (suc zero)</code> holds today:</p><pre><code>-- On the second day, two properties are known.
P zero
P (suc zero)</code></pre><p>And we repeat the process again. Now the inductive case tells us that since <code>P zero</code> and <code>P (suc zero)</code> both hold, then <code>P (suc zero)</code> and <code>P (suc (suc zero))</code> also hold. We already knew about the first of these, but the second is new:</p><pre><code>-- On the third day, three properties are known.
P zero
P (suc zero)
P (suc (suc zero))</code></pre><p>You’ve got the hang of it by now:</p><pre><code>-- On the fourth day, four properties are known.
P zero
P (suc zero)
P (suc (suc zero))
P (suc (suc (suc zero)))</code></pre><p>The process continues. On the <em>n</em>’th day there will be <em>n</em> distinct properties that hold. The property of every natural number will appear on some given day. In particular, the property <code>P n</code> first appears on day <em>n+1</em>.</p><h2 id="our-first-proof-associativity">Our first proof: associativity</h2><p>To prove associativity, we take <code>P m</code> to be the property:</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>Here <code>n</code> and <code>p</code> are arbitrary natural numbers, so if we can show the equation holds for all <code>m</code> it will also hold for all <code>n</code> and <code>p</code>. The appropriate instances of the inference rules are:</p><pre><code>-------------------------------
(zero + n) + p ≡ zero + (n + p)

(m + n) + p ≡ m + (n + p)
---------------------------------
(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>If we can demonstrate both of these, then associativity of addition follows by induction.</p>Here is the proposition’s statement and proof:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc"></a><a id="plfa_plfa-part1-Induction-7812" href="../Induction/#plfa_plfa-part1-Induction-7812" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-7820" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-7822" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-7824" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7825" href="../Induction/#plfa_plfa-part1-Induction-7825" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-7827" href="../Induction/#plfa_plfa-part1-Induction-7827" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-7829" href="../Induction/#plfa_plfa-part1-Induction-7829" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-7831" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-7833" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-7834" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-7836" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-7838" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7839" href="../Induction/#plfa_plfa-part1-Induction-7825" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-7841" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7843" href="../Induction/#plfa_plfa-part1-Induction-7827" class="Bound">n</a><a id="plfa_plfa-part1-Induction-7844" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-7846" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7848" href="../Induction/#plfa_plfa-part1-Induction-7829" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-7850" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-7852" href="../Induction/#plfa_plfa-part1-Induction-7825" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-7854" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7856" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7857" href="../Induction/#plfa_plfa-part1-Induction-7827" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-7859" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7861" href="../Induction/#plfa_plfa-part1-Induction-7829" class="Bound">p</a><a id="plfa_plfa-part1-Induction-7862" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-7864" href="../Induction/#plfa_plfa-part1-Induction-7812" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-7872" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-7877" href="../Induction/#plfa_plfa-part1-Induction-7877" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-7879" href="../Induction/#plfa_plfa-part1-Induction-7879" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-7881" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-7885" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-7895" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7896" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-7901" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7903" href="../Induction/#plfa_plfa-part1-Induction-7877" class="Bound">n</a><a id="plfa_plfa-part1-Induction-7904" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-7906" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7908" href="../Induction/#plfa_plfa-part1-Induction-7879" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-7912" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-7920" href="../Induction/#plfa_plfa-part1-Induction-7877" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-7922" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7924" href="../Induction/#plfa_plfa-part1-Induction-7879" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-7928" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-7936" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-7941" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7943" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7944" href="../Induction/#plfa_plfa-part1-Induction-7877" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-7946" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7948" href="../Induction/#plfa_plfa-part1-Induction-7879" class="Bound">p</a><a id="plfa_plfa-part1-Induction-7949" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-7953" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-7955" href="../Induction/#plfa_plfa-part1-Induction-7812" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-7963" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7964" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-7968" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a><a id="plfa_plfa-part1-Induction-7969" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-7971" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-7973" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-7975" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-7979" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-7989" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-7990" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-7994" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-7996" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-7998" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a><a id="plfa_plfa-part1-Induction-7999" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-8001" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8003" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-8007" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-8015" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-8019" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-8020" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-8022" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8024" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a><a id="plfa_plfa-part1-Induction-8025" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-8027" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8029" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-8033" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-8041" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-8045" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-8047" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-8049" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8051" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a><a id="plfa_plfa-part1-Induction-8052" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-8054" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8056" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a><a id="plfa_plfa-part1-Induction-8057" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-8061" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-8064" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-8069" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-8073" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-8074" href="../Induction/#plfa_plfa-part1-Induction-7812" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-8082" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-8084" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-8086" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a><a id="plfa_plfa-part1-Induction-8087" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-8089" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-8095" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-8099" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-8100" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-8102" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8104" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-8105" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-8107" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8109" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a><a id="plfa_plfa-part1-Induction-8110" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-8115" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-8123" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-8127" href="../Induction/#plfa_plfa-part1-Induction-7968" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-8129" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8131" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-8132" href="../Induction/#plfa_plfa-part1-Induction-7971" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-8134" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-8136" href="../Induction/#plfa_plfa-part1-Induction-7973" class="Bound">p</a><a id="plfa_plfa-part1-Induction-8137" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-8141" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>We have named the proof <code>+-assoc</code>. In Agda, identifiers can consist of any sequence of characters not including spaces or the characters <code>@.(){};_</code>.</p><p>Let’s unpack this code. The signature states that we are defining the identifier <code>+-assoc</code> which provides evidence for the proposition:</p><pre><code>∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>The upside down A is pronounced “for all”, and the proposition asserts that for all natural numbers <code>m</code>, <code>n</code>, and <code>p</code> the equation <code>(m + n) + p ≡ m + (n + p)</code> holds. Evidence for the proposition is a function that accepts three natural numbers, binds them to <code>m</code>, <code>n</code>, and <code>p</code>, and returns evidence for the corresponding instance of the equation.</p><p>For the base case, we must show:</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>Simplifying both sides with the base case of addition yields the equation:</p><pre><code>n + p ≡ n + p</code></pre><p>This holds trivially. Reading the chain of equations in the base case of the proof, the top and bottom of the chain match the two sides of the equation to be shown, and reading down from the top and up from the bottom takes us to <code>n + p</code> in the middle. No justification other than simplification is required.</p><p>For the inductive case, we must show:</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>Simplifying both sides with the inductive case of addition yields the equation:</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This in turn follows by prefacing <code>suc</code> to both sides of the induction hypothesis:</p><pre><code>(m + n) + p ≡ m + (n + p)</code></pre><p>Reading the chain of equations in the inductive case of the proof, the top and bottom of the chain match the two sides of the equation to be shown, and reading down from the top and up from the bottom takes us to the simplified equation above. The remaining equation does not follow from simplification alone, so we use an additional operator for chain reasoning, <code>_≡⟨_⟩_</code>, where a justification for the equation appears within angle brackets. The justification given is:</p><pre><code>⟨ cong suc (+-assoc m n p) ⟩</code></pre><p>Here, the recursive invocation <code>+-assoc m n p</code> has as its type the induction hypothesis, and <code>cong suc</code> prefaces <code>suc</code> to each side to yield the needed equation.</p><p>A relation is said to be a <em>congruence</em> for a given function if it is preserved by applying that function. If <code>e</code> is evidence that <code>x ≡ y</code>, then <code>cong f e</code> is evidence that <code>f x ≡ f y</code>, for any function <code>f</code>.</p><p>Here the inductive hypothesis is not assumed, but instead proved by a recursive invocation of the function we are defining, <code>+-assoc m n p</code>. As with addition, this is well founded because associativity of larger numbers is proved in terms of associativity of smaller numbers. In this case, <code>assoc (suc m) n p</code> is proved using <code>assoc m n p</code>. The correspondence between proof by induction and definition by recursion is one of the most appealing aspects of Agda.</p><h2 id="induction-as-recursion">Induction as recursion</h2><p>As a concrete example of how induction corresponds to recursion, here is the computation that occurs when instantiating <code>m</code> to <code>2</code> in the proof of associativity.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc-0"></a><a id="plfa_plfa-part1-Induction-11168" href="../Induction/#plfa_plfa-part1-Induction-11168" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-11178" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11180" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11182" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11183" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11185" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11187" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11189" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11190" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11192" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11194" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11195" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11197" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11199" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11200" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11202" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11204" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11206" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11208" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11210" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11212" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11213" href="../Induction/#plfa_plfa-part1-Induction-11183" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11215" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11217" href="../Induction/#plfa_plfa-part1-Induction-11185" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11218" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11220" href="../Induction/#plfa_plfa-part1-Induction-11168" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-11230" href="../Induction/#plfa_plfa-part1-Induction-11230" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11232" href="../Induction/#plfa_plfa-part1-Induction-11232" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11234" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11238" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11248" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11249" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11251" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11253" href="../Induction/#plfa_plfa-part1-Induction-11230" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11254" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11256" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11258" href="../Induction/#plfa_plfa-part1-Induction-11232" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11262" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11270" href="../Induction/#plfa_plfa-part1-Induction-11230" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11272" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11274" href="../Induction/#plfa_plfa-part1-Induction-11232" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11278" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11286" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11288" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11290" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11291" href="../Induction/#plfa_plfa-part1-Induction-11230" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11293" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11295" href="../Induction/#plfa_plfa-part1-Induction-11232" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11296" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11300" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-1"></a><a id="plfa_plfa-part1-Induction-11303" href="../Induction/#plfa_plfa-part1-Induction-11303" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-11313" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11315" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11317" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11318" href="../Induction/#plfa_plfa-part1-Induction-11318" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11320" href="../Induction/#plfa_plfa-part1-Induction-11320" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11322" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11324" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11325" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11327" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11329" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11330" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11332" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11334" href="../Induction/#plfa_plfa-part1-Induction-11318" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11335" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11337" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11339" href="../Induction/#plfa_plfa-part1-Induction-11320" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11341" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11343" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11345" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11347" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11348" href="../Induction/#plfa_plfa-part1-Induction-11318" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11350" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11352" href="../Induction/#plfa_plfa-part1-Induction-11320" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11353" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11355" href="../Induction/#plfa_plfa-part1-Induction-11303" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-11365" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11367" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11369" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11373" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11383" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11384" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11386" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11388" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11389" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11391" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11393" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11397" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11405" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11409" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11410" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11412" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11414" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11415" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11417" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11419" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11423" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11431" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11435" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11437" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11439" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11441" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11442" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11444" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11446" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11447" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11451" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11454" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11459" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11463" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11464" href="../Induction/#plfa_plfa-part1-Induction-11168" class="Function">+-assoc-0</a> <a id="plfa_plfa-part1-Induction-11474" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11476" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11477" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11479" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11485" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11489" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11490" class="Number">0</a> <a id="plfa_plfa-part1-Induction-11492" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11494" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11495" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11497" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11499" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11500" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11505" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11513" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11515" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11517" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11518" href="../Induction/#plfa_plfa-part1-Induction-11365" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11520" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11522" href="../Induction/#plfa_plfa-part1-Induction-11367" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11523" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11527" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>

<a id="plfa_plfa-part1-Induction-+-assoc-2"></a><a id="plfa_plfa-part1-Induction-11530" href="../Induction/#plfa_plfa-part1-Induction-11530" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-11540" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11542" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-11544" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11545" href="../Induction/#plfa_plfa-part1-Induction-11545" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11547" href="../Induction/#plfa_plfa-part1-Induction-11547" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11549" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-11551" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-11552" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11554" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-11556" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11557" class="Number">2</a> <a id="plfa_plfa-part1-Induction-11559" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11561" href="../Induction/#plfa_plfa-part1-Induction-11545" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11562" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11564" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11566" href="../Induction/#plfa_plfa-part1-Induction-11547" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11568" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-11570" class="Number">2</a> <a id="plfa_plfa-part1-Induction-11572" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11574" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11575" href="../Induction/#plfa_plfa-part1-Induction-11545" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11577" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11579" href="../Induction/#plfa_plfa-part1-Induction-11547" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11580" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-11582" href="../Induction/#plfa_plfa-part1-Induction-11530" class="Function">+-assoc-2</a> <a id="plfa_plfa-part1-Induction-11592" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11594" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-11596" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-11600" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-11610" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11611" class="Number">2</a> <a id="plfa_plfa-part1-Induction-11613" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11615" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11616" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11618" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11620" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11624" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11632" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11636" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11637" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11639" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11641" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11642" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11644" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11646" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a>
  <a id="plfa_plfa-part1-Induction-11650" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11658" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11662" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-11664" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11666" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11668" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a><a id="plfa_plfa-part1-Induction-11669" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11671" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11673" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11674" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11678" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-11681" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-11686" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11690" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11691" href="../Induction/#plfa_plfa-part1-Induction-11303" class="Function">+-assoc-1</a> <a id="plfa_plfa-part1-Induction-11701" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11703" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11704" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-11706" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-11712" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-11716" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11717" class="Number">1</a> <a id="plfa_plfa-part1-Induction-11719" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11721" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11722" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11724" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11726" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11727" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-11732" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-11740" class="Number">2</a> <a id="plfa_plfa-part1-Induction-11742" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11744" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-11745" href="../Induction/#plfa_plfa-part1-Induction-11592" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-11747" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-11749" href="../Induction/#plfa_plfa-part1-Induction-11594" class="Bound">p</a><a id="plfa_plfa-part1-Induction-11750" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-11754" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><h2 id="terminology-and-notation">Terminology and notation</h2><p>The symbol <code>∀</code> appears in the statement of associativity to indicate that it holds for all numbers <code>m</code>, <code>n</code>, and <code>p</code>. We refer to <code>∀</code> as the <em>universal quantifier</em>, and it is discussed further in Chapter <a href="../Quantifiers/">Quantifiers</a>.</p><p>Evidence for a universal quantifier is a function. The signatures</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>and</p><pre><code>+-assoc : ∀ (m : ℕ) → ∀ (n : ℕ) → ∀ (p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>are equivalent. They differ from a function type such as <code>ℕ → ℕ → ℕ</code> in that variables are associated with each argument type, and the result type may mention (or depend upon) these variables; hence they are called <em>dependent functions</em>.</p><p>Ordinary functions are a special case of dependent functions. For instance, the signatures</p><pre><code>_+_ : ℕ → ℕ → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m n : ℕ) → ℕ</code></pre><p>and</p><pre><code>_+_ : ∀ (m : ℕ) → ∀ (n : ℕ) → ℕ</code></pre><p>are all equivalent.</p><h2 id="our-second-proof-commutativity">Our second proof: commutativity</h2><p>Another important property of addition is that it is <em>commutative</em>, that is, that the order of the operands does not matter:</p><pre><code>m + n ≡ n + m</code></pre><p>The proof requires that we first demonstrate two lemmas.</p><h3 id="the-first-lemma">The first lemma</h3><p>The base case of the definition of addition states that zero is a left-identity:</p><pre><code>zero + n ≡ n</code></pre><p>Our first lemma states that zero is also a right-identity:</p><pre><code>m + zero ≡ m</code></pre>Here is the lemma’s statement and proof:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identityʳ"></a><a id="plfa_plfa-part1-Induction-13170" href="../Induction/#plfa_plfa-part1-Induction-13170" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-13182" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-13184" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-13186" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-13187" href="../Induction/#plfa_plfa-part1-Induction-13187" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-13189" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-13191" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-13192" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-13194" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-13196" href="../Induction/#plfa_plfa-part1-Induction-13187" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-13198" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-13200" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-13205" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-13207" href="../Induction/#plfa_plfa-part1-Induction-13187" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-13209" href="../Induction/#plfa_plfa-part1-Induction-13170" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-13221" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-13226" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-13230" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-13240" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-13245" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-13247" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-13254" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-13262" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-13269" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-13271" href="../Induction/#plfa_plfa-part1-Induction-13170" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-13283" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-13284" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-13288" href="../Induction/#plfa_plfa-part1-Induction-13288" class="Bound">m</a><a id="plfa_plfa-part1-Induction-13289" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-13291" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-13295" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-13305" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-13309" href="../Induction/#plfa_plfa-part1-Induction-13288" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-13311" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-13313" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-13320" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-13328" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-13332" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-13333" href="../Induction/#plfa_plfa-part1-Induction-13288" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-13335" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-13337" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Induction-13341" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-13345" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-13348" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-13353" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-13357" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-13358" href="../Induction/#plfa_plfa-part1-Induction-13170" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-13370" href="../Induction/#plfa_plfa-part1-Induction-13288" class="Bound">m</a><a id="plfa_plfa-part1-Induction-13371" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-13373" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-13379" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-13383" href="../Induction/#plfa_plfa-part1-Induction-13288" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-13387" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The signature states that we are defining the identifier <code>+-identityʳ</code> which provides evidence for the proposition:</p><pre><code>∀ (m : ℕ) → m + zero ≡ m</code></pre><p>Evidence for the proposition is a function that accepts a natural number, binds it to <code>m</code>, and returns evidence for the corresponding instance of the equation. The proof is by induction on <code>m</code>.</p><p>For the base case, we must show:</p><pre><code>zero + zero ≡ zero</code></pre><p>Simplifying with the base case of addition, this is straightforward.</p><p>For the inductive case, we must show:</p><pre><code>(suc m) + zero = suc m</code></pre><p>Simplifying both sides with the inductive case of addition yields the equation:</p><pre><code>suc (m + zero) = suc m</code></pre><p>This in turn follows by prefacing <code>suc</code> to both sides of the induction hypothesis:</p><pre><code>m + zero ≡ m</code></pre><p>Reading the chain of equations down from the top and up from the bottom takes us to the simplified equation above. The remaining equation has the justification:</p><pre><code>⟨ cong suc (+-identityʳ m) ⟩</code></pre><p>Here, the recursive invocation <code>+-identityʳ m</code> has as its type the induction hypothesis, and <code>cong suc</code> prefaces <code>suc</code> to each side to yield the needed equation. This completes the first lemma.</p><h3 id="the-second-lemma">The second lemma</h3><p>The inductive case of the definition of addition pushes <code>suc</code> on the first argument to the outside:</p><pre><code>suc m + n ≡ suc (m + n)</code></pre><p>Our second lemma does the same for <code>suc</code> on the second argument:</p><pre><code>m + suc n ≡ suc (m + n)</code></pre>Here is the lemma’s statement and proof:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-suc"></a><a id="plfa_plfa-part1-Induction-14831" href="../Induction/#plfa_plfa-part1-Induction-14831" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-14837" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-14839" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-14841" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-14842" href="../Induction/#plfa_plfa-part1-Induction-14842" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-14844" href="../Induction/#plfa_plfa-part1-Induction-14844" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-14846" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-14848" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-14849" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-14851" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-14853" href="../Induction/#plfa_plfa-part1-Induction-14842" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-14855" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-14857" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14861" href="../Induction/#plfa_plfa-part1-Induction-14844" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-14863" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-14865" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14869" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-14870" href="../Induction/#plfa_plfa-part1-Induction-14842" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-14872" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-14874" href="../Induction/#plfa_plfa-part1-Induction-14844" class="Bound">n</a><a id="plfa_plfa-part1-Induction-14875" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-14877" href="../Induction/#plfa_plfa-part1-Induction-14831" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-14883" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-14888" href="../Induction/#plfa_plfa-part1-Induction-14888" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-14890" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-14894" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-14904" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-14909" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-14911" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14915" href="../Induction/#plfa_plfa-part1-Induction-14888" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-14919" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-14927" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14931" href="../Induction/#plfa_plfa-part1-Induction-14888" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-14935" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-14943" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14947" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-14948" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-14953" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-14955" href="../Induction/#plfa_plfa-part1-Induction-14888" class="Bound">n</a><a id="plfa_plfa-part1-Induction-14956" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-14960" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-14962" href="../Induction/#plfa_plfa-part1-Induction-14831" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-14968" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-14969" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14973" href="../Induction/#plfa_plfa-part1-Induction-14973" class="Bound">m</a><a id="plfa_plfa-part1-Induction-14974" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-14976" href="../Induction/#plfa_plfa-part1-Induction-14976" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-14978" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-14982" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-14992" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-14996" href="../Induction/#plfa_plfa-part1-Induction-14973" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-14998" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15000" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15004" href="../Induction/#plfa_plfa-part1-Induction-14976" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-15008" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15016" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15020" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15021" href="../Induction/#plfa_plfa-part1-Induction-14973" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-15023" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15025" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15029" href="../Induction/#plfa_plfa-part1-Induction-14976" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15030" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15034" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-15037" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-15042" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15046" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15047" href="../Induction/#plfa_plfa-part1-Induction-14831" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-15053" href="../Induction/#plfa_plfa-part1-Induction-14973" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-15055" href="../Induction/#plfa_plfa-part1-Induction-14976" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15056" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-15058" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-15064" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15068" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15069" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15073" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15074" href="../Induction/#plfa_plfa-part1-Induction-14973" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-15076" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15078" href="../Induction/#plfa_plfa-part1-Induction-14976" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15079" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Induction-15084" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-15092" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15096" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-15097" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-15101" href="../Induction/#plfa_plfa-part1-Induction-14973" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-15103" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-15105" href="../Induction/#plfa_plfa-part1-Induction-14976" class="Bound">n</a><a id="plfa_plfa-part1-Induction-15106" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-15110" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The signature states that we are defining the identifier <code>+-suc</code> which provides evidence for the proposition:</p><pre><code>∀ (m n : ℕ) → m + suc n ≡ suc (m + n)</code></pre><p>Evidence for the proposition is a function that accepts two natural numbers, binds them to <code>m</code> and <code>n</code>, and returns evidence for the corresponding instance of the equation. The proof is by induction on <code>m</code>.</p><p>For the base case, we must show:</p><pre><code>zero + suc n ≡ suc (zero + n)</code></pre><p>Simplifying with the base case of addition, this is straightforward.</p><p>For the inductive case, we must show:</p><pre><code>suc m + suc n ≡ suc (suc m + n)</code></pre><p>Simplifying both sides with the inductive case of addition yields the equation:</p><pre><code>suc (m + suc n) ≡ suc (suc (m + n))</code></pre><p>This in turn follows by prefacing <code>suc</code> to both sides of the induction hypothesis:</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>Reading the chain of equations down from the top and up from the bottom takes us to the simplified equation in the middle. The remaining equation has the justification:</p><pre><code>⟨ cong suc (+-suc m n) ⟩</code></pre><p>Here, the recursive invocation <code>+-suc m n</code> has as its type the induction hypothesis, and <code>cong suc</code> prefaces <code>suc</code> to each side to yield the needed equation. This completes the second lemma.</p><h3 id="the-proposition">The proposition</h3>Finally, here is our proposition’s statement and proof:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-comm"></a><a id="plfa_plfa-part1-Induction-16408" href="../Induction/#plfa_plfa-part1-Induction-16408" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-16415" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16417" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-16419" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16420" href="../Induction/#plfa_plfa-part1-Induction-16420" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16422" href="../Induction/#plfa_plfa-part1-Induction-16422" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16424" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-16426" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-16427" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16429" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-16431" href="../Induction/#plfa_plfa-part1-Induction-16420" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16433" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16435" href="../Induction/#plfa_plfa-part1-Induction-16422" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16437" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-16439" href="../Induction/#plfa_plfa-part1-Induction-16422" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16441" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16443" href="../Induction/#plfa_plfa-part1-Induction-16420" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-16445" href="../Induction/#plfa_plfa-part1-Induction-16408" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-16452" href="../Induction/#plfa_plfa-part1-Induction-16452" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16454" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-16459" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-16463" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-16473" href="../Induction/#plfa_plfa-part1-Induction-16452" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16475" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16477" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
  <a id="plfa_plfa-part1-Induction-16484" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16487" href="../Induction/#plfa_plfa-part1-Induction-13170" class="Function">+-identityʳ</a> <a id="plfa_plfa-part1-Induction-16499" href="../Induction/#plfa_plfa-part1-Induction-16452" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16501" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16507" href="../Induction/#plfa_plfa-part1-Induction-16452" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-16511" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16519" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-16524" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16526" href="../Induction/#plfa_plfa-part1-Induction-16452" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-16530" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Induction-16532" href="../Induction/#plfa_plfa-part1-Induction-16408" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-16539" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16541" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16542" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16546" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16547" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16549" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-16553" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-16563" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16565" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16567" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16571" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a>
  <a id="plfa_plfa-part1-Induction-16575" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16578" href="../Induction/#plfa_plfa-part1-Induction-14831" class="Function">+-suc</a> <a id="plfa_plfa-part1-Induction-16584" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16586" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16588" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16594" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16598" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16599" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16601" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16603" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16604" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16608" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-16611" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-16616" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16620" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16621" href="../Induction/#plfa_plfa-part1-Induction-16408" class="Function">+-comm</a> <a id="plfa_plfa-part1-Induction-16628" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-16630" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a><a id="plfa_plfa-part1-Induction-16631" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-16633" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-16639" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16643" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-16644" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16646" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16648" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a><a id="plfa_plfa-part1-Induction-16649" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-16653" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Induction-16661" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-16665" href="../Induction/#plfa_plfa-part1-Induction-16546" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-16667" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-16669" href="../Induction/#plfa_plfa-part1-Induction-16539" class="Bound">m</a>
  <a id="plfa_plfa-part1-Induction-16673" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The first line states that we are defining the identifier <code>+-comm</code> which provides evidence for the proposition:</p><pre><code>∀ (m n : ℕ) → m + n ≡ n + m</code></pre><p>Evidence for the proposition is a function that accepts two natural numbers, binds them to <code>m</code> and <code>n</code>, and returns evidence for the corresponding instance of the equation. The proof is by induction on <code>n</code>. (Not on <code>m</code> this time!)</p><p>For the base case, we must show:</p><pre><code>m + zero ≡ zero + m</code></pre><p>Simplifying both sides with the base case of addition yields the equation:</p><pre><code>m + zero ≡ m</code></pre><p>The remaining equation has the justification <code>⟨ +-identityʳ m ⟩</code>, which invokes the first lemma.</p><p>For the inductive case, we must show:</p><pre><code>m + suc n ≡ suc n + m</code></pre><p>Simplifying both sides with the inductive case of addition yields the equation:</p><pre><code>m + suc n ≡ suc (n + m)</code></pre><p>We show this in two steps. First, we have:</p><pre><code>m + suc n ≡ suc (m + n)</code></pre><p>which is justified by the second lemma, <code>⟨ +-suc m n ⟩</code>. Then we have</p><pre><code>suc (m + n) ≡ suc (n + m)</code></pre><p>which is justified by congruence and the induction hypothesis, <code>⟨ cong suc (+-comm m n) ⟩</code>. This completes the proof.</p><p>Agda requires that identifiers are defined before they are used, so we must present the lemmas before the main proposition, as we have done above. In practice, one will often attempt to prove the main proposition first, and the equations required to do so will suggest what lemmas to prove.</p><h2 id="sections">Our first corollary: rearranging</h2>We can apply associativity to rearrange parentheses however we like. Here is an example:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-rearrange"></a><a id="plfa_plfa-part1-Induction-18223" href="../Induction/#plfa_plfa-part1-Induction-18223" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-18235" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18237" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-18239" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18240" href="../Induction/#plfa_plfa-part1-Induction-18240" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18242" href="../Induction/#plfa_plfa-part1-Induction-18242" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-18244" href="../Induction/#plfa_plfa-part1-Induction-18244" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-18246" href="../Induction/#plfa_plfa-part1-Induction-18246" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-18248" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-18250" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-18251" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18253" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-18255" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18256" href="../Induction/#plfa_plfa-part1-Induction-18240" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18258" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18260" href="../Induction/#plfa_plfa-part1-Induction-18242" class="Bound">n</a><a id="plfa_plfa-part1-Induction-18261" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18263" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18265" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18266" href="../Induction/#plfa_plfa-part1-Induction-18244" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-18268" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18270" href="../Induction/#plfa_plfa-part1-Induction-18246" class="Bound">q</a><a id="plfa_plfa-part1-Induction-18271" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18273" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-18275" href="../Induction/#plfa_plfa-part1-Induction-18240" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18277" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18279" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18280" href="../Induction/#plfa_plfa-part1-Induction-18242" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-18282" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18284" href="../Induction/#plfa_plfa-part1-Induction-18244" class="Bound">p</a><a id="plfa_plfa-part1-Induction-18285" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18287" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18289" href="../Induction/#plfa_plfa-part1-Induction-18246" class="Bound">q</a>
<a id="plfa_plfa-part1-Induction-18291" href="../Induction/#plfa_plfa-part1-Induction-18223" class="Function">+-rearrange</a> <a id="plfa_plfa-part1-Induction-18303" href="../Induction/#plfa_plfa-part1-Induction-18303" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18305" href="../Induction/#plfa_plfa-part1-Induction-18305" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-18307" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-18309" href="../Induction/#plfa_plfa-part1-Induction-18309" class="Bound">q</a> <a id="plfa_plfa-part1-Induction-18311" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Induction-18315" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Induction-18325" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18326" href="../Induction/#plfa_plfa-part1-Induction-18303" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18328" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18330" href="../Induction/#plfa_plfa-part1-Induction-18305" class="Bound">n</a><a id="plfa_plfa-part1-Induction-18331" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18333" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18335" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18336" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-18338" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18340" href="../Induction/#plfa_plfa-part1-Induction-18309" class="Bound">q</a><a id="plfa_plfa-part1-Induction-18341" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Induction-18345" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18348" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Induction-18352" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18353" href="../Induction/#plfa_plfa-part1-Induction-7812" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-18361" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18362" href="../Induction/#plfa_plfa-part1-Induction-18303" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18364" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18366" href="../Induction/#plfa_plfa-part1-Induction-18305" class="Bound">n</a><a id="plfa_plfa-part1-Induction-18367" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18369" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-18371" href="../Induction/#plfa_plfa-part1-Induction-18309" class="Bound">q</a><a id="plfa_plfa-part1-Induction-18372" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18374" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18380" class="Symbol">((</a><a id="plfa_plfa-part1-Induction-18382" href="../Induction/#plfa_plfa-part1-Induction-18303" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18384" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18386" href="../Induction/#plfa_plfa-part1-Induction-18305" class="Bound">n</a><a id="plfa_plfa-part1-Induction-18387" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18389" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18391" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">p</a><a id="plfa_plfa-part1-Induction-18392" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18394" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18396" href="../Induction/#plfa_plfa-part1-Induction-18309" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-18400" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Induction-18403" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Induction-18408" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18409" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="plfa_plfa-part1-Induction-18412" href="../Induction/#plfa_plfa-part1-Induction-18309" class="Bound">q</a><a id="plfa_plfa-part1-Induction-18413" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18415" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18416" href="../Induction/#plfa_plfa-part1-Induction-7812" class="Function">+-assoc</a> <a id="plfa_plfa-part1-Induction-18424" href="../Induction/#plfa_plfa-part1-Induction-18303" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18426" href="../Induction/#plfa_plfa-part1-Induction-18305" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-18428" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">p</a><a id="plfa_plfa-part1-Induction-18429" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-18431" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Induction-18437" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18438" href="../Induction/#plfa_plfa-part1-Induction-18303" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-18440" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18442" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-18443" href="../Induction/#plfa_plfa-part1-Induction-18305" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-18445" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18447" href="../Induction/#plfa_plfa-part1-Induction-18307" class="Bound">p</a><a id="plfa_plfa-part1-Induction-18448" class="Symbol">))</a> <a id="plfa_plfa-part1-Induction-18451" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-18453" href="../Induction/#plfa_plfa-part1-Induction-18309" class="Bound">q</a>
  <a id="plfa_plfa-part1-Induction-18457" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>No induction is required, we simply apply associativity twice. A few points are worthy of note.</p><p>First, addition associates to the left, so <code>m + (n + p) + q</code> stands for <code>(m + (n + p)) + q</code>.</p><p>Second, we use <code>sym</code> to interchange the sides of an equation. Proposition <code>+-assoc (m + n) p q</code> shifts parentheses from left to right:</p><pre><code>((m + n) + p) + q ≡ (m + n) + (p + q)</code></pre><p>To shift them the other way, we use <code>sym (+-assoc (m + n) p q)</code>:</p><pre><code>(m + n) + (p + q) ≡ ((m + n) + p) + q</code></pre><p>In general, if <code>e</code> provides evidence for <code>x ≡ y</code> then <code>sym e</code> provides evidence for <code>y ≡ x</code>.</p><p>Third, Agda supports a variant of the <em>section</em> notation introduced by Richard Bird. We write <code>(_+ y)</code> for the function that applied to <code>x</code> returns <code>x + y</code>. Thus, applying the congruence <code>cong (_+ q)</code> to <code>assoc m n p</code> takes the equation:</p><pre><code>(m + n) + p  ≡  m + (n + p)</code></pre><p>into the equation:</p><pre><code>((m + n) + p) + q  ≡  (m + (n + p)) + q</code></pre><p>Similarly, we write <code>(x +_)</code> for the function that applied to <code>y</code> returns <code>x + y</code>; the same works for any infix operator.</p><h2 id="creation-one-last-time">Creation, one last time</h2><p>Returning to the proof of associativity, it may be helpful to view the inductive proof (or, equivalently, the recursive definition) as a creation story. This time we are concerned with judgments asserting associativity:</p><pre><code> -- In the beginning, we know nothing about associativity.</code></pre><p>Now, we apply the rules to all the judgments we know about. The base case tells us that <code>(zero + n) + p ≡ zero + (n + p)</code> for every natural <code>n</code> and <code>p</code>. The inductive case tells us that if <code>(m + n) + p ≡ m + (n + p)</code> (on the day before today) then <code>(suc m + n) + p ≡ suc m + (n + p)</code> (today). We didn’t know any judgments about associativity before today, so that rule doesn’t give us any new judgments:</p><pre><code>-- On the first day, we know about associativity of 0.
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...</code></pre><p>Then we repeat the process, so on the next day we know about all the judgments from the day before, plus any judgments added by the rules. The base case tells us nothing new, but now the inductive case adds more judgments:</p><pre><code>-- On the second day, we know about associativity of 0 and 1.
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...</code></pre><p>And we repeat the process again:</p><pre><code>-- On the third day, we know about associativity of 0, 1, and 2.
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...</code></pre><p>You’ve got the hang of it by now:</p><pre><code>-- On the fourth day, we know about associativity of 0, 1, 2, and 3.
(0 + 0) + 0 ≡ 0 + (0 + 0)   ...   (0 + 4) + 5 ≡ 0 + (4 + 5)   ...
(1 + 0) + 0 ≡ 1 + (0 + 0)   ...   (1 + 4) + 5 ≡ 1 + (4 + 5)   ...
(2 + 0) + 0 ≡ 2 + (0 + 0)   ...   (2 + 4) + 5 ≡ 2 + (4 + 5)   ...
(3 + 0) + 0 ≡ 3 + (0 + 0)   ...   (3 + 4) + 5 ≡ 3 + (4 + 5)   ...</code></pre><p>The process continues. On the <em>m</em>’th day we will know all the judgments where the first number is less than <em>m</em>.</p><p>There is also a completely finite approach to generating the same equations, which is left as an exercise for the reader.</p><h4 id="finite-plus-assoc">Exercise <code>finite-+-assoc</code> (stretch)</h4><p>Write out what is known about associativity of addition on each of the first four days using a finite story of creation, as <a href="../Naturals/#finite-creation">earlier</a>.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-21958" class="Comment">-- Your code goes here</a>
</pre><h2 id="associativity-with-rewrite">Associativity with rewrite</h2>There is more than one way to skin a cat. Here is a second proof of associativity of addition in Agda, using <code>rewrite</code> rather than chains of equations:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-assoc′"></a><a id="plfa_plfa-part1-Induction-22178" href="../Induction/#plfa_plfa-part1-Induction-22178" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-22187" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22189" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-22191" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22192" href="../Induction/#plfa_plfa-part1-Induction-22192" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22194" href="../Induction/#plfa_plfa-part1-Induction-22194" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22196" href="../Induction/#plfa_plfa-part1-Induction-22196" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-22198" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-22200" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-22201" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22203" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-22205" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22206" href="../Induction/#plfa_plfa-part1-Induction-22192" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22208" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22210" href="../Induction/#plfa_plfa-part1-Induction-22194" class="Bound">n</a><a id="plfa_plfa-part1-Induction-22211" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22213" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22215" href="../Induction/#plfa_plfa-part1-Induction-22196" class="Bound">p</a> <a id="plfa_plfa-part1-Induction-22217" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-22219" href="../Induction/#plfa_plfa-part1-Induction-22192" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22221" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22223" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22224" href="../Induction/#plfa_plfa-part1-Induction-22194" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22226" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-22228" href="../Induction/#plfa_plfa-part1-Induction-22196" class="Bound">p</a><a id="plfa_plfa-part1-Induction-22229" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-22231" href="../Induction/#plfa_plfa-part1-Induction-22178" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-22240" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="plfa_plfa-part1-Induction-22248" href="../Induction/#plfa_plfa-part1-Induction-22248" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22250" href="../Induction/#plfa_plfa-part1-Induction-22250" class="Bound">p</a>                          <a id="plfa_plfa-part1-Induction-22277" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-22280" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-22285" href="../Induction/#plfa_plfa-part1-Induction-22178" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-22294" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-22295" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-22299" href="../Induction/#plfa_plfa-part1-Induction-22299" class="Bound">m</a><a id="plfa_plfa-part1-Induction-22300" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-22302" href="../Induction/#plfa_plfa-part1-Induction-22302" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22304" href="../Induction/#plfa_plfa-part1-Induction-22304" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-22307" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-22315" href="../Induction/#plfa_plfa-part1-Induction-22178" class="Function">+-assoc′</a> <a id="plfa_plfa-part1-Induction-22324" href="../Induction/#plfa_plfa-part1-Induction-22299" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-22326" href="../Induction/#plfa_plfa-part1-Induction-22302" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-22328" href="../Induction/#plfa_plfa-part1-Induction-22304" class="Bound">p</a>  <a id="plfa_plfa-part1-Induction-22331" class="Symbol">=</a>  <a id="plfa_plfa-part1-Induction-22334" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>For the base case, we must show:</p><pre><code>(zero + n) + p ≡ zero + (n + p)</code></pre><p>Simplifying both sides with the base case of addition yields the equation:</p><pre><code>n + p ≡ n + p</code></pre><p>This holds trivially. The proof that a term is equal to itself is written <code>refl</code>.</p><p>For the inductive case, we must show:</p><pre><code>(suc m + n) + p ≡ suc m + (n + p)</code></pre><p>Simplifying both sides with the inductive case of addition yields the equation:</p><pre><code>suc ((m + n) + p) ≡ suc (m + (n + p))</code></pre><p>This is our goal to be proved. Rewriting by a given equation is indicated by the keyword <code>rewrite</code> followed by a proof of that equation. Rewriting replaces each occurrence of the left-hand side of the equation in the goal by the right-hand side. In this case, after rewriting by the inductive hypothesis our goal becomes</p><pre><code>suc (m + (n + p)) ≡ suc (m + (n + p))</code></pre><p>and the proof is again given by <code>refl</code>. Rewriting avoids not only chains of equations but also the need to invoke <code>cong</code>.</p><h2 id="commutativity-with-rewrite">Commutativity with rewrite</h2>Here is a second proof of commutativity of addition, using <code>rewrite</code> rather than chains of equations:<pre class="Agda"><a id="plfa_plfa-part1-Induction-+-identity′"></a><a id="plfa_plfa-part1-Induction-23429" href="../Induction/#plfa_plfa-part1-Induction-23429" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-23441" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-23443" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-23445" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23446" href="../Induction/#plfa_plfa-part1-Induction-23446" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23448" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-23450" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-23451" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-23453" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-23455" href="../Induction/#plfa_plfa-part1-Induction-23446" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23457" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-23459" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-23464" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-23466" href="../Induction/#plfa_plfa-part1-Induction-23446" class="Bound">n</a>
<a id="plfa_plfa-part1-Induction-23468" href="../Induction/#plfa_plfa-part1-Induction-23429" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-23480" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-23485" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-23487" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-23492" href="../Induction/#plfa_plfa-part1-Induction-23429" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-23504" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23505" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-23509" href="../Induction/#plfa_plfa-part1-Induction-23509" class="Bound">n</a><a id="plfa_plfa-part1-Induction-23510" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-23512" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-23520" href="../Induction/#plfa_plfa-part1-Induction-23429" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-23532" href="../Induction/#plfa_plfa-part1-Induction-23509" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23534" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-23536" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-suc′"></a><a id="plfa_plfa-part1-Induction-23542" href="../Induction/#plfa_plfa-part1-Induction-23542" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-23549" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-23551" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-23553" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23554" href="../Induction/#plfa_plfa-part1-Induction-23554" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23556" href="../Induction/#plfa_plfa-part1-Induction-23556" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23558" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-23560" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-23561" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-23563" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-23565" href="../Induction/#plfa_plfa-part1-Induction-23554" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23567" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-23569" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-23573" href="../Induction/#plfa_plfa-part1-Induction-23556" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23575" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-23577" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-23581" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23582" href="../Induction/#plfa_plfa-part1-Induction-23554" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23584" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-23586" href="../Induction/#plfa_plfa-part1-Induction-23556" class="Bound">n</a><a id="plfa_plfa-part1-Induction-23587" class="Symbol">)</a>
<a id="plfa_plfa-part1-Induction-23589" href="../Induction/#plfa_plfa-part1-Induction-23542" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-23596" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-23601" href="../Induction/#plfa_plfa-part1-Induction-23601" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23603" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-23605" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-23610" href="../Induction/#plfa_plfa-part1-Induction-23542" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-23617" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23618" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-23622" href="../Induction/#plfa_plfa-part1-Induction-23622" class="Bound">m</a><a id="plfa_plfa-part1-Induction-23623" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-23625" href="../Induction/#plfa_plfa-part1-Induction-23625" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23627" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-23635" href="../Induction/#plfa_plfa-part1-Induction-23542" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-23642" href="../Induction/#plfa_plfa-part1-Induction-23622" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23644" href="../Induction/#plfa_plfa-part1-Induction-23625" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23646" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-23648" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Induction-+-comm′"></a><a id="plfa_plfa-part1-Induction-23654" href="../Induction/#plfa_plfa-part1-Induction-23654" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-23662" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-23664" class="Symbol">∀</a> <a id="plfa_plfa-part1-Induction-23666" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23667" href="../Induction/#plfa_plfa-part1-Induction-23667" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23669" href="../Induction/#plfa_plfa-part1-Induction-23669" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23671" class="Symbol">:</a> <a id="plfa_plfa-part1-Induction-23673" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Induction-23674" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-23676" class="Symbol">→</a> <a id="plfa_plfa-part1-Induction-23678" href="../Induction/#plfa_plfa-part1-Induction-23667" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23680" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-23682" href="../Induction/#plfa_plfa-part1-Induction-23669" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23684" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Induction-23686" href="../Induction/#plfa_plfa-part1-Induction-23669" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23688" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Induction-23690" href="../Induction/#plfa_plfa-part1-Induction-23667" class="Bound">m</a>
<a id="plfa_plfa-part1-Induction-23692" href="../Induction/#plfa_plfa-part1-Induction-23654" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-23700" href="../Induction/#plfa_plfa-part1-Induction-23700" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23702" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Induction-23707" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-23715" href="../Induction/#plfa_plfa-part1-Induction-23429" class="Function">+-identity′</a> <a id="plfa_plfa-part1-Induction-23727" href="../Induction/#plfa_plfa-part1-Induction-23700" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23729" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-23731" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="plfa_plfa-part1-Induction-23736" href="../Induction/#plfa_plfa-part1-Induction-23654" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-23744" href="../Induction/#plfa_plfa-part1-Induction-23744" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23746" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-23747" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Induction-23751" href="../Induction/#plfa_plfa-part1-Induction-23751" class="Bound">n</a><a id="plfa_plfa-part1-Induction-23752" class="Symbol">)</a> <a id="plfa_plfa-part1-Induction-23754" class="Keyword">rewrite</a> <a id="plfa_plfa-part1-Induction-23762" href="../Induction/#plfa_plfa-part1-Induction-23542" class="Function">+-suc′</a> <a id="plfa_plfa-part1-Induction-23769" href="../Induction/#plfa_plfa-part1-Induction-23744" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23771" href="../Induction/#plfa_plfa-part1-Induction-23751" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23773" class="Symbol">|</a> <a id="plfa_plfa-part1-Induction-23775" href="../Induction/#plfa_plfa-part1-Induction-23654" class="Function">+-comm′</a> <a id="plfa_plfa-part1-Induction-23783" href="../Induction/#plfa_plfa-part1-Induction-23744" class="Bound">m</a> <a id="plfa_plfa-part1-Induction-23785" href="../Induction/#plfa_plfa-part1-Induction-23751" class="Bound">n</a> <a id="plfa_plfa-part1-Induction-23787" class="Symbol">=</a> <a id="plfa_plfa-part1-Induction-23789" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>In the final line, rewriting with two equations is indicated by separating the two proofs of the relevant equations by a vertical bar; the rewrite on the left is performed before that on the right.</p><h2 id="building-proofs-interactively">Building proofs interactively</h2><p>It is instructive to see how to build the alternative proof of associativity using the interactive features of Agda in Emacs. Begin by typing:</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = ?</code></pre><p>The question mark indicates that you would like Agda to help with filling in that part of the code. If you type <code>C-c C-l</code> (control-c followed by control-l), the question mark will be replaced:</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ m n p = { }0</code></pre><p>The empty braces are called a <em>hole</em>, and 0 is a number used for referring to the hole. The hole may display highlighted in green. Emacs will also create a new window at the bottom of the screen displaying the text:</p><pre><code>?0 : ((m + n) + p) ≡ (m + (n + p))</code></pre><p>This indicates that hole 0 is to be filled in with a proof of the stated judgment.</p><p>We wish to prove the proposition by induction on <code>m</code>. Move the cursor into the hole and type <code>C-c C-c</code>. You will be given the prompt:</p><pre><code>pattern variables to case (empty for split on result):</code></pre><p>Typing <code>m</code> will cause a split on that variable, resulting in an update to the code:</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = { }0
+-assoc′ (suc m) n p = { }1</code></pre><p>There are now two holes, and the window at the bottom tells you what each is required to prove:</p><pre><code>?0 : ((zero + n) + p) ≡ (zero + (n + p))
?1 : ((suc m + n) + p) ≡ (suc m + (n + p))</code></pre><p>Going into hole 0 and typing <code>C-c C-,</code> will display the text:</p><pre><code>Goal: (n + p) ≡ (n + p)
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ</code></pre><p>This indicates that after simplification the goal for hole 0 is as stated, and that variables <code>p</code> and <code>n</code> of the stated types are available to use in the proof. The proof of the given goal is trivial, and going into the goal and typing <code>C-c C-r</code> will fill it in. Typing <code>C-c C-l</code> renumbers the remaining hole to 0:</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p = { }0</code></pre><p>Going into the new hole 0 and typing <code>C-c C-,</code> will display the text:</p><pre><code>Goal: suc ((m + n) + p) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>Again, this gives the simplified goal and the available variables. In this case, we need to rewrite by the induction hypothesis, so let’s edit the text accordingly:</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = { }0</code></pre><p>Going into the remaining hole and typing <code>C-c C-,</code> will display the text:</p><pre><code>Goal: suc (m + (n + p)) ≡ suc (m + (n + p))
————————————————————————————————————————————————————————————
p : ℕ
n : ℕ
m : ℕ</code></pre><p>The proof of the given goal is trivial, and going into the goal and typing <code>C-c C-r</code> will fill it in, completing the proof:</p><pre><code>+-assoc′ : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
+-assoc′ zero n p = refl
+-assoc′ (suc m) n p rewrite +-assoc′ m n p = refl</code></pre><h4 id="plus-swap">Exercise <code>+-swap</code> (recommended)</h4><p>Show</p><pre><code>m + (n + p) ≡ n + (m + p)</code></pre><p>for all naturals <code>m</code>, <code>n</code>, and <code>p</code>. No induction is needed, just apply the previous results which show addition is associative and commutative.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-27333" class="Comment">-- Your code goes here</a>
</pre><h4 id="times-distrib-plus">Exercise <code>*-distrib-+</code> (recommended)</h4><p>Show multiplication distributes over addition, that is,</p><pre><code>(m + n) * p ≡ m * p + n * p</code></pre><p>for all naturals <code>m</code>, <code>n</code>, and <code>p</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-27562" class="Comment">-- Your code goes here</a>
</pre><h4 id="times-assoc">Exercise <code>*-assoc</code> (recommended)</h4><p>Show multiplication is associative, that is,</p><pre><code>(m * n) * p ≡ m * (n * p)</code></pre><p>for all naturals <code>m</code>, <code>n</code>, and <code>p</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-27767" class="Comment">-- Your code goes here</a>
</pre><h4 id="times-comm">Exercise <code>*-comm</code> (practice)</h4><p>Show multiplication is commutative, that is,</p><pre><code>m * n ≡ n * m</code></pre><p>for all naturals <code>m</code> and <code>n</code>. As with commutativity of addition, you will need to formulate and prove suitable lemmas.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-28039" class="Comment">-- Your code goes here</a>
</pre><h4 id="zero-monus">Exercise <code>0∸n≡0</code> (practice)</h4><p>Show</p><pre><code>zero ∸ n ≡ zero</code></pre><p>for all naturals <code>n</code>. Did your proof require induction?</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-28208" class="Comment">-- Your code goes here</a>
</pre><h4 id="monus-plus-assoc">Exercise <code>∸-+-assoc</code> (practice)</h4><p>Show that monus associates with addition, that is,</p><pre><code>m ∸ n ∸ p ≡ m ∸ (n + p)</code></pre><p>for all naturals <code>m</code>, <code>n</code>, and <code>p</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-28421" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-stretch">Exercise <code>+*^</code> (stretch)</h4><p>Show the following three laws</p><pre><code> m ^ (n + p) ≡ (m ^ n) * (m ^ p)  (^-distribˡ-+-*)
 (m * n) ^ p ≡ (m ^ p) * (n ^ p)  (^-distribʳ-*)
 (m ^ n) ^ p ≡ m ^ (n * p)        (^-*-assoc)</code></pre><p>for all <code>m</code>, <code>n</code>, and <code>p</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-28703" class="Comment">-- Your code goes here</a>
</pre><h4 id="Bin-laws">Exercise <code>Bin-laws</code> (stretch)</h4><p>Recall that Exercise <a href="../Naturals/#Bin">Bin</a> defines a datatype <code>Bin</code> of bitstrings representing natural numbers, and asks you to define functions</p><pre><code>inc   : Bin → Bin
to    : ℕ → Bin
from  : Bin → ℕ</code></pre><p>Consider the following laws, where <code>n</code> ranges over naturals and <code>b</code> over bitstrings:</p><pre><code>from (inc b) ≡ suc (from b)
to (from b) ≡ b
from (to n) ≡ n</code></pre><p>For each law: if it holds, prove; if not, give a counterexample.</p><pre class="Agda"><a id="plfa_plfa-part1-Induction-29222" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Induction-29363" class="Keyword">import</a> <a id="plfa_plfa-part1-Induction-29370" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Induction-29390" class="Keyword">using</a> <a id="plfa_plfa-part1-Induction-29396" class="Symbol">(</a><a id="plfa_plfa-part1-Induction-29397" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15113" class="Function">+-assoc</a><a id="plfa_plfa-part1-Induction-29404" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-29406" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15269" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Induction-29417" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-29419" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#14905" class="Function">+-suc</a><a id="plfa_plfa-part1-Induction-29424" class="Symbol">;</a> <a id="plfa_plfa-part1-Induction-29426" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15446" class="Function">+-comm</a><a id="plfa_plfa-part1-Induction-29432" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>∀  U+2200  FOR ALL (\forall, \all)
ʳ  U+02B3  MODIFIER LETTER SMALL R (\^r)
′  U+2032  PRIME (\&#39;)
″  U+2033  DOUBLE PRIME (\&#39;)
‴  U+2034  TRIPLE PRIME (\&#39;)
⁗  U+2057  QUADRUPLE PRIME (\&#39;)</code></pre><p>Similar to <code>\r</code>, the command <code>\^r</code> gives access to a variety of superscript rightward arrows, and also a superscript letter <code>r</code>. The command <code>\&#39;</code> gives access to a range of primes (<code>′ ″ ‴ ⁗</code>).</p></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Naturals/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Induction.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Relations/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>