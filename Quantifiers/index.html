<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-Iet5P6T2OjpPNbRRAfA07eC3B8G+1UJ3G2AfJt2W8DSZoip3L4SeP/NsBQjh6SpoRhSCwBSlybhAjYDEHDEOqw==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-QeJAmAllnjIvujXwMJ8C6Wms1c7ULCVBi5jR3JQvhRLTq87Gu6EFDALUBAv98KUfhgrdTOvOcRJhWILyetVq2Q==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Quantifiers</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Negation/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Decidable/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Quantifiers: Universals and existentials</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-99" class="Keyword">module</a> <a id="plfa_plfa-part1-Quantifiers-106" href="../Quantifiers/#" class="Module">plfa.part1.Quantifiers</a> <a id="plfa_plfa-part1-Quantifiers-129" class="Keyword">where</a>
</pre><p>This chapter introduces universal and existential quantification.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-227" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-234" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Quantifiers-272" class="Symbol">as</a> <a id="plfa_plfa-part1-Quantifiers-275" class="Module">Eq</a>
<a id="plfa_plfa-part1-Quantifiers-278" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-283" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Quantifiers-286" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-292" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-293" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Quantifiers-296" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-298" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Quantifiers-302" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-304" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-309" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-316" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Quantifiers-325" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-331" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-332" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-333" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-335" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Quantifiers-339" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-341" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Quantifiers-344" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-346" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Quantifiers-349" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-351" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Quantifiers-354" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-356" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-361" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-368" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Quantifiers-385" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-391" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-392" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Quantifiers-394" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-396" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-401" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-408" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Quantifiers-421" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-427" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-428" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Quantifiers-431" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-433" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#636" class="Field">proj₁</a><a id="plfa_plfa-part1-Quantifiers-438" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-440" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#650" class="Field">proj₂</a><a id="plfa_plfa-part1-Quantifiers-445" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-447" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Quantifiers-456" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-457" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Quantifiers-461" class="Symbol">to</a> <a id="plfa_plfa-part1-Quantifiers-464" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Quantifiers-469" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-471" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-476" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-483" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Quantifiers-492" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-498" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-499" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Quantifiers-502" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-504" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Quantifiers-508" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-510" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Quantifiers-514" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-516" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-521" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-528" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Quantifiers-551" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-557" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-558" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Quantifiers-561" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-563" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2625" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Quantifiers-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-579" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3877" class="Postulate">∀-extensionality</a><a id="plfa_plfa-part1-Quantifiers-595" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-597" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-602" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-609" href="https://agda.github.io/agda-stdlib/v2.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Quantifiers-618" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-624" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-625" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html#1115" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Quantifiers-628" class="Symbol">)</a>
</pre><h2 id="universals">Universals</h2><p>We formalise universal quantification using the dependent function type, which has appeared throughout this book. For instance, in Chapter Induction we showed addition is associative:</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>which asserts for all natural numbers <code>m</code>, <code>n</code>, and <code>p</code> that <code>(m + n) + p ≡ m + (n + p)</code> holds. It is a dependent function, which given values for <code>m</code>, <code>n</code>, and <code>p</code> returns evidence for the corresponding equation.</p><p>In general, given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the universally quantified proposition <code>∀ (x : A) → B x</code> holds if for every term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>∀ (x : A) → B x</code>.</p><p>Evidence that <code>∀ (x : A) → B x</code> holds is of the form</p><pre><code>λ (x : A) → N x</code></pre><p>where <code>N x</code> is a term of type <code>B x</code>, and <code>N x</code> and <code>B x</code> both contain a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>∀ (x : A) → B x</code> holds, and a term <code>M</code> of type <code>A</code>, the term <code>L M</code> provides evidence that <code>B M</code> holds. In other words, evidence that <code>∀ (x : A) → B x</code> holds is a function that converts a term <code>M</code> of type <code>A</code> into evidence that <code>B M</code> holds.</p>Put another way, if we know that <code>∀ (x : A) → B x</code> holds and that <code>M</code> is a term of type <code>A</code> then we may conclude that <code>B M</code> holds:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∀-elim"></a><a id="plfa_plfa-part1-Quantifiers-2110" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2110" class="Function">∀-elim</a> <a id="plfa_plfa-part1-Quantifiers-2117" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2119" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-2121" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-2122" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2122" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-2124" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2126" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-2129" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-2131" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-2132" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2132" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2134" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2136" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2122" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-2138" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2140" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-2143" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-2147" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2149" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-2152" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2153" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2153" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-2155" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2157" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2122" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-2158" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-2160" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2162" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2132" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2164" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2153" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-2165" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Quantifiers-2169" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2171" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2172" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2172" class="Bound">M</a> <a id="plfa_plfa-part1-Quantifiers-2174" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2176" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2122" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-2177" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Quantifiers-2183" class="Comment">-----------------</a>
  <a id="plfa_plfa-part1-Quantifiers-2203" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2205" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2132" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2207" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2172" class="Bound">M</a>
<a id="plfa_plfa-part1-Quantifiers-2209" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2110" class="Function">∀-elim</a> <a id="plfa_plfa-part1-Quantifiers-2216" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2216" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2218" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2218" class="Bound">M</a> <a id="plfa_plfa-part1-Quantifiers-2220" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-2222" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2216" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2224" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2218" class="Bound">M</a>
</pre><p>As with <code>→-elim</code>, the rule corresponds to function application.</p><p>Functions arise as a special case of dependent functions, where the range does not depend on a variable drawn from the domain. When a function is viewed as evidence of implication, both its argument and result are viewed as evidence, whereas when a dependent function is viewed as evidence of a universal, its argument is viewed as an element of a data type and its result is viewed as evidence of a proposition that depends on the argument. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p><p>Dependent function types are sometimes referred to as dependent products, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ , B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>∀ (x : A) → B x</code> has <code>m₁ * ⋯ * mₙ</code> members. Indeed, sometimes the notation <code>∀ (x : A) → B x</code> is replaced by a notation such as <code>Π[ x ∈ A ] (B x)</code>, where <code>Π</code> stands for product. However, we will stick with the name dependent function, because (as we will see) dependent product is ambiguous.</p><h4 id="exercise--distrib--recommended">Exercise <code>∀-distrib-×</code> (recommended)</h4>Show that universals distribute over conjunction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-3492" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∀-distrib-×"></a><a id="plfa_plfa-part1-Quantifiers-3504" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3504" class="Postulate">∀-distrib-×</a> <a id="plfa_plfa-part1-Quantifiers-3516" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3518" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3520" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3521" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3521" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3523" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3525" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3528" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3530" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3531" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3531" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3533" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3533" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3535" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3537" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3521" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3539" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3541" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3544" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3546" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-3552" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3555" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3556" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3556" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3558" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3560" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3521" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3561" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3563" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3565" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3531" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3567" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3556" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3569" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-3571" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3533" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3573" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3556" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3574" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3576" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-3578" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3581" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3582" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3582" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3584" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3586" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3521" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3587" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3589" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3591" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3531" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3593" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3582" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3594" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3596" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-3598" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3601" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3602" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3602" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3604" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3606" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3521" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3607" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3609" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3611" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3533" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3613" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3602" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3614" class="Symbol">)</a>
</pre><p>Compare this with the result (<code>→-distrib-×</code>) in Chapter <a href="../Connectives/">Connectives</a>.</p><h4 id="exercise--implies--practice">Exercise <code>⊎∀-implies-∀⊎</code> (practice)</h4>Show that a disjunction of universals implies a universal of disjunctions:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-3832" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-⊎∀-implies-∀⊎"></a><a id="plfa_plfa-part1-Quantifiers-3844" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3844" class="Postulate">⊎∀-implies-∀⊎</a> <a id="plfa_plfa-part1-Quantifiers-3858" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3860" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3862" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3863" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3865" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3867" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3870" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3872" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3873" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3873" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3875" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3875" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3877" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3879" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3863" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3881" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3883" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3886" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3888" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-3894" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3897" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3898" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3898" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3900" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3902" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3863" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3903" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3905" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3907" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3873" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3909" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3898" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3910" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3912" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-3914" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3917" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3918" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3918" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3920" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3922" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3863" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3923" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3925" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3927" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3875" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3929" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3918" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3930" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3932" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3934" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3936" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3937" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3937" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3939" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3941" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3863" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3942" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3944" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3946" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3873" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3948" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3937" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3950" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-3952" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3875" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3954" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3937" class="Bound">x</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="exercise---practice">Exercise <code>∀-×</code> (practice)</h4>Consider the following type.<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-4090" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-Tri"></a><a id="plfa_plfa-part1-Quantifiers-4095" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4095" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Quantifiers-4099" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4101" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-4105" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.aa"></a><a id="plfa_plfa-part1-Quantifiers-4113" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4113" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Quantifiers-4116" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4118" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4095" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.bb"></a><a id="plfa_plfa-part1-Quantifiers-4124" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4124" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Quantifiers-4127" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4129" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4095" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.cc"></a><a id="plfa_plfa-part1-Quantifiers-4135" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4135" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Quantifiers-4138" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4140" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4095" class="Datatype">Tri</a>
</pre><p>Let <code>B</code> be a type indexed by <code>Tri</code>, that is <code>B : Tri → Set</code>. Show that <code>∀ (x : Tri) → B x</code> is isomorphic to <code>B aa × B bb × B cc</code>.</p><p>Hint: you will need to use <a href="../Isomorphism/#extensionality"><code>∀-extensionality</code></a>.</p><h2 id="existentials">Existentials</h2><p>Given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the existentially quantified proposition <code>Σ[ x ∈ A ] B x</code> holds if for some term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>Σ[ x ∈ A ] B x</code>.</p>We formalise existential quantification by declaring a suitable record type:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-4847" class="Keyword">record</a> <a id="plfa_plfa-part1-Quantifiers-Σ"></a><a id="plfa_plfa-part1-Quantifiers-4854" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4854" class="Record">Σ</a> <a id="plfa_plfa-part1-Quantifiers-4856" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4857" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4857" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4859" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4861" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-4864" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4866" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4867" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4867" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4869" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4871" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4857" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4873" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4875" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-4878" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4880" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4882" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-4886" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-4894" class="Keyword">constructor</a> <a id="plfa_plfa-part1-Quantifiers-⟨_,_⟩"></a><a id="plfa_plfa-part1-Quantifiers-4906" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨_,_⟩</a>
  <a id="plfa_plfa-part1-Quantifiers-4914" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Quantifiers-Σ.proj₁"></a><a id="plfa_plfa-part1-Quantifiers-4924" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4924" class="Field">proj₁</a> <a id="plfa_plfa-part1-Quantifiers-4930" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4932" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4857" class="Bound">A</a>
    <a id="plfa_plfa-part1-Quantifiers-Σ.proj₂"></a><a id="plfa_plfa-part1-Quantifiers-4938" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4938" class="Field">proj₂</a> <a id="plfa_plfa-part1-Quantifiers-4944" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4946" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4867" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4948" class="Field">proj₁</a>
</pre><p>Here we have a dependent record, where the type of <code>proj₂</code> refers to the field <code>proj₁</code>. Evidence that <code>Σ A B</code> holds is of the form</p><pre><code>⟨ M , N ⟩</code></pre><p>where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B M</code>. Equivalently, the evidence may be written in the form</p><pre><code>record { proj₁ = M ; proj₂ = N }.</code></pre>We define a convenient syntax for existentials as follows:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-Σ-syntax"></a><a id="plfa_plfa-part1-Quantifiers-5331" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5331" class="Function">Σ-syntax</a> <a id="plfa_plfa-part1-Quantifiers-5340" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-5342" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4854" class="Record">Σ</a>
<a id="plfa_plfa-part1-Quantifiers-5344" class="Keyword">infix</a> <a id="plfa_plfa-part1-Quantifiers-5350" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-5352" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5331" class="Function">Σ-syntax</a>
<a id="plfa_plfa-part1-Quantifiers-5361" class="Keyword">syntax</a> <a id="plfa_plfa-part1-Quantifiers-5368" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5331" class="Function">Σ-syntax</a> <a id="plfa_plfa-part1-Quantifiers-5377" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5379" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Quantifiers-5382" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5384" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5386" class="Bound">Bx</a><a id="plfa_plfa-part1-Quantifiers-5388" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5390" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-5392" class="Function">Σ[</a> <a id="plfa_plfa-part1-Quantifiers-5395" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5397" class="Function">∈</a> <a id="plfa_plfa-part1-Quantifiers-5399" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5401" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-5403" class="Bound">Bx</a>
</pre><p>This is our first use of a syntax declaration to define binding. It specifies that the term on the left may be written with the syntax on the right. Note that the term on the left includes a lambda expression, with <code>x</code> as a bound variable. The special syntax is available only when the identifier <code>Σ-syntax</code> is imported.</p><p>The syntax declaration makes <code>Σ[ x ∈ A ] Bx</code> and <code>Σ A (λ x → Bx)</code> equivalent. In particular, instantiating <code>Bx</code> to <code>B x</code>, we have that <code>Σ[ x ∈ A ] B x</code> and <code>Σ A (λ x → B x)</code> are equivalent. By the η rule we have <code>(λ x → B x) ≡ B</code> and so they are also equivalent to <code>Σ A B</code>.</p>Equivalently, we could also declare existentials as an inductive type:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-6088" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-Σ′"></a><a id="plfa_plfa-part1-Quantifiers-6093" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6093" class="Datatype">Σ′</a> <a id="plfa_plfa-part1-Quantifiers-6096" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-6097" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6097" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6099" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6101" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-6104" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-6106" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-6107" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6107" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6109" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6111" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6097" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6113" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6115" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-6118" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-6120" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6122" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-6126" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-Σ′.⟨_,_⟩′"></a><a id="plfa_plfa-part1-Quantifiers-6134" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">⟨_,_⟩′</a> <a id="plfa_plfa-part1-Quantifiers-6141" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6143" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-6144" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6144" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-6146" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6148" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6097" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-6149" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-6151" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6153" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6107" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6155" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6144" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-6157" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6159" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6093" class="Datatype">Σ′</a> <a id="plfa_plfa-part1-Quantifiers-6162" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6097" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6164" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6107" class="Bound">B</a>

<a id="plfa_plfa-part1-Quantifiers-proj₁′"></a><a id="plfa_plfa-part1-Quantifiers-6167" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6167" class="Function">proj₁′</a> <a id="plfa_plfa-part1-Quantifiers-6174" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6176" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-6178" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-6179" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6179" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6181" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6183" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-6186" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-6188" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-6189" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6189" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6191" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6193" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6179" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6195" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6197" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-6200" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-6202" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6204" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6093" class="Datatype">Σ′</a> <a id="plfa_plfa-part1-Quantifiers-6207" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6179" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6209" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6189" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6211" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6213" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6179" class="Bound">A</a>
<a id="plfa_plfa-part1-Quantifiers-6215" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6167" class="Function">proj₁′</a> <a id="plfa_plfa-part1-Quantifiers-6222" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-6224" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6224" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-6226" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-6228" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6228" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-6230" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">⟩′</a> <a id="plfa_plfa-part1-Quantifiers-6233" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-6235" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6224" class="Bound">x</a>

<a id="plfa_plfa-part1-Quantifiers-proj₂′"></a><a id="plfa_plfa-part1-Quantifiers-6238" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6238" class="Function">proj₂′</a> <a id="plfa_plfa-part1-Quantifiers-6245" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6247" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-6249" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-6250" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6250" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6252" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6254" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-6257" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-6259" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-6260" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6260" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6262" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6264" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6250" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6266" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6268" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-6271" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-6273" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6275" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-6277" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-6278" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6278" class="Bound">w</a> <a id="plfa_plfa-part1-Quantifiers-6280" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6282" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6093" class="Datatype">Σ′</a> <a id="plfa_plfa-part1-Quantifiers-6285" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6250" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6287" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6260" class="Bound">B</a><a id="plfa_plfa-part1-Quantifiers-6288" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-6290" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6292" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6260" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6294" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-6295" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6167" class="Function">proj₁′</a> <a id="plfa_plfa-part1-Quantifiers-6302" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6278" class="Bound">w</a><a id="plfa_plfa-part1-Quantifiers-6303" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-6305" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6238" class="Function">proj₂′</a> <a id="plfa_plfa-part1-Quantifiers-6312" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-6314" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6314" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-6316" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-6318" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6318" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-6320" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6134" class="InductiveConstructor Operator">⟩′</a> <a id="plfa_plfa-part1-Quantifiers-6323" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-6325" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6318" class="Bound">y</a>
</pre><p>One consequence of the dependence is that <code>proj₁′</code> appears in the type signature for <code>proj₂′</code>.</p>Products arise as a special case of existentials, where the second component does not depend on the first component.<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-_×′_"></a><a id="plfa_plfa-part1-Quantifiers-6548" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6548" class="Function Operator">_×′_</a> <a id="plfa_plfa-part1-Quantifiers-6553" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-6555" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-6559" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6561" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-6565" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-6567" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-6571" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6571" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6573" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6548" class="Function Operator">×′</a> <a id="plfa_plfa-part1-Quantifiers-6576" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6576" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-6578" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-6580" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5331" class="Function">Σ[</a> <a id="plfa_plfa-part1-Quantifiers-6583" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6583" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-6585" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5331" class="Function">∈</a> <a id="plfa_plfa-part1-Quantifiers-6587" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6571" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-6589" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5331" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-6591" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-6576" class="Bound">B</a>
</pre><p>(Here we prime <code>×</code> to avoid collision with product from the standard library, which we imported for use in exercises in the last section.)</p><p>When a product is viewed as evidence of a conjunction, both of its components are viewed as evidence, whereas when it is viewed as evidence of an existential, the first component is viewed as an element of a datatype and the second component is viewed as evidence of a proposition that depends on the first component. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p><p>Existentials are sometimes referred to as dependent sums, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>Σ[ x ∈ A ] B x</code> has <code>m₁ + ⋯ + mₙ</code> members, which explains the choice of notation for existentials, since <code>Σ</code> stands for sum.</p><p>Existentials are also sometimes referred to as dependent products, since products arise as a special case. However, that choice of names is doubly confusing, since universals also have a claim to the name dependent product and since existentials also have a claim to the name dependent sum. We will stick with the name dependent sum.</p>A common notation for existentials is <code>∃</code> (analogous to <code>∀</code> for universals). We follow the convention of the Agda standard library, and reserve this notation for the case where the domain of the bound variable is left implicit:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃"></a><a id="plfa_plfa-part1-Quantifiers-8095" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8095" class="Function">∃</a> <a id="plfa_plfa-part1-Quantifiers-8097" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8099" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-8101" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8102" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8102" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8104" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8106" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8109" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8111" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-8112" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8112" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8114" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8116" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8102" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8118" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8120" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8123" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-8125" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8127" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-8131" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8095" class="Function">∃</a> <a id="plfa_plfa-part1-Quantifiers-8133" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8134" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8134" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-8135" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8137" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8137" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8139" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-8141" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4854" class="Record">Σ</a> <a id="plfa_plfa-part1-Quantifiers-8143" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8134" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8145" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8137" class="Bound">B</a>

<a id="plfa_plfa-part1-Quantifiers-∃-syntax"></a><a id="plfa_plfa-part1-Quantifiers-8148" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃-syntax</a> <a id="plfa_plfa-part1-Quantifiers-8157" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-8159" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8095" class="Function">∃</a>
<a id="plfa_plfa-part1-Quantifiers-8161" class="Keyword">syntax</a> <a id="plfa_plfa-part1-Quantifiers-8168" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃-syntax</a> <a id="plfa_plfa-part1-Quantifiers-8177" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Quantifiers-8180" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8182" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8184" class="Bound">B</a><a id="plfa_plfa-part1-Quantifiers-8185" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-8187" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-8189" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8192" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8194" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8196" class="Bound">B</a>
</pre><p>The special syntax is available only when the identifier <code>∃-syntax</code> is imported. We will tend to use this syntax, since it is shorter and more familiar.</p>Given evidence that <code>∀ x → B x → C</code> holds, where <code>C</code> does not contain <code>x</code> as a free variable, and given evidence that <code>∃[ x ] B x</code> holds, we may conclude that <code>C</code> holds:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃-elim"></a><a id="plfa_plfa-part1-Quantifiers-8534" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8534" class="Function">∃-elim</a> <a id="plfa_plfa-part1-Quantifiers-8541" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8543" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-8545" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8546" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8546" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8548" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8550" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8553" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8555" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8556" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8556" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8558" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8560" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8546" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8562" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8564" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8567" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8569" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8570" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8570" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-8572" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8574" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8577" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-8581" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8583" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-8586" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8586" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8588" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8590" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8556" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8592" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8586" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8594" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8596" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8570" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-8597" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Quantifiers-8601" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8603" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8606" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8606" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8608" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8610" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8556" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8612" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8606" class="Bound">x</a>
    <a id="plfa_plfa-part1-Quantifiers-8618" class="Comment">---------------</a>
  <a id="plfa_plfa-part1-Quantifiers-8636" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8638" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8570" class="Bound">C</a>
<a id="plfa_plfa-part1-Quantifiers-8640" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8534" class="Function">∃-elim</a> <a id="plfa_plfa-part1-Quantifiers-8647" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8647" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8649" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8651" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8651" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8653" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8655" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8655" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8657" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8659" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-8661" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8647" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8663" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8651" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8665" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8655" class="Bound">y</a>
</pre><p>In other words, if we know for every <code>x</code> of type <code>A</code> that <code>B x</code> implies <code>C</code>, and we know for some <code>x</code> of type <code>A</code> that <code>B x</code> holds, then we may conclude that <code>C</code> holds. This is because we may instantiate that proof that <code>∀ x → B x → C</code> to any value <code>x</code> of type <code>A</code> and any <code>y</code> of type <code>B x</code>, and exactly such values are provided by the evidence for <code>∃[ x ] B x</code>.</p>Indeed, the converse also holds, and the two together form an isomorphism:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∀∃-currying"></a><a id="plfa_plfa-part1-Quantifiers-9119" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9119" class="Function">∀∃-currying</a> <a id="plfa_plfa-part1-Quantifiers-9131" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9133" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9135" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9136" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9136" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9138" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9140" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9143" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9145" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9146" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9146" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9148" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9150" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9136" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9152" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9154" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9157" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9159" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9160" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9160" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9162" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9164" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9167" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-9171" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9173" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-9176" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9176" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9178" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9180" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9146" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9182" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9176" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9184" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9186" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9160" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-9187" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9189" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-9191" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9192" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9195" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9195" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9197" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9199" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9146" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9201" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9195" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9203" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9205" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9160" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-9206" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-9208" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9119" class="Function">∀∃-currying</a> <a id="plfa_plfa-part1-Quantifiers-9220" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Quantifiers-9224" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Quantifiers-9235" class="Symbol">{</a> <a id="plfa_plfa-part1-Quantifiers-9237" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4348" class="Field">to</a>      <a id="plfa_plfa-part1-Quantifiers-9245" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-9248" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9251" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9251" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-9253" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9255" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9258" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-9260" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9260" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9262" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-9264" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9264" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-9266" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-9268" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9270" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9251" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-9272" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9260" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9274" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9264" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-9276" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Quantifiers-9283" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-9285" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4365" class="Field">from</a>    <a id="plfa_plfa-part1-Quantifiers-9293" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-9296" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9299" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9299" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-9301" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9303" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9306" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9306" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9308" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9310" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9313" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9313" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-9315" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9317" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9299" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-9319" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-9321" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9306" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9323" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-9325" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9313" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-9327" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-9329" class="Symbol">}}}</a>
    <a id="plfa_plfa-part1-Quantifiers-9337" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-9339" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4382" class="Field">from∘to</a> <a id="plfa_plfa-part1-Quantifiers-9347" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-9350" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9353" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9353" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-9355" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9357" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-9362" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-9368" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-9370" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4424" class="Field">to∘from</a> <a id="plfa_plfa-part1-Quantifiers-9378" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-9381" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-9384" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9384" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-9386" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9388" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-9393" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-9399" class="Symbol">}</a>
</pre><p>The result can be viewed as a generalisation of currying. Indeed, the code to establish the isomorphism is identical to what we wrote when discussing <a href="../Connectives/#implication">implication</a>.</p><h4 id="exercise--distrib--recommended-1">Exercise <code>∃-distrib-⊎</code> (recommended)</h4>Show that existentials distribute over disjunction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-9702" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃-distrib-⊎"></a><a id="plfa_plfa-part1-Quantifiers-9714" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9714" class="Postulate">∃-distrib-⊎</a> <a id="plfa_plfa-part1-Quantifiers-9726" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9728" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9730" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9731" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9731" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9733" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9735" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9738" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9740" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9741" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9741" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9743" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9743" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9745" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9747" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9731" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9749" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9751" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9754" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9756" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-9762" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9765" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9765" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9767" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9769" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9770" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9741" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9772" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9765" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9774" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-9776" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9743" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9778" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9765" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9779" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9781" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-9783" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9784" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9787" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9787" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9789" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9791" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9741" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9793" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9787" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9794" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9796" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-9798" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9799" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9802" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9802" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9804" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9806" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9743" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9808" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9802" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9809" class="Symbol">)</a>
</pre><h4 id="exercise--implies--practice-1">Exercise <code>∃×-implies-×∃</code> (practice)</h4>Show that an existential of conjunctions implies a conjunction of existentials:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-9946" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃×-implies-×∃"></a><a id="plfa_plfa-part1-Quantifiers-9958" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9958" class="Postulate">∃×-implies-×∃</a> <a id="plfa_plfa-part1-Quantifiers-9972" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9974" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9976" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9977" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9977" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9979" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9981" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9984" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9986" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9987" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9987" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9989" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9989" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9991" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9993" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9977" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9995" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9997" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-10000" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-10002" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-10008" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10011" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10011" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-10013" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10015" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10016" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9987" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-10018" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10011" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-10020" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-10022" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9989" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-10024" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10011" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-10025" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-10027" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10029" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10030" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10033" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10033" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-10035" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10037" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9987" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-10039" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10033" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-10040" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-10042" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-10044" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10045" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10048" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10048" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-10050" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10052" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9989" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-10054" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10048" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-10055" class="Symbol">)</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="exercise---practice-1">Exercise <code>∃-⊎</code> (practice)</h4><p>Let <code>Tri</code> and <code>B</code> be as in Exercise <code>∀-×</code>. Show that <code>∃[ x ] B x</code> is isomorphic to <code>B aa ⊎ B bb ⊎ B cc</code>.</p><h2 id="an-existential-example">An existential example</h2>Recall the definitions of <code>even</code> and <code>odd</code> from Chapter <a href="../Relations/">Relations</a>:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-10377" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-even"></a><a id="plfa_plfa-part1-Quantifiers-10382" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10387" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10389" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Quantifiers-10391" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10393" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-10397" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-odd"></a><a id="plfa_plfa-part1-Quantifiers-10402" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10402" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Quantifiers-10407" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10409" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Quantifiers-10411" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10413" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Quantifiers-10418" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-10423" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10428" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Quantifiers-even.even-zero"></a><a id="plfa_plfa-part1-Quantifiers-10437" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10437" class="InductiveConstructor">even-zero</a> <a id="plfa_plfa-part1-Quantifiers-10447" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10449" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10454" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Quantifiers-even.even-suc"></a><a id="plfa_plfa-part1-Quantifiers-10462" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10462" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-10471" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10473" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-10475" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-10476" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10476" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10478" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10480" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-10481" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-10487" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10489" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10402" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-10493" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10476" class="Bound">n</a>
      <a id="plfa_plfa-part1-Quantifiers-10501" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Quantifiers-10518" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10520" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10525" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10526" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-10530" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10476" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-10531" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-10534" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-10539" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10402" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-10543" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-odd.odd-suc"></a><a id="plfa_plfa-part1-Quantifiers-10551" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10551" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-10559" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10561" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-10563" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-10564" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10564" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10566" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10568" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-10569" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-10575" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10577" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10582" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10564" class="Bound">n</a>
      <a id="plfa_plfa-part1-Quantifiers-10590" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Quantifiers-10606" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10608" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10402" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-10612" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10613" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-10617" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10564" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-10618" class="Symbol">)</a>
</pre><p>A number is even if it is zero or the successor of an odd number, and odd if it is the successor of an even number.</p><p>We will show that a number is even if and only if it is twice some other number, and odd if and only if it is one more than twice some other number. In other words, we will show:</p><p><code>even n</code> iff <code>∃[ m ] ( m * 2 ≡ n)</code></p><p><code>odd n</code> iff <code>∃[ m ] (1 + m * 2 ≡ n)</code></p><p>By convention, one tends to write constant factors first and to put the constant term in a sum last. Here we’ve reversed each of those conventions, because doing so eases the proof.</p>Here is the proof in the forward direction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-even-∃"></a><a id="plfa_plfa-part1-Quantifiers-11243" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11243" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-11250" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11252" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-11254" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-11255" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11255" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11257" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11259" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-11260" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-11262" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11264" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-11269" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11255" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11271" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11273" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-11276" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11276" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11278" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-11280" class="Symbol">(</a>    <a id="plfa_plfa-part1-Quantifiers-11285" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11276" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11287" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-11289" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-11291" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-11293" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11255" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-11294" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-odd-∃"></a><a id="plfa_plfa-part1-Quantifiers-11296" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11296" class="Function">odd-∃</a>  <a id="plfa_plfa-part1-Quantifiers-11303" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11305" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-11307" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-11308" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11308" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11310" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11312" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-11313" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-11315" class="Symbol">→</a>  <a id="plfa_plfa-part1-Quantifiers-11318" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10402" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-11322" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11308" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11324" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11326" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-11329" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11329" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11331" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-11333" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-11334" class="Number">1</a> <a id="plfa_plfa-part1-Quantifiers-11336" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Quantifiers-11338" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11329" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11340" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-11342" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-11344" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-11346" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11308" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-11347" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-11350" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11243" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-11357" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10437" class="InductiveConstructor">even-zero</a>                       <a id="plfa_plfa-part1-Quantifiers-11389" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-11392" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11394" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Quantifiers-11399" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11401" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11406" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Quantifiers-11408" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11243" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-11415" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-11416" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10462" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-11425" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11425" class="Bound">o</a><a id="plfa_plfa-part1-Quantifiers-11426" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-11428" class="Keyword">with</a> <a id="plfa_plfa-part1-Quantifiers-11433" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11296" class="Function">odd-∃</a> <a id="plfa_plfa-part1-Quantifiers-11439" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11425" class="Bound">o</a>
<a id="plfa_plfa-part1-Quantifiers-11441" class="Symbol">...</a>                    <a id="plfa_plfa-part1-Quantifiers-11464" class="Symbol">|</a> <a id="plfa_plfa-part1-Quantifiers-11466" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11468" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11468" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11470" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11472" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11477" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-11480" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-11483" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11485" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-11489" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11468" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11491" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11493" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11498" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>

<a id="plfa_plfa-part1-Quantifiers-11501" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11296" class="Function">odd-∃</a>  <a id="plfa_plfa-part1-Quantifiers-11508" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-11509" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10551" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-11517" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11517" class="Bound">e</a><a id="plfa_plfa-part1-Quantifiers-11518" class="Symbol">)</a>  <a id="plfa_plfa-part1-Quantifiers-11521" class="Keyword">with</a> <a id="plfa_plfa-part1-Quantifiers-11526" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11243" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-11533" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11517" class="Bound">e</a>
<a id="plfa_plfa-part1-Quantifiers-11535" class="Symbol">...</a>                    <a id="plfa_plfa-part1-Quantifiers-11558" class="Symbol">|</a> <a id="plfa_plfa-part1-Quantifiers-11560" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11562" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11562" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11564" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11566" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11571" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-11574" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-11577" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11579" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11562" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11581" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11583" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11588" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>
</pre><p>We define two mutually recursive functions. Given evidence that <code>n</code> is even or odd, we return a number <code>m</code> and evidence that <code>m * 2 ≡ n</code> or <code>1 + m * 2 ≡ n</code>. We induct over the evidence that <code>n</code> is even or odd:</p><ul><li><p>If the number is even because it is zero, then we return a pair consisting of zero and the evidence that twice zero is zero.</p></li><li><p>If the number is even because it is one more than an odd number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>1 + m * 2 ≡ n</code>. We return a pair consisting of <code>suc m</code> and evidence that <code>suc m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li><li><p>If the number is odd because it is the successor of an even number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>m * 2 ≡ n</code>. We return a pair consisting of <code>m</code> and evidence that <code>1 + m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li></ul><p>This completes the proof in the forward direction.</p>Here is the proof in the reverse direction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃-even"></a><a id="plfa_plfa-part1-Quantifiers-12608" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12608" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12615" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-12617" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-12619" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-12620" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12620" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-12622" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-12624" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-12625" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-12627" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-12629" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-12632" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12632" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12634" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-12636" class="Symbol">(</a>    <a id="plfa_plfa-part1-Quantifiers-12641" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12632" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12643" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-12645" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-12647" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-12649" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12620" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-12650" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-12652" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-12654" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10382" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-12659" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12620" class="Bound">n</a>
<a id="plfa_plfa-part1-Quantifiers-∃-odd"></a><a id="plfa_plfa-part1-Quantifiers-12661" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12661" class="Function">∃-odd</a>  <a id="plfa_plfa-part1-Quantifiers-12668" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-12670" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-12672" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-12673" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12673" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-12675" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-12677" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-12678" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-12680" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-12682" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-12685" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12685" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12687" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-12689" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-12690" class="Number">1</a> <a id="plfa_plfa-part1-Quantifiers-12692" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Quantifiers-12694" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12685" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12696" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-12698" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-12700" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-12702" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12673" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-12703" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-12705" class="Symbol">→</a>  <a id="plfa_plfa-part1-Quantifiers-12708" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10402" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-12712" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12673" class="Bound">n</a>

<a id="plfa_plfa-part1-Quantifiers-12715" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12608" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12722" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a>  <a id="plfa_plfa-part1-Quantifiers-12725" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Quantifiers-12730" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12732" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12737" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12740" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12743" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10437" class="InductiveConstructor">even-zero</a>
<a id="plfa_plfa-part1-Quantifiers-12753" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12608" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12760" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12762" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-12766" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12766" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12768" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12770" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12775" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12778" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12781" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10462" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-12790" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-12791" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12661" class="Function">∃-odd</a> <a id="plfa_plfa-part1-Quantifiers-12797" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12799" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12766" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12801" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12803" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12808" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Quantifiers-12809" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-12812" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12661" class="Function">∃-odd</a>  <a id="plfa_plfa-part1-Quantifiers-12819" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a>     <a id="plfa_plfa-part1-Quantifiers-12825" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12825" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12827" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12829" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12834" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12837" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12840" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10551" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-12848" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-12849" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12608" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12856" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12858" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12825" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12860" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12862" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12867" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Quantifiers-12868" class="Symbol">)</a>
</pre><p>Given a number that is twice some other number we must show it is even, and a number that is one more than twice some other number we must show it is odd. We induct over the evidence of the existential, and in the even case consider the two possibilities for the number that is doubled:</p><ul><li><p>In the even case for <code>zero</code>, we must show <code>zero * 2</code> is even, which follows by <code>even-zero</code>.</p></li><li><p>In the even case for <code>suc n</code>, we must show <code>suc m * 2</code> is even. The inductive hypothesis tells us that <code>1 + m * 2</code> is odd, from which the desired result follows by <code>even-suc</code>.</p></li><li><p>In the odd case, we must show <code>1 + m * 2</code> is odd. The inductive hypothesis tell us that <code>m * 2</code> is even, from which the desired result follows by <code>odd-suc</code>.</p></li></ul><p>This completes the proof in the backward direction.</p><h4 id="exercise--even-odd-practice">Exercise <code>∃-even-odd</code> (practice)</h4><p>How do the proofs become more difficult if we replace <code>m * 2</code> and <code>1 + m * 2</code> by <code>2 * m</code> and <code>2 * m + 1</code>? Rewrite the proofs of <code>∃-even</code> and <code>∃-odd</code> when restated in this way.</p><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-13877" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise----practice">Exercise <code>∃-+-≤</code> (practice)</h4><p>Show that <code>y ≤ z</code> holds if and only if there exists a <code>x</code> such that <code>x + y ≡ z</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-14029" class="Comment">-- Your code goes here</a>
</pre><h2 id="existentials-universals-and-negation">Existentials, Universals, and Negation</h2>Negation of an existential is isomorphic to the universal of a negation. Considering that existentials are generalised disjunction and universals are generalised conjunction, this result is analogous to the one which tells us that negation of a disjunction is isomorphic to a conjunction of negations:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-¬∃≃∀¬"></a><a id="plfa_plfa-part1-Quantifiers-14412" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14412" class="Function">¬∃≃∀¬</a> <a id="plfa_plfa-part1-Quantifiers-14418" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14420" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-14422" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-14423" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14423" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-14425" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14427" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-14430" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-14432" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-14433" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14433" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14435" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14437" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14423" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-14439" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14441" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-14444" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-14448" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14450" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-14451" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-14453" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-14456" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14456" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14458" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-14460" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14433" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14462" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14456" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-14463" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-14465" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-14467" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-14469" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14469" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14471" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14473" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-14475" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14433" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14477" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14469" class="Bound">x</a>
<a id="plfa_plfa-part1-Quantifiers-14479" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14412" class="Function">¬∃≃∀¬</a> <a id="plfa_plfa-part1-Quantifiers-14485" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Quantifiers-14489" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Quantifiers-14500" class="Symbol">{</a> <a id="plfa_plfa-part1-Quantifiers-14502" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4348" class="Field">to</a>      <a id="plfa_plfa-part1-Quantifiers-14510" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-14513" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-14516" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14516" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-14521" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14521" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14523" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14523" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-14525" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14527" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14516" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-14532" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-14534" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14521" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14536" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-14538" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14523" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-14540" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-14542" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-14548" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-14550" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4365" class="Field">from</a>    <a id="plfa_plfa-part1-Quantifiers-14558" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-14561" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-14564" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14564" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-14569" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-14571" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14571" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14573" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-14575" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14575" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-14577" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4906" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-14579" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14581" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14564" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-14586" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14571" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14588" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14575" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-14590" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-14596" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-14598" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4382" class="Field">from∘to</a> <a id="plfa_plfa-part1-Quantifiers-14606" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-14609" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-14612" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14612" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-14617" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14619" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-14624" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-14630" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-14632" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4424" class="Field">to∘from</a> <a id="plfa_plfa-part1-Quantifiers-14640" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-14643" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-14646" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14646" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-14651" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14653" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-14658" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-14664" class="Symbol">}</a>
</pre><p>In the <code>to</code> direction, we are given a value <code>¬∃xy</code> of type <code>¬ ∃[ x ] B x</code>, and need to show that given a value <code>x</code> that <code>¬ B x</code> follows, in other words, from a value <code>y</code> of type <code>B x</code> we can derive false. Combining <code>x</code> and <code>y</code> gives us a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code>, and applying <code>¬∃xy</code> to that yields a contradiction.</p><p>In the <code>from</code> direction, we are given a value <code>∀¬xy</code> of type <code>∀ x → ¬ B x</code>, and need to show that from a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code> we can derive false. Applying <code>∀¬xy</code> to <code>x</code> gives a value of type <code>¬ B x</code>, and applying that to <code>y</code> yields a contradiction.</p><p>The two inverse proofs are straightforward.</p><h4 id="exercise--implies--recommended">Exercise <code>∃¬-implies-¬∀</code> (recommended)</h4>Show that existential of a negation implies negation of a universal:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-15440" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃¬-implies-¬∀"></a><a id="plfa_plfa-part1-Quantifiers-15452" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15452" class="Postulate">∃¬-implies-¬∀</a> <a id="plfa_plfa-part1-Quantifiers-15466" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-15468" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-15470" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-15471" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15471" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-15473" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-15475" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-15478" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-15480" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-15481" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15481" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-15483" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-15485" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15471" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-15487" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-15489" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-15492" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-15498" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-15500" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-15503" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15503" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-15505" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8148" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-15507" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-15508" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-15510" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15481" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-15512" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15503" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-15513" class="Symbol">)</a>
      <a id="plfa_plfa-part1-Quantifiers-15521" class="Comment">--------------</a>
    <a id="plfa_plfa-part1-Quantifiers-15540" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-15542" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-15544" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-15547" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15547" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-15549" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-15551" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15481" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-15553" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-15547" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-15554" class="Symbol">)</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="Bin-isomorphism">Exercise <code>Bin-isomorphism</code> (stretch)</h4><p>Recall that Exercises <a href="../Naturals/#Bin">Bin</a>, <a href="../Induction/#Bin-laws">Bin-laws</a>, and <a href="../Relations/#Bin-predicates">Bin-predicates</a> define a datatype <code>Bin</code> of bitstrings representing natural numbers, and asks you to define the following functions and predicates:</p><pre><code>to   : ℕ → Bin
from : Bin → ℕ
Can  : Bin → Set</code></pre><p>And to establish the following properties:</p><pre><code>from (to n) ≡ n

----------
Can (to n)

Can b
---------------
to (from b) ≡ b</code></pre><p>Using the above, establish that there is an isomorphism between <code>ℕ</code> and <code>∃[ b ] Can b</code>.</p><p>We recommend proving the following lemmas which show that, for a given binary number <code>b</code>, there is only one proof of <code>One b</code> and similarly for <code>Can b</code>.</p><pre><code>≡One : ∀ {b : Bin} (o o′ : One b) → o ≡ o′

≡Can : ∀ {b : Bin} (c c′ : Can b) → c ≡ c′</code></pre><p>Many of the alternatives for proving <code>to∘from</code> turn out to be tricky. However, the proof can be straightforward if you use the following lemma, which is a corollary of <code>≡Can</code>.</p><pre><code>proj₁≡→Can≡ : {c c′ : ∃[ b ] Can b} → proj₁ c ≡ proj₁ c′ → c ≡ c′</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-16744" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-16885" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-16892" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Quantifiers-16905" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-16911" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-16912" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="plfa_plfa-part1-Quantifiers-16913" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16915" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="plfa_plfa-part1-Quantifiers-16918" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16920" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#852" class="Function">∃</a><a id="plfa_plfa-part1-Quantifiers-16921" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16923" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1244" class="Function">Σ-syntax</a><a id="plfa_plfa-part1-Quantifiers-16931" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16933" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1371" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Quantifiers-16941" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>Π  U+03A0  GREEK CAPITAL LETTER PI (\Pi)
Σ  U+03A3  GREEK CAPITAL LETTER SIGMA (\Sigma)
∃  U+2203  THERE EXISTS (\ex, \exists)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Negation/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Decidable/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>