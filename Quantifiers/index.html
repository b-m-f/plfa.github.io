<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-Iet5P6T2OjpPNbRRAfA07eC3B8G+1UJ3G2AfJt2W8DSZoip3L4SeP/NsBQjh6SpoRhSCwBSlybhAjYDEHDEOqw==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-QeJAmAllnjIvujXwMJ8C6Wms1c7ULCVBi5jR3JQvhRLTq87Gu6EFDALUBAv98KUfhgrdTOvOcRJhWILyetVq2Q==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Quantifiers</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Negation/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Decidable/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Quantifiers: Universals and existentials</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-99" class="Keyword">module</a> <a id="plfa_plfa-part1-Quantifiers-106" href="../Quantifiers/#" class="Module">plfa.part1.Quantifiers</a> <a id="plfa_plfa-part1-Quantifiers-129" class="Keyword">where</a>
</pre><p>This chapter introduces universal and existential quantification.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-227" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-234" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Quantifiers-272" class="Symbol">as</a> <a id="plfa_plfa-part1-Quantifiers-275" class="Module">Eq</a>
<a id="plfa_plfa-part1-Quantifiers-278" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-283" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Quantifiers-286" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-292" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-293" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Quantifiers-296" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-298" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Quantifiers-302" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-304" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-309" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-316" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="plfa_plfa-part1-Quantifiers-330" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-336" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-337" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-338" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-340" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Quantifiers-344" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-346" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Quantifiers-349" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-351" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Quantifiers-354" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-356" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Quantifiers-359" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-361" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-366" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-373" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="plfa_plfa-part1-Quantifiers-399" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-405" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-406" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Quantifiers-408" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-410" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-415" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-422" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="plfa_plfa-part1-Quantifiers-440" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-446" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-447" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Quantifiers-450" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-452" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#636" class="Field">proj₁</a><a id="plfa_plfa-part1-Quantifiers-457" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-459" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#650" class="Field">proj₂</a><a id="plfa_plfa-part1-Quantifiers-464" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-466" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Quantifiers-475" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-476" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Quantifiers-480" class="Symbol">to</a> <a id="plfa_plfa-part1-Quantifiers-483" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Quantifiers-488" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-490" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-495" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-502" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="plfa_plfa-part1-Quantifiers-516" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-522" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-523" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Quantifiers-526" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-528" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Quantifiers-532" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-534" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Quantifiers-538" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-540" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-545" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-552" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Quantifiers-575" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-581" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-582" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Quantifiers-585" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-587" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2625" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Quantifiers-601" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-603" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-3877" class="Postulate">∀-extensionality</a><a id="plfa_plfa-part1-Quantifiers-619" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-621" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-626" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-633" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html" class="Module">Function.Base</a> <a id="plfa_plfa-part1-Quantifiers-647" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-653" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-654" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html#1115" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Quantifiers-657" class="Symbol">)</a>
</pre><h2 id="universals">Universals</h2><p>We formalise universal quantification using the dependent function type, which has appeared throughout this book. For instance, in Chapter Induction we showed addition is associative:</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>which asserts for all natural numbers <code>m</code>, <code>n</code>, and <code>p</code> that <code>(m + n) + p ≡ m + (n + p)</code> holds. It is a dependent function, which given values for <code>m</code>, <code>n</code>, and <code>p</code> returns evidence for the corresponding equation.</p><p>In general, given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the universally quantified proposition <code>∀ (x : A) → B x</code> holds if for every term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>∀ (x : A) → B x</code>.</p><p>Evidence that <code>∀ (x : A) → B x</code> holds is of the form</p><pre><code>λ (x : A) → N x</code></pre><p>where <code>N x</code> is a term of type <code>B x</code>, and <code>N x</code> and <code>B x</code> both contain a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>∀ (x : A) → B x</code> holds, and a term <code>M</code> of type <code>A</code>, the term <code>L M</code> provides evidence that <code>B M</code> holds. In other words, evidence that <code>∀ (x : A) → B x</code> holds is a function that converts a term <code>M</code> of type <code>A</code> into evidence that <code>B M</code> holds.</p>Put another way, if we know that <code>∀ (x : A) → B x</code> holds and that <code>M</code> is a term of type <code>A</code> then we may conclude that <code>B M</code> holds:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∀-elim"></a><a id="plfa_plfa-part1-Quantifiers-2139" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2139" class="Function">∀-elim</a> <a id="plfa_plfa-part1-Quantifiers-2146" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2148" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-2150" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-2151" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2151" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-2153" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2155" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-2158" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-2160" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-2161" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2161" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2163" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2165" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2151" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-2167" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2169" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-2172" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-2176" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2178" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2179" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2179" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2181" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2183" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-2185" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2186" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2186" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-2188" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2190" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2151" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-2191" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-2193" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2195" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2161" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2197" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2186" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-2198" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Quantifiers-2202" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2204" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2205" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2205" class="Bound">M</a> <a id="plfa_plfa-part1-Quantifiers-2207" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2209" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2151" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-2210" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Quantifiers-2216" class="Comment">-----------------</a>
  <a id="plfa_plfa-part1-Quantifiers-2236" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2238" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2161" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2240" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2205" class="Bound">M</a>
<a id="plfa_plfa-part1-Quantifiers-2242" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2139" class="Function">∀-elim</a> <a id="plfa_plfa-part1-Quantifiers-2249" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2249" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2251" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2251" class="Bound">M</a> <a id="plfa_plfa-part1-Quantifiers-2253" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-2255" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2249" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2257" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2251" class="Bound">M</a>
</pre><p>As with <code>→-elim</code>, the rule corresponds to function application.</p><p>Functions arise as a special case of dependent functions, where the range does not depend on a variable drawn from the domain. When a function is viewed as evidence of implication, both its argument and result are viewed as evidence, whereas when a dependent function is viewed as evidence of a universal, its argument is viewed as an element of a data type and its result is viewed as evidence of a proposition that depends on the argument. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p><p>Dependent function types are sometimes referred to as dependent products, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ , B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>∀ (x : A) → B x</code> has <code>m₁ * ⋯ * mₙ</code> members. Indeed, sometimes the notation <code>∀ (x : A) → B x</code> is replaced by a notation such as <code>Π[ x ∈ A ] (B x)</code>, where <code>Π</code> stands for product. However, we will stick with the name dependent function, because (as we will see) dependent product is ambiguous.</p><h4 id="exercise--distrib--recommended">Exercise <code>∀-distrib-×</code> (recommended)</h4>Show that universals distribute over conjunction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-3525" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∀-distrib-×"></a><a id="plfa_plfa-part1-Quantifiers-3537" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3537" class="Postulate">∀-distrib-×</a> <a id="plfa_plfa-part1-Quantifiers-3549" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3551" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3553" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3554" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3554" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3556" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3558" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3561" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3563" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3564" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3564" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3566" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3566" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3568" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3570" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3554" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3572" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3574" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3577" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3579" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-3585" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3588" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3589" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3589" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3591" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3593" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3554" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3594" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3596" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3598" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3564" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3600" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3589" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3602" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-3604" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3566" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3606" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3589" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3607" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3609" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-3611" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3614" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3615" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3615" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3617" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3619" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3554" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3620" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3622" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3624" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3564" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3626" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3615" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3627" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3629" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-3631" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3634" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3635" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3635" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3637" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3639" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3554" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3640" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3642" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3644" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3566" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3646" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3635" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3647" class="Symbol">)</a>
</pre><p>Compare this with the result (<code>→-distrib-×</code>) in Chapter <a href="../Connectives/">Connectives</a>.</p><p>Hint: you will need to use <a href="../Isomorphism/#extensionality"><code>∀-extensionality</code></a>.</p><h4 id="exercise--implies--practice">Exercise <code>⊎∀-implies-∀⊎</code> (practice)</h4>Show that a disjunction of universals implies a universal of disjunctions:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-3945" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-⊎∀-implies-∀⊎"></a><a id="plfa_plfa-part1-Quantifiers-3957" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3957" class="Postulate">⊎∀-implies-∀⊎</a> <a id="plfa_plfa-part1-Quantifiers-3971" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3973" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3975" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3976" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3976" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3978" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3980" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3983" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3985" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3986" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3986" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3988" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3988" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3990" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3992" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3976" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3994" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3996" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3999" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-4001" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-4007" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-4010" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4011" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4011" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-4013" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4015" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3976" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-4016" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4018" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4020" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3986" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4022" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4011" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-4023" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4025" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-4027" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-4030" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4031" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4031" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-4033" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4035" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3976" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-4036" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4038" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4040" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3988" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-4042" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4031" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-4043" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4045" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4047" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-4049" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4050" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4050" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-4052" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4054" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3976" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-4055" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4057" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4059" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3986" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4061" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4050" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-4063" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-4065" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3988" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-4067" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4050" class="Bound">x</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="exercise---practice">Exercise <code>∀-×</code> (practice)</h4>Consider the following type.<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-4203" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-Tri"></a><a id="plfa_plfa-part1-Quantifiers-4208" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4208" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Quantifiers-4212" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4214" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-4218" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.aa"></a><a id="plfa_plfa-part1-Quantifiers-4226" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4226" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Quantifiers-4229" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4231" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4208" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.bb"></a><a id="plfa_plfa-part1-Quantifiers-4237" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4237" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Quantifiers-4240" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4242" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4208" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.cc"></a><a id="plfa_plfa-part1-Quantifiers-4248" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4248" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Quantifiers-4251" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4253" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4208" class="Datatype">Tri</a>
</pre><p>Let <code>B</code> be a type indexed by <code>Tri</code>, that is <code>B : Tri → Set</code>. Show that <code>∀ (x : Tri) → B x</code> is isomorphic to <code>B aa × B bb × B cc</code>.</p><p>Hint: you will need to use <a href="../Isomorphism/#extensionality"><code>∀-extensionality</code></a>.</p><h2 id="existentials">Existentials</h2><p>Given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the existentially quantified proposition <code>Σ[ x ∈ A ] B x</code> holds if for some term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>Σ[ x ∈ A ] B x</code>.</p>We formalise existential quantification by declaring a suitable inductive type:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-4963" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-Σ"></a><a id="plfa_plfa-part1-Quantifiers-4968" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4968" class="Datatype">Σ</a> <a id="plfa_plfa-part1-Quantifiers-4970" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4971" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4971" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4973" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4975" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-4978" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4980" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4981" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4981" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4983" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4985" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4971" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4987" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4989" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-4992" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4994" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4996" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-5000" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-Σ.⟨_,_⟩"></a><a id="plfa_plfa-part1-Quantifiers-5008" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="plfa_plfa-part1-Quantifiers-5014" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5016" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-5017" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5017" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5019" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5021" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4971" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-5022" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5024" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5026" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4981" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-5028" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5017" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5030" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5032" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4968" class="Datatype">Σ</a> <a id="plfa_plfa-part1-Quantifiers-5034" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4971" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5036" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4981" class="Bound">B</a>
</pre>We define a convenient syntax for existentials as follows:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-Σ-syntax"></a><a id="plfa_plfa-part1-Quantifiers-5109" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5109" class="Function">Σ-syntax</a> <a id="plfa_plfa-part1-Quantifiers-5118" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-5120" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4968" class="Datatype">Σ</a>
<a id="plfa_plfa-part1-Quantifiers-5122" class="Keyword">infix</a> <a id="plfa_plfa-part1-Quantifiers-5128" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-5130" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5109" class="Function">Σ-syntax</a>
<a id="plfa_plfa-part1-Quantifiers-5139" class="Keyword">syntax</a> <a id="plfa_plfa-part1-Quantifiers-5146" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5109" class="Function">Σ-syntax</a> <a id="plfa_plfa-part1-Quantifiers-5155" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5157" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Quantifiers-5160" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5162" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5164" class="Bound">Bx</a><a id="plfa_plfa-part1-Quantifiers-5166" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5168" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-5170" class="Function">Σ[</a> <a id="plfa_plfa-part1-Quantifiers-5173" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5175" class="Function">∈</a> <a id="plfa_plfa-part1-Quantifiers-5177" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5179" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-5181" class="Bound">Bx</a>
</pre><p>This is our first use of a syntax declaration, which specifies that the term on the left may be written with the syntax on the right. The special syntax is available only when the identifier <code>Σ-syntax</code> is imported.</p><p>Evidence that <code>Σ[ x ∈ A ] B x</code> holds is of the form <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code>, and <code>N</code> is evidence that <code>B M</code> holds.</p>Equivalently, we could also declare existentials as a record type:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-5615" class="Keyword">record</a> <a id="plfa_plfa-part1-Quantifiers-Σ′"></a><a id="plfa_plfa-part1-Quantifiers-5622" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5622" class="Record">Σ′</a> <a id="plfa_plfa-part1-Quantifiers-5625" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-5626" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5626" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5628" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5630" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-5633" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5635" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-5636" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5636" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-5638" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5640" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5626" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5642" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5644" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-5647" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5649" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5651" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-5655" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-5663" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Quantifiers-Σ′.proj₁′"></a><a id="plfa_plfa-part1-Quantifiers-5673" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5673" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Quantifiers-5680" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5682" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5626" class="Bound">A</a>
    <a id="plfa_plfa-part1-Quantifiers-Σ′.proj₂′"></a><a id="plfa_plfa-part1-Quantifiers-5688" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5688" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Quantifiers-5695" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5697" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5636" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-5699" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5673" class="Field">proj₁′</a>
</pre><p>Here record construction</p><pre><code>record
  { proj₁′ = M
  ; proj₂′ = N
  }</code></pre><p>corresponds to the term</p><pre><code>⟨ M , N ⟩</code></pre><p>where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B M</code>.</p><p>Products arise as a special case of existentials, where the second component does not depend on a variable drawn from the first component. When a product is viewed as evidence of a conjunction, both of its components are viewed as evidence, whereas when it is viewed as evidence of an existential, the first component is viewed as an element of a datatype and the second component is viewed as evidence of a proposition that depends on the first component. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p><p>Existentials are sometimes referred to as dependent sums, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>Σ[ x ∈ A ] B x</code> has <code>m₁ + ⋯ + mₙ</code> members, which explains the choice of notation for existentials, since <code>Σ</code> stands for sum.</p><p>Existentials are sometimes referred to as dependent products, since products arise as a special case. However, that choice of names is doubly confusing, since universals also have a claim to the name dependent product and since existentials also have a claim to the name dependent sum.</p>A common notation for existentials is <code>∃</code> (analogous to <code>∀</code> for universals). We follow the convention of the Agda standard library, and reserve this notation for the case where the domain of the bound variable is left implicit:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃"></a><a id="plfa_plfa-part1-Quantifiers-7350" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7350" class="Function">∃</a> <a id="plfa_plfa-part1-Quantifiers-7352" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7354" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-7356" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7357" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7357" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7359" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7361" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7364" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7366" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-7367" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7367" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7369" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7371" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7357" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7373" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7375" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7378" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-7380" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7382" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-7386" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7350" class="Function">∃</a> <a id="plfa_plfa-part1-Quantifiers-7388" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7389" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7389" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-7390" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7392" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7392" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7394" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7396" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4968" class="Datatype">Σ</a> <a id="plfa_plfa-part1-Quantifiers-7398" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7389" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7400" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7392" class="Bound">B</a>

<a id="plfa_plfa-part1-Quantifiers-∃-syntax"></a><a id="plfa_plfa-part1-Quantifiers-7403" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃-syntax</a> <a id="plfa_plfa-part1-Quantifiers-7412" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7414" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7350" class="Function">∃</a>
<a id="plfa_plfa-part1-Quantifiers-7416" class="Keyword">syntax</a> <a id="plfa_plfa-part1-Quantifiers-7423" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃-syntax</a> <a id="plfa_plfa-part1-Quantifiers-7432" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Quantifiers-7435" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7437" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7439" class="Bound">B</a><a id="plfa_plfa-part1-Quantifiers-7440" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-7442" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7444" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-7447" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7449" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-7451" class="Bound">B</a>
</pre><p>The special syntax is available only when the identifier <code>∃-syntax</code> is imported. We will tend to use this syntax, since it is shorter and more familiar.</p>Given evidence that <code>∀ x → B x → C</code> holds, where <code>C</code> does not contain <code>x</code> as a free variable, and given evidence that <code>∃[ x ] B x</code> holds, we may conclude that <code>C</code> holds:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃-elim"></a><a id="plfa_plfa-part1-Quantifiers-7789" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7789" class="Function">∃-elim</a> <a id="plfa_plfa-part1-Quantifiers-7796" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7798" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-7800" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7801" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7801" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7803" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7805" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7808" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7810" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7811" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7811" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7813" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7815" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7801" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7817" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7819" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7822" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7824" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7825" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7825" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-7827" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7829" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7832" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-7836" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7838" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-7841" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7841" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7843" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7845" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7811" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7847" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7841" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7849" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7851" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7825" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-7852" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Quantifiers-7856" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7858" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-7861" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7861" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-7865" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7811" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7867" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7861" class="Bound">x</a>
    <a id="plfa_plfa-part1-Quantifiers-7873" class="Comment">---------------</a>
  <a id="plfa_plfa-part1-Quantifiers-7891" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7893" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7825" class="Bound">C</a>
<a id="plfa_plfa-part1-Quantifiers-7895" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7789" class="Function">∃-elim</a> <a id="plfa_plfa-part1-Quantifiers-7902" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7902" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-7904" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-7906" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7906" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7908" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-7910" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7910" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-7912" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-7914" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7916" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7902" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-7918" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7906" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7920" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7910" class="Bound">y</a>
</pre><p>In other words, if we know for every <code>x</code> of type <code>A</code> that <code>B x</code> implies <code>C</code>, and we know for some <code>x</code> of type <code>A</code> that <code>B x</code> holds, then we may conclude that <code>C</code> holds. This is because we may instantiate that proof that <code>∀ x → B x → C</code> to any value <code>x</code> of type <code>A</code> and any <code>y</code> of type <code>B x</code>, and exactly such values are provided by the evidence for <code>∃[ x ] B x</code>.</p>Indeed, the converse also holds, and the two together form an isomorphism:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∀∃-currying"></a><a id="plfa_plfa-part1-Quantifiers-8374" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8374" class="Function">∀∃-currying</a> <a id="plfa_plfa-part1-Quantifiers-8386" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8388" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-8390" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8391" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8391" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8393" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8395" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8398" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8400" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8401" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8401" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8403" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8405" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8391" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8407" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8409" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8412" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8414" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8415" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8415" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-8417" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8419" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8422" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-8426" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8428" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-8431" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8431" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8433" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8435" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8401" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8437" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8431" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8439" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8441" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8415" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-8442" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-8444" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-8446" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-8447" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8450" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8450" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8452" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8454" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8401" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8456" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8450" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8458" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8460" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8415" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-8461" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-8463" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8374" class="Function">∀∃-currying</a> <a id="plfa_plfa-part1-Quantifiers-8475" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Quantifiers-8479" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Quantifiers-8490" class="Symbol">{</a> <a id="plfa_plfa-part1-Quantifiers-8492" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4348" class="Field">to</a>      <a id="plfa_plfa-part1-Quantifiers-8500" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8503" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8506" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8506" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8508" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8510" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8513" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8515" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8515" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8517" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8519" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8519" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8521" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8523" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8525" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8506" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8527" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8515" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8529" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8519" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8531" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Quantifiers-8538" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-8540" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4365" class="Field">from</a>    <a id="plfa_plfa-part1-Quantifiers-8548" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8551" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8554" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8554" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-8556" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8558" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8561" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8561" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8563" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8565" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8568" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8568" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8570" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8572" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8554" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-8574" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8576" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8561" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8578" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8580" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8568" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8582" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8584" class="Symbol">}}}</a>
    <a id="plfa_plfa-part1-Quantifiers-8592" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-8594" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4382" class="Field">from∘to</a> <a id="plfa_plfa-part1-Quantifiers-8602" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8605" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8608" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8608" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8610" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8612" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-8617" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-8623" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-8625" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4424" class="Field">to∘from</a> <a id="plfa_plfa-part1-Quantifiers-8633" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8636" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8639" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8639" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-8641" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8643" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2625" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Quantifiers-8658" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8661" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8663" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8663" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8665" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8667" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8667" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8669" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8671" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8673" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-8678" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Quantifiers-8685" class="Symbol">}</a>
</pre><p>The result can be viewed as a generalisation of currying. Indeed, the code to establish the isomorphism is identical to what we wrote when discussing <a href="../Connectives/#implication">implication</a>.</p><h4 id="exercise--distrib--recommended-1">Exercise <code>∃-distrib-⊎</code> (recommended)</h4>Show that existentials distribute over disjunction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-8988" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃-distrib-⊎"></a><a id="plfa_plfa-part1-Quantifiers-9000" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9000" class="Postulate">∃-distrib-⊎</a> <a id="plfa_plfa-part1-Quantifiers-9012" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9014" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9016" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9017" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9017" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9019" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9021" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9024" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9026" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9027" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9027" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9029" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9029" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9031" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9033" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9017" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9035" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9037" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9040" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9042" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-9048" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9051" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9051" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9053" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9055" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9056" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9027" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9058" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9051" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9060" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-9062" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9029" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9064" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9051" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9065" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9067" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-9069" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9070" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9073" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9073" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9075" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9077" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9027" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9079" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9073" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9080" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9082" href="https://agda.github.io/agda-stdlib/v2.1/Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-9084" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9085" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9088" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9088" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9090" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9092" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9029" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9094" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9088" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9095" class="Symbol">)</a>
</pre><h4 id="exercise--implies--practice-1">Exercise <code>∃×-implies-×∃</code> (practice)</h4>Show that an existential of conjunctions implies a conjunction of existentials:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-9232" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃×-implies-×∃"></a><a id="plfa_plfa-part1-Quantifiers-9244" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9244" class="Postulate">∃×-implies-×∃</a> <a id="plfa_plfa-part1-Quantifiers-9258" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9260" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9262" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9263" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9263" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9265" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9267" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9270" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9272" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9273" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9273" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9275" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9275" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9277" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9279" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9263" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9281" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9283" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9286" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9288" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-9294" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9297" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9297" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9299" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9301" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9302" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9273" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9304" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9297" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9306" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-9308" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9275" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9310" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9297" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9311" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9313" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9315" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9316" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9319" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9319" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9321" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9323" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9273" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9325" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9319" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9326" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9328" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-9330" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9331" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9334" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9334" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9336" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9338" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9275" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9340" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9334" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9341" class="Symbol">)</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="exercise---practice-1">Exercise <code>∃-⊎</code> (practice)</h4><p>Let <code>Tri</code> and <code>B</code> be as in Exercise <code>∀-×</code>. Show that <code>∃[ x ] B x</code> is isomorphic to <code>B aa ⊎ B bb ⊎ B cc</code>.</p><h2 id="an-existential-example">An existential example</h2>Recall the definitions of <code>even</code> and <code>odd</code> from Chapter <a href="../Relations/">Relations</a>:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-9663" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-even"></a><a id="plfa_plfa-part1-Quantifiers-9668" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9673" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9675" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Quantifiers-9677" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9679" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-9683" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-odd"></a><a id="plfa_plfa-part1-Quantifiers-9688" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9688" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Quantifiers-9693" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9695" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Quantifiers-9697" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9699" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Quantifiers-9704" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-9709" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9714" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Quantifiers-even.even-zero"></a><a id="plfa_plfa-part1-Quantifiers-9723" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9723" class="InductiveConstructor">even-zero</a> <a id="plfa_plfa-part1-Quantifiers-9733" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9735" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9740" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Quantifiers-even.even-suc"></a><a id="plfa_plfa-part1-Quantifiers-9748" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9748" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-9757" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9759" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9761" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9762" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9762" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-9764" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9766" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-9767" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-9773" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9775" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9688" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-9779" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9762" class="Bound">n</a>
      <a id="plfa_plfa-part1-Quantifiers-9787" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Quantifiers-9804" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9806" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9811" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9812" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-9816" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9762" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-9817" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-9820" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-9825" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9688" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-9829" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-odd.odd-suc"></a><a id="plfa_plfa-part1-Quantifiers-9837" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9837" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-9845" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9847" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9849" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9850" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9850" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-9852" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9854" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-9855" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-9861" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9868" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9850" class="Bound">n</a>
      <a id="plfa_plfa-part1-Quantifiers-9876" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Quantifiers-9892" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9894" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9688" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-9898" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9899" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-9903" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9850" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-9904" class="Symbol">)</a>
</pre><p>A number is even if it is zero or the successor of an odd number, and odd if it is the successor of an even number.</p><p>We will show that a number is even if and only if it is twice some other number, and odd if and only if it is one more than twice some other number. In other words, we will show:</p><p><code>even n</code> iff <code>∃[ m ] ( m * 2 ≡ n)</code></p><p><code>odd n</code> iff <code>∃[ m ] (1 + m * 2 ≡ n)</code></p><p>By convention, one tends to write constant factors first and to put the constant term in a sum last. Here we’ve reversed each of those conventions, because doing so eases the proof.</p>Here is the proof in the forward direction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-even-∃"></a><a id="plfa_plfa-part1-Quantifiers-10529" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10529" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10536" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10538" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-10540" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-10541" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10541" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10543" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10545" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-10546" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-10548" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10550" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10555" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10541" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10557" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10559" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10562" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10562" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10564" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10566" class="Symbol">(</a>    <a id="plfa_plfa-part1-Quantifiers-10571" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10562" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10573" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-10575" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-10577" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-10579" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10541" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-10580" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-odd-∃"></a><a id="plfa_plfa-part1-Quantifiers-10582" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10582" class="Function">odd-∃</a>  <a id="plfa_plfa-part1-Quantifiers-10589" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10591" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-10593" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-10594" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10594" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10596" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10598" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-10599" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-10601" class="Symbol">→</a>  <a id="plfa_plfa-part1-Quantifiers-10604" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9688" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-10608" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10594" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10610" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10612" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10615" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10615" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10617" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10619" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10620" class="Number">1</a> <a id="plfa_plfa-part1-Quantifiers-10622" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Quantifiers-10624" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10615" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10626" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-10628" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-10630" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-10632" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10594" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-10633" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-10636" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10529" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10643" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9723" class="InductiveConstructor">even-zero</a>                       <a id="plfa_plfa-part1-Quantifiers-10675" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-10678" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10680" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Quantifiers-10685" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10687" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10692" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Quantifiers-10694" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10529" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10701" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10702" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9748" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-10711" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10711" class="Bound">o</a><a id="plfa_plfa-part1-Quantifiers-10712" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-10714" class="Keyword">with</a> <a id="plfa_plfa-part1-Quantifiers-10719" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10582" class="Function">odd-∃</a> <a id="plfa_plfa-part1-Quantifiers-10725" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10711" class="Bound">o</a>
<a id="plfa_plfa-part1-Quantifiers-10727" class="Symbol">...</a>                    <a id="plfa_plfa-part1-Quantifiers-10750" class="Symbol">|</a> <a id="plfa_plfa-part1-Quantifiers-10752" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10754" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10754" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10756" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10758" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10763" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-10766" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-10769" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10771" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-10775" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10754" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10777" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10779" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10784" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>

<a id="plfa_plfa-part1-Quantifiers-10787" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10582" class="Function">odd-∃</a>  <a id="plfa_plfa-part1-Quantifiers-10794" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10795" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9837" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-10803" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10803" class="Bound">e</a><a id="plfa_plfa-part1-Quantifiers-10804" class="Symbol">)</a>  <a id="plfa_plfa-part1-Quantifiers-10807" class="Keyword">with</a> <a id="plfa_plfa-part1-Quantifiers-10812" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10529" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10819" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10803" class="Bound">e</a>
<a id="plfa_plfa-part1-Quantifiers-10821" class="Symbol">...</a>                    <a id="plfa_plfa-part1-Quantifiers-10844" class="Symbol">|</a> <a id="plfa_plfa-part1-Quantifiers-10846" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10848" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10848" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10850" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10852" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10857" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-10860" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-10863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10865" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10848" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10867" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10869" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10874" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>
</pre><p>We define two mutually recursive functions. Given evidence that <code>n</code> is even or odd, we return a number <code>m</code> and evidence that <code>m * 2 ≡ n</code> or <code>1 + m * 2 ≡ n</code>. We induct over the evidence that <code>n</code> is even or odd:</p><ul><li><p>If the number is even because it is zero, then we return a pair consisting of zero and the evidence that twice zero is zero.</p></li><li><p>If the number is even because it is one more than an odd number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>1 + m * 2 ≡ n</code>. We return a pair consisting of <code>suc m</code> and evidence that <code>suc m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li><li><p>If the number is odd because it is the successor of an even number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>m * 2 ≡ n</code>. We return a pair consisting of <code>m</code> and evidence that <code>1 + m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li></ul><p>This completes the proof in the forward direction.</p>Here is the proof in the reverse direction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃-even"></a><a id="plfa_plfa-part1-Quantifiers-11894" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11894" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-11901" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11903" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-11905" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-11906" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11906" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11908" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11910" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-11911" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-11913" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11915" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-11918" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11918" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11920" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-11922" class="Symbol">(</a>    <a id="plfa_plfa-part1-Quantifiers-11927" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11918" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11929" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-11931" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-11933" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-11935" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11906" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-11936" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-11938" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11940" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9668" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-11945" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11906" class="Bound">n</a>
<a id="plfa_plfa-part1-Quantifiers-∃-odd"></a><a id="plfa_plfa-part1-Quantifiers-11947" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11947" class="Function">∃-odd</a>  <a id="plfa_plfa-part1-Quantifiers-11954" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11956" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-11958" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-11959" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11959" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11961" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11963" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-11964" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-11966" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11968" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-11971" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11971" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11973" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-11975" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-11976" class="Number">1</a> <a id="plfa_plfa-part1-Quantifiers-11978" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Quantifiers-11980" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11971" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11982" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-11984" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-11986" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-11988" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11959" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-11989" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-11991" class="Symbol">→</a>  <a id="plfa_plfa-part1-Quantifiers-11994" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9688" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-11998" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11959" class="Bound">n</a>

<a id="plfa_plfa-part1-Quantifiers-12001" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11894" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12008" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a>  <a id="plfa_plfa-part1-Quantifiers-12011" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Quantifiers-12016" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12018" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12023" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12026" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12029" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9723" class="InductiveConstructor">even-zero</a>
<a id="plfa_plfa-part1-Quantifiers-12039" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11894" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12046" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12048" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-12052" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12052" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12054" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12056" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12061" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12064" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12067" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9748" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-12076" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-12077" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11947" class="Function">∃-odd</a> <a id="plfa_plfa-part1-Quantifiers-12083" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12085" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12052" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12087" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12089" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12094" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Quantifiers-12095" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-12098" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11947" class="Function">∃-odd</a>  <a id="plfa_plfa-part1-Quantifiers-12105" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a>     <a id="plfa_plfa-part1-Quantifiers-12111" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12111" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12113" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12115" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12120" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12123" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12126" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9837" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-12134" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-12135" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11894" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12142" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12144" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12111" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12146" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12148" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12153" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Quantifiers-12154" class="Symbol">)</a>
</pre><p>Given a number that is twice some other number we must show it is even, and a number that is one more than twice some other number we must show it is odd. We induct over the evidence of the existential, and in the even case consider the two possibilities for the number that is doubled:</p><ul><li><p>In the even case for <code>zero</code>, we must show <code>zero * 2</code> is even, which follows by <code>even-zero</code>.</p></li><li><p>In the even case for <code>suc n</code>, we must show <code>suc m * 2</code> is even. The inductive hypothesis tells us that <code>1 + m * 2</code> is odd, from which the desired result follows by <code>even-suc</code>.</p></li><li><p>In the odd case, we must show <code>1 + m * 2</code> is odd. The inductive hypothesis tell us that <code>m * 2</code> is even, from which the desired result follows by <code>odd-suc</code>.</p></li></ul><p>This completes the proof in the backward direction.</p><h4 id="exercise--even-odd-practice">Exercise <code>∃-even-odd</code> (practice)</h4><p>How do the proofs become more difficult if we replace <code>m * 2</code> and <code>1 + m * 2</code> by <code>2 * m</code> and <code>2 * m + 1</code>? Rewrite the proofs of <code>∃-even</code> and <code>∃-odd</code> when restated in this way.</p><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-13163" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise----practice">Exercise <code>∃-+-≤</code> (practice)</h4><p>Show that <code>y ≤ z</code> holds if and only if there exists a <code>x</code> such that <code>x + y ≡ z</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-13315" class="Comment">-- Your code goes here</a>
</pre><h2 id="existentials-universals-and-negation">Existentials, Universals, and Negation</h2>Negation of an existential is isomorphic to the universal of a negation. Considering that existentials are generalised disjunction and universals are generalised conjunction, this result is analogous to the one which tells us that negation of a disjunction is isomorphic to a conjunction of negations:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-¬∃≃∀¬"></a><a id="plfa_plfa-part1-Quantifiers-13698" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13698" class="Function">¬∃≃∀¬</a> <a id="plfa_plfa-part1-Quantifiers-13704" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-13706" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-13708" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-13709" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13709" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-13711" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-13713" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-13716" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-13718" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-13719" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13719" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-13721" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-13723" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13709" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-13725" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13727" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-13730" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-13734" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13736" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-13737" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-13739" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-13742" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13742" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13744" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-13746" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13719" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-13748" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13742" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-13749" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-13751" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-13753" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-13755" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13755" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13757" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13759" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-13761" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13719" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-13763" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13755" class="Bound">x</a>
<a id="plfa_plfa-part1-Quantifiers-13765" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13698" class="Function">¬∃≃∀¬</a> <a id="plfa_plfa-part1-Quantifiers-13771" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Quantifiers-13775" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Quantifiers-13786" class="Symbol">{</a> <a id="plfa_plfa-part1-Quantifiers-13788" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4348" class="Field">to</a>      <a id="plfa_plfa-part1-Quantifiers-13796" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13799" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13802" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13802" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-13807" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13807" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13809" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13809" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13811" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13813" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13802" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-13818" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-13820" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13807" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13822" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-13824" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13809" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13826" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-13828" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13834" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-13836" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4365" class="Field">from</a>    <a id="plfa_plfa-part1-Quantifiers-13844" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13847" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13850" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13850" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-13855" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-13857" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13857" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13859" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-13861" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13861" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-13865" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13867" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13850" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-13872" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13857" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13874" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13861" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13876" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13882" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-13884" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4382" class="Field">from∘to</a> <a id="plfa_plfa-part1-Quantifiers-13892" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13895" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13898" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13898" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-13903" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13905" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2625" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Quantifiers-13920" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13923" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-13925" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13925" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13927" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-13929" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13929" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13931" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5008" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-13933" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13935" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-13940" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-13942" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13948" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-13950" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4424" class="Field">to∘from</a> <a id="plfa_plfa-part1-Quantifiers-13958" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13961" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13964" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13964" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-13969" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13971" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-13976" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13982" class="Symbol">}</a>
</pre><p>In the <code>to</code> direction, we are given a value <code>¬∃xy</code> of type <code>¬ ∃[ x ] B x</code>, and need to show that given a value <code>x</code> that <code>¬ B x</code> follows, in other words, from a value <code>y</code> of type <code>B x</code> we can derive false. Combining <code>x</code> and <code>y</code> gives us a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code>, and applying <code>¬∃xy</code> to that yields a contradiction.</p><p>In the <code>from</code> direction, we are given a value <code>∀¬xy</code> of type <code>∀ x → ¬ B x</code>, and need to show that from a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code> we can derive false. Applying <code>∀¬xy</code> to <code>x</code> gives a value of type <code>¬ B x</code>, and applying that to <code>y</code> yields a contradiction.</p><p>The two inverse proofs are straightforward, where one direction requires extensionality.</p><h4 id="exercise--implies--recommended">Exercise <code>∃¬-implies-¬∀</code> (recommended)</h4>Show that existential of a negation implies negation of a universal:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-14803" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃¬-implies-¬∀"></a><a id="plfa_plfa-part1-Quantifiers-14815" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14815" class="Postulate">∃¬-implies-¬∀</a> <a id="plfa_plfa-part1-Quantifiers-14829" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14831" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-14833" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-14834" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14834" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-14836" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14838" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-14841" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-14843" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-14844" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14844" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14846" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14848" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14834" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-14850" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14852" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-14855" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-14861" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-14866" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14866" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14868" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7403" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-14870" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-14871" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-14873" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14844" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14875" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14866" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-14876" class="Symbol">)</a>
      <a id="plfa_plfa-part1-Quantifiers-14884" class="Comment">--------------</a>
    <a id="plfa_plfa-part1-Quantifiers-14903" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14905" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-14907" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-14910" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14910" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14912" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14914" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14844" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14916" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14910" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-14917" class="Symbol">)</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="Bin-isomorphism">Exercise <code>Bin-isomorphism</code> (stretch)</h4><p>Recall that Exercises <a href="../Naturals/#Bin">Bin</a>, <a href="../Induction/#Bin-laws">Bin-laws</a>, and <a href="../Relations/#Bin-predicates">Bin-predicates</a> define a datatype <code>Bin</code> of bitstrings representing natural numbers, and asks you to define the following functions and predicates:</p><pre><code>to   : ℕ → Bin
from : Bin → ℕ
Can  : Bin → Set</code></pre><p>And to establish the following properties:</p><pre><code>from (to n) ≡ n

----------
Can (to n)

Can b
---------------
to (from b) ≡ b</code></pre><p>Using the above, establish that there is an isomorphism between <code>ℕ</code> and <code>∃[ b ] Can b</code>.</p><p>We recommend proving the following lemmas which show that, for a given binary number <code>b</code>, there is only one proof of <code>One b</code> and similarly for <code>Can b</code>.</p><pre><code>≡One : ∀ {b : Bin} (o o′ : One b) → o ≡ o′

≡Can : ∀ {b : Bin} (c c′ : Can b) → c ≡ c′</code></pre><p>Many of the alternatives for proving <code>to∘from</code> turn out to be tricky. However, the proof can be straightforward if you use the following lemma, which is a corollary of <code>≡Can</code>.</p><pre><code>proj₁≡→Can≡ : {c c′ : ∃[ b ] Can b} → proj₁ c ≡ proj₁ c′ → c ≡ c′</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-16107" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-16248" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-16255" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Quantifiers-16268" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-16274" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-16275" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#165" class="Record">Σ</a><a id="plfa_plfa-part1-Quantifiers-16276" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16278" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="plfa_plfa-part1-Quantifiers-16281" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16283" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#852" class="Function">∃</a><a id="plfa_plfa-part1-Quantifiers-16284" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16286" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1244" class="Function">Σ-syntax</a><a id="plfa_plfa-part1-Quantifiers-16294" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16296" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1371" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Quantifiers-16304" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>Π  U+03A0  GREEK CAPITAL LETTER PI (\Pi)
Σ  U+03A3  GREEK CAPITAL LETTER SIGMA (\Sigma)
∃  U+2203  THERE EXISTS (\ex, \exists)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Negation/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Decidable/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>