<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-Iet5P6T2OjpPNbRRAfA07eC3B8G+1UJ3G2AfJt2W8DSZoip3L4SeP/NsBQjh6SpoRhSCwBSlybhAjYDEHDEOqw==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-QeJAmAllnjIvujXwMJ8C6Wms1c7ULCVBi5jR3JQvhRLTq87Gu6EFDALUBAv98KUfhgrdTOvOcRJhWILyetVq2Q==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Lists: Lists and higher-order functions</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-92" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-99" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-116" class="Keyword">where</a>
</pre><p>This chapter discusses the list data type. It gives further examples of many of the techniques we have developed so far, and provides examples of polymorphic types and higher-order functions.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-341" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-348" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-386" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-389" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-392" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-397" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-400" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-406" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-407" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-410" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-412" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-416" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-418" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="plfa_plfa-part1-Lists-421" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-423" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1938" class="Function">trans</a><a id="plfa_plfa-part1-Lists-428" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-430" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="plfa_plfa-part1-Lists-434" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-436" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-441" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-456" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-461" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-468" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-478" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-484" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-485" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-489" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-491" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-495" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-497" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-502" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-504" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#1348" class="Function">T</a><a id="plfa_plfa-part1-Lists-505" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-507" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#995" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-512" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-515" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-517" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#941" class="Function">not</a><a id="plfa_plfa-part1-Lists-520" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-522" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-527" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-534" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-543" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-549" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-550" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-551" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-553" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-557" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-559" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-562" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-564" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-567" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-569" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#4456" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1691" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-582" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-584" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-587" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-589" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-592" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-594" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-599" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-606" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-626" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-634" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-635" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15113" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-642" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-644" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15214" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-655" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-657" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15269" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-668" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-670" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#22674" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-677" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-679" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21574" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-690" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-692" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21638" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-703" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-705" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#22188" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-717" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-719" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-724" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-731" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-748" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-754" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-755" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-757" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-759" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-762" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-764" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-767" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-769" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-771" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-773" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-778" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-785" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-798" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-804" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-805" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-808" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-810" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#852" class="Function">∃</a><a id="plfa_plfa-part1-Lists-811" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-813" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1371" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-821" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-823" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-832" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-833" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-837" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-845" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-847" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-852" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-859" href="https://agda.github.io/agda-stdlib/v2.1/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-868" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-874" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-875" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html#1115" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-878" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-880" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-885" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-892" href="https://agda.github.io/agda-stdlib/v2.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-898" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-904" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-905" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#742" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-910" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-912" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-917" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-924" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-947" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-953" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-954" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-957" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-959" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12028" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-962" class="Symbol">)</a>
</pre><h2 id="lists">Lists</h2>Lists are defined in Agda as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-1026" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1031" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1036" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1037" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1039" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1041" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1044" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1046" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1048" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1052" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1060" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1064" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1066" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1071" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1075" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1079" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1081" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1083" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1085" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1090" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1092" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1094" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1099" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1102" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1109" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1111" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a>
</pre><p>Let’s unpack this definition. If <code>A</code> is a set, then <code>List A</code> is a set. The next two lines tell us that <code>[]</code> (pronounced <em>nil</em>) is a list of type <code>A</code> (often called the <em>empty</em> list), and that <code>_∷_</code> (pronounced <em>cons</em>, short for <em>constructor</em>) takes a value of type <code>A</code> and a value of type <code>List A</code> and returns a value of type <code>List A</code>. Operator <code>_∷_</code> has precedence level 5 and associates to the right.</p>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-1544" href="../Lists/#plfa_plfa-part1-Lists-1544" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1546" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1548" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1553" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1555" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1557" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1559" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1561" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1563" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1565" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1567" class="Number">2</a> <a id="plfa_plfa-part1-Lists-1569" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1571" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
</pre><p>denotes the list of the first three natural numbers. Since <code>_∷_</code> associates to the right, the term parses as <code>0 ∷ (1 ∷ (2 ∷ []))</code>. Here <code>0</code> is the first element of the list, called the <em>head</em>, and <code>1 ∷ (2 ∷ [])</code> is a list of the remaining elements, called the <em>tail</em>. A list is a strange beast: it has a head and a tail, nothing in between, and the tail is itself another list!</p>As we’ve seen, some parameterised types can be translated to indexed types. The definition above translates to the following:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2092" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2097" href="../Lists/#plfa_plfa-part1-Lists-2097" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2103" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2105" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2109" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2111" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="plfa_plfa-part1-Lists-2116" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2124" href="../Lists/#plfa_plfa-part1-Lists-2124" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2129" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2131" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2133" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2134" href="../Lists/#plfa_plfa-part1-Lists-2134" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2136" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2138" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2141" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2143" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2145" href="../Lists/#plfa_plfa-part1-Lists-2097" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2151" href="../Lists/#plfa_plfa-part1-Lists-2134" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2155" href="../Lists/#plfa_plfa-part1-Lists-2155" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2160" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2162" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2164" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2165" href="../Lists/#plfa_plfa-part1-Lists-2165" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2167" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2169" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2172" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2174" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2176" href="../Lists/#plfa_plfa-part1-Lists-2165" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2178" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2180" href="../Lists/#plfa_plfa-part1-Lists-2097" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2186" href="../Lists/#plfa_plfa-part1-Lists-2165" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2188" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2190" href="../Lists/#plfa_plfa-part1-Lists-2097" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2196" href="../Lists/#plfa_plfa-part1-Lists-2165" class="Bound">A</a>
</pre><p>This is almost equivalent, save that with parametrised types the result can be in <code>Set</code>, whereas for technical reasons indexed types require the result to be <code>Set₁</code>.</p>Each constructor of <code>List</code> takes the parameter as an implicit argument. Thus, our example list could also be written:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2495" href="../Lists/#plfa_plfa-part1-Lists-2495" class="Function">_</a> <a id="plfa_plfa-part1-Lists-2497" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2499" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-2504" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-2506" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-2508" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2510" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2514" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2515" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2516" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2518" class="Number">0</a> <a id="plfa_plfa-part1-Lists-2520" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2521" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2525" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2526" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2527" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2529" class="Number">1</a> <a id="plfa_plfa-part1-Lists-2531" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2532" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2536" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2537" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2538" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2540" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2542" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2543" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-2546" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2547" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2548" class="Symbol">})))</a>
</pre><p>where here we have provided the implicit parameters explicitly.</p><p>Including the pragma:</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>tells Agda that the type <code>List</code> corresponds to the Haskell type list, and the constructors <code>[]</code> and <code>_∷_</code> correspond to nil and cons respectively, allowing a more efficient representation of lists.</p><h2 id="list-syntax">List syntax</h2>We can write lists more conveniently by introducing the following definitions:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2979" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-2987" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-2991" href="../Lists/#plfa_plfa-part1-Lists-2995" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2993" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2995" href="../Lists/#plfa_plfa-part1-Lists-2995" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2997" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2999" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3002" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3010" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3016" href="../Lists/#plfa_plfa-part1-Lists-3022" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3018" href="../Lists/#plfa_plfa-part1-Lists-3026" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3020" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3022" href="../Lists/#plfa_plfa-part1-Lists-3022" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3024" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3026" href="../Lists/#plfa_plfa-part1-Lists-3026" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3028" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3030" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3033" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-3041" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-3049" href="../Lists/#plfa_plfa-part1-Lists-3057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3051" href="../Lists/#plfa_plfa-part1-Lists-3061" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3053" href="../Lists/#plfa_plfa-part1-Lists-3065" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3055" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3057" href="../Lists/#plfa_plfa-part1-Lists-3057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3059" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3061" href="../Lists/#plfa_plfa-part1-Lists-3061" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3063" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3065" href="../Lists/#plfa_plfa-part1-Lists-3065" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3067" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3069" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3072" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3080" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3090" href="../Lists/#plfa_plfa-part1-Lists-3100" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3092" href="../Lists/#plfa_plfa-part1-Lists-3104" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3094" href="../Lists/#plfa_plfa-part1-Lists-3108" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3096" href="../Lists/#plfa_plfa-part1-Lists-3112" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3098" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3100" href="../Lists/#plfa_plfa-part1-Lists-3100" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3102" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3104" href="../Lists/#plfa_plfa-part1-Lists-3104" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3106" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3108" href="../Lists/#plfa_plfa-part1-Lists-3108" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3110" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3112" href="../Lists/#plfa_plfa-part1-Lists-3112" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3114" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3116" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3119" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3127" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3139" href="../Lists/#plfa_plfa-part1-Lists-3151" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3141" href="../Lists/#plfa_plfa-part1-Lists-3155" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3143" href="../Lists/#plfa_plfa-part1-Lists-3159" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3145" href="../Lists/#plfa_plfa-part1-Lists-3163" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3147" href="../Lists/#plfa_plfa-part1-Lists-3167" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3149" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3151" href="../Lists/#plfa_plfa-part1-Lists-3151" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3153" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3155" href="../Lists/#plfa_plfa-part1-Lists-3155" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3157" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3159" href="../Lists/#plfa_plfa-part1-Lists-3159" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3161" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3163" href="../Lists/#plfa_plfa-part1-Lists-3163" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3165" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3167" href="../Lists/#plfa_plfa-part1-Lists-3167" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3169" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3171" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3174" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3182" href="../Lists/#plfa_plfa-part1-Lists-3182" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3196" href="../Lists/#plfa_plfa-part1-Lists-3210" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3198" href="../Lists/#plfa_plfa-part1-Lists-3214" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3200" href="../Lists/#plfa_plfa-part1-Lists-3218" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3202" href="../Lists/#plfa_plfa-part1-Lists-3222" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3204" href="../Lists/#plfa_plfa-part1-Lists-3226" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3206" href="../Lists/#plfa_plfa-part1-Lists-3230" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3208" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3210" href="../Lists/#plfa_plfa-part1-Lists-3210" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3212" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3214" href="../Lists/#plfa_plfa-part1-Lists-3214" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3216" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3218" href="../Lists/#plfa_plfa-part1-Lists-3218" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3220" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3222" href="../Lists/#plfa_plfa-part1-Lists-3222" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3224" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3226" href="../Lists/#plfa_plfa-part1-Lists-3226" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3228" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3230" href="../Lists/#plfa_plfa-part1-Lists-3230" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3232" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3234" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
</pre><p>This is our first use of pattern declarations. For instance, the third line tells us that <code>[ x , y , z ]</code> is equivalent to <code>x ∷ y ∷ z ∷ []</code>, and permits the former to appear either in a pattern on the left-hand side of an equation, or a term on the right-hand side of an equation.</p><h2 id="append">Append</h2><p>Our first function on lists is written <code>_++_</code> and pronounced <em>append</em>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3616" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-3623" class="Number">5</a> <a id="plfa_plfa-part1-Lists-3625" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-3631" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-3636" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3638" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-3640" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3641" href="../Lists/#plfa_plfa-part1-Lists-3641" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3643" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3645" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-3648" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3650" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3652" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3657" href="../Lists/#plfa_plfa-part1-Lists-3641" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3659" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3661" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3666" href="../Lists/#plfa_plfa-part1-Lists-3641" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3668" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3670" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3675" href="../Lists/#plfa_plfa-part1-Lists-3641" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-3677" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-3686" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3689" href="../Lists/#plfa_plfa-part1-Lists-3689" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3693" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3696" href="../Lists/#plfa_plfa-part1-Lists-3689" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-3699" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3700" href="../Lists/#plfa_plfa-part1-Lists-3700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3702" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3704" href="../Lists/#plfa_plfa-part1-Lists-3704" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-3706" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-3708" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3711" href="../Lists/#plfa_plfa-part1-Lists-3711" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3715" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3718" href="../Lists/#plfa_plfa-part1-Lists-3700" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3720" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3722" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3723" href="../Lists/#plfa_plfa-part1-Lists-3704" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-3726" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3729" href="../Lists/#plfa_plfa-part1-Lists-3711" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-3731" class="Symbol">)</a>
</pre><p>The type <code>A</code> is an implicit argument to append, making it a <em>polymorphic</em> function (one that can be used at many types). A list appended to the empty list yields the list itself. A list appended to a non-empty list yields a list with the head the same as the head of the non-empty list, and a tail the same as the other list appended to tail of the non-empty list.</p>Here is an example, showing how to compute the result of appending two lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-4189" href="../Lists/#plfa_plfa-part1-Lists-4189" class="Function">_</a> <a id="plfa_plfa-part1-Lists-4191" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4193" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4195" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4197" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4199" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4201" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4203" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4205" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4207" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4210" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4212" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4214" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4216" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4218" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4220" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4222" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4224" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4226" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4228" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4230" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4232" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4234" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4236" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4238" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4240" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4242" href="../Lists/#plfa_plfa-part1-Lists-3127" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-4244" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-4246" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4250" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4260" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4262" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4264" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4266" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4268" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4270" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4272" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4275" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4278" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4280" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4282" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4284" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4286" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4291" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4299" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4301" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4303" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4304" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4306" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4308" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4310" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4312" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4315" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4318" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4320" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4322" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4324" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4326" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4328" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4332" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4340" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4342" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4344" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4346" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4348" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4349" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4351" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4353" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4356" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4359" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4361" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4363" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4365" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4367" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4369" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4373" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4381" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4383" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4385" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4387" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4389" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4391" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4393" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4394" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4397" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4400" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4402" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4404" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4406" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4408" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4410" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4414" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4422" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4424" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4426" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4428" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4430" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4432" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4434" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4436" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4438" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4440" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4442" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4447" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Appending two lists requires time linear in the number of elements in the first list.</p><h2 id="reasoning-about-append">Reasoning about append</h2>We can reason about lists in much the same way that we reason about numbers. Here is the proof that append is associative:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-4700" href="../Lists/#plfa_plfa-part1-Lists-4700" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4709" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4711" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4713" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4714" href="../Lists/#plfa_plfa-part1-Lists-4714" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4716" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4718" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4721" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4723" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4724" href="../Lists/#plfa_plfa-part1-Lists-4724" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4727" href="../Lists/#plfa_plfa-part1-Lists-4727" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4730" href="../Lists/#plfa_plfa-part1-Lists-4730" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4733" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4735" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4740" href="../Lists/#plfa_plfa-part1-Lists-4714" class="Bound">A</a><a id="plfa_plfa-part1-Lists-4741" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4745" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4747" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4748" href="../Lists/#plfa_plfa-part1-Lists-4724" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4751" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4754" href="../Lists/#plfa_plfa-part1-Lists-4727" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4756" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4758" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4761" href="../Lists/#plfa_plfa-part1-Lists-4730" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4764" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4766" href="../Lists/#plfa_plfa-part1-Lists-4724" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4769" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4772" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4773" href="../Lists/#plfa_plfa-part1-Lists-4727" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4776" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4779" href="../Lists/#plfa_plfa-part1-Lists-4730" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4781" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-4783" href="../Lists/#plfa_plfa-part1-Lists-4700" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4792" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4795" href="../Lists/#plfa_plfa-part1-Lists-4795" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4798" href="../Lists/#plfa_plfa-part1-Lists-4798" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4801" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4805" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4815" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4816" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4819" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4822" href="../Lists/#plfa_plfa-part1-Lists-4795" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4824" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4826" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4829" href="../Lists/#plfa_plfa-part1-Lists-4798" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4834" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4842" href="../Lists/#plfa_plfa-part1-Lists-4795" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4845" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4848" href="../Lists/#plfa_plfa-part1-Lists-4798" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4853" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4861" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4864" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4867" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4868" href="../Lists/#plfa_plfa-part1-Lists-4795" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4871" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4874" href="../Lists/#plfa_plfa-part1-Lists-4798" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4876" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4880" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-4882" href="../Lists/#plfa_plfa-part1-Lists-4700" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4891" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4892" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4894" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4896" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4898" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4900" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4903" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4906" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4910" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4920" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4921" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4923" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4925" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4928" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4931" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4933" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4935" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4938" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4943" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4951" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4953" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4955" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4956" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4959" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4962" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4964" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4966" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4969" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4974" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4982" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4984" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4986" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-4988" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4991" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4994" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4996" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4998" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5001" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5003" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5007" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-5010" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-5015" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5016" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5018" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-5020" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5022" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5023" href="../Lists/#plfa_plfa-part1-Lists-4700" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5032" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5035" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5038" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5040" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5042" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-5048" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5050" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5052" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5053" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5056" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5059" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5060" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5063" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5066" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5068" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-5073" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5081" href="../Lists/#plfa_plfa-part1-Lists-4892" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5083" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5085" href="../Lists/#plfa_plfa-part1-Lists-4896" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5088" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5091" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5092" href="../Lists/#plfa_plfa-part1-Lists-4900" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5095" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5098" href="../Lists/#plfa_plfa-part1-Lists-4903" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5100" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5104" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>++-assoc xs ys zs</code>.</p><p>Recall that Agda supports <a href="../Induction/#sections">sections</a>. Applying <code>cong (x ∷_)</code> promotes the inductive hypothesis:</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>to the equality:</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>which is needed in the proof.</p>It is also easy to show that <code>[]</code> is a left and right identity for <code>_++_</code>. That it is a left identity is immediate from the definition:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-5897" href="../Lists/#plfa_plfa-part1-Lists-5897" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5910" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5912" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5914" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5915" href="../Lists/#plfa_plfa-part1-Lists-5915" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5917" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5919" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5922" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5924" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5925" href="../Lists/#plfa_plfa-part1-Lists-5925" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5928" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5930" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5935" href="../Lists/#plfa_plfa-part1-Lists-5915" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5936" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5938" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5940" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5943" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5946" href="../Lists/#plfa_plfa-part1-Lists-5925" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5949" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5951" href="../Lists/#plfa_plfa-part1-Lists-5925" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-5954" href="../Lists/#plfa_plfa-part1-Lists-5897" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5967" href="../Lists/#plfa_plfa-part1-Lists-5967" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5970" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5974" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5984" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5987" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5990" href="../Lists/#plfa_plfa-part1-Lists-5967" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-5995" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6003" href="../Lists/#plfa_plfa-part1-Lists-5967" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6008" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre>That it is a right identity follows by simple induction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-6079" href="../Lists/#plfa_plfa-part1-Lists-6079" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6092" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6094" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6096" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6097" href="../Lists/#plfa_plfa-part1-Lists-6097" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6099" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6101" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6104" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6106" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6107" href="../Lists/#plfa_plfa-part1-Lists-6107" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6110" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6112" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6117" href="../Lists/#plfa_plfa-part1-Lists-6097" class="Bound">A</a><a id="plfa_plfa-part1-Lists-6118" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6120" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6122" href="../Lists/#plfa_plfa-part1-Lists-6107" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6125" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6128" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6131" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6133" href="../Lists/#plfa_plfa-part1-Lists-6107" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-6136" href="../Lists/#plfa_plfa-part1-Lists-6079" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6149" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6152" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6156" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6166" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6169" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6172" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6177" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6185" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6190" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6192" href="../Lists/#plfa_plfa-part1-Lists-6079" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6205" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6206" href="../Lists/#plfa_plfa-part1-Lists-6206" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6208" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6210" href="../Lists/#plfa_plfa-part1-Lists-6210" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6212" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6214" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6218" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6228" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6229" href="../Lists/#plfa_plfa-part1-Lists-6206" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6231" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6233" href="../Lists/#plfa_plfa-part1-Lists-6210" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6235" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6237" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6240" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6245" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6253" href="../Lists/#plfa_plfa-part1-Lists-6206" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6255" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6257" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6258" href="../Lists/#plfa_plfa-part1-Lists-6210" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6261" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6264" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6266" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6270" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6273" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6278" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6279" href="../Lists/#plfa_plfa-part1-Lists-6206" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6281" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6283" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6285" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6286" href="../Lists/#plfa_plfa-part1-Lists-6079" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6299" href="../Lists/#plfa_plfa-part1-Lists-6210" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6301" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6303" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6309" href="../Lists/#plfa_plfa-part1-Lists-6206" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6311" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6313" href="../Lists/#plfa_plfa-part1-Lists-6210" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6318" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>As we will see later, these three properties establish that <code>_++_</code> and <code>[]</code> form a <em>monoid</em> over lists.</p><h2 id="length">Length</h2>Our next function finds the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-6494" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6501" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6503" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6505" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6506" href="../Lists/#plfa_plfa-part1-Lists-6506" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6508" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6510" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6513" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6515" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6517" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6522" href="../Lists/#plfa_plfa-part1-Lists-6506" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6524" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6526" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-6528" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6535" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-6545" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6548" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-6553" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6560" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6561" href="../Lists/#plfa_plfa-part1-Lists-6561" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6563" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6565" href="../Lists/#plfa_plfa-part1-Lists-6565" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6567" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-6570" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6573" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6577" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6578" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6585" href="../Lists/#plfa_plfa-part1-Lists-6565" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6587" class="Symbol">)</a>
</pre><p>Again, it takes an implicit parameter <code>A</code>. The length of the empty list is zero. The length of a non-empty list is one greater than the length of the tail of the list.</p>Here is an example showing how to compute the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-6834" href="../Lists/#plfa_plfa-part1-Lists-6834" class="Function">_</a> <a id="plfa_plfa-part1-Lists-6836" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6838" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6845" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-6847" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6849" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6851" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6853" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6855" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6857" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-6859" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6861" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-6863" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-6865" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6869" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6879" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6886" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6887" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6889" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6891" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6893" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6895" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6897" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6899" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6901" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6905" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6913" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6917" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6918" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6925" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6926" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6928" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6930" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6932" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6934" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6936" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6941" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6949" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6953" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6954" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6958" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6959" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6966" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6967" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6969" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6971" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6973" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-6979" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6987" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6991" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6992" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6996" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6997" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7001" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7002" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7009" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7010" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-7011" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7013" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-7015" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-7021" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7029" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7033" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7034" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7038" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7039" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7043" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-7047" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-7052" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Computing the length of a list requires time linear in the number of elements in the list.</p><p>In the second-to-last line, we cannot write simply <code>length []</code> but must instead write <code>length {ℕ} []</code>. Since <code>[]</code> has no elements, Agda has insufficient information to infer the implicit parameter.</p><h2 id="reasoning-about-length">Reasoning about length</h2>The length of one list appended to another is the sum of the lengths of the lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-7469" href="../Lists/#plfa_plfa-part1-Lists-7469" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7479" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7481" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7483" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7484" href="../Lists/#plfa_plfa-part1-Lists-7484" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7486" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7488" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7491" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7493" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7494" href="../Lists/#plfa_plfa-part1-Lists-7494" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7497" href="../Lists/#plfa_plfa-part1-Lists-7497" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7500" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7502" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7507" href="../Lists/#plfa_plfa-part1-Lists-7484" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7508" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7512" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7514" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7521" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7522" href="../Lists/#plfa_plfa-part1-Lists-7494" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7525" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7528" href="../Lists/#plfa_plfa-part1-Lists-7497" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7530" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7532" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7534" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7541" href="../Lists/#plfa_plfa-part1-Lists-7494" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7544" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7546" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7553" href="../Lists/#plfa_plfa-part1-Lists-7497" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-7556" href="../Lists/#plfa_plfa-part1-Lists-7469" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7566" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7567" href="../Lists/#plfa_plfa-part1-Lists-7567" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7568" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7570" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7573" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7576" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7580" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7590" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7597" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7598" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7601" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7604" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7606" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7610" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7618" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7625" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7630" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7638" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7645" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7646" href="../Lists/#plfa_plfa-part1-Lists-7567" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7647" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7649" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7652" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7654" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7661" href="../Lists/#plfa_plfa-part1-Lists-7573" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7666" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7668" href="../Lists/#plfa_plfa-part1-Lists-7469" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7678" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7679" href="../Lists/#plfa_plfa-part1-Lists-7679" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7681" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7683" href="../Lists/#plfa_plfa-part1-Lists-7683" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7685" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7687" href="../Lists/#plfa_plfa-part1-Lists-7687" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7690" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7694" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7704" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7711" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-7713" href="../Lists/#plfa_plfa-part1-Lists-7679" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7715" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7717" href="../Lists/#plfa_plfa-part1-Lists-7683" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7719" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7721" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7724" href="../Lists/#plfa_plfa-part1-Lists-7687" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7726" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7730" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7738" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7742" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7743" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7750" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7751" href="../Lists/#plfa_plfa-part1-Lists-7683" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7754" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7757" href="../Lists/#plfa_plfa-part1-Lists-7687" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7759" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-7764" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7767" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7772" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7776" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7777" href="../Lists/#plfa_plfa-part1-Lists-7469" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7787" href="../Lists/#plfa_plfa-part1-Lists-7683" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7790" href="../Lists/#plfa_plfa-part1-Lists-7687" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7792" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7794" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7800" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7804" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7805" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7812" href="../Lists/#plfa_plfa-part1-Lists-7683" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7815" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7817" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7824" href="../Lists/#plfa_plfa-part1-Lists-7687" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7826" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7830" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7838" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7845" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7846" href="../Lists/#plfa_plfa-part1-Lists-7679" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7848" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7850" href="../Lists/#plfa_plfa-part1-Lists-7683" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7852" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7854" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7856" href="../Lists/#plfa_plfa-part1-Lists-6494" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7863" href="../Lists/#plfa_plfa-part1-Lists-7687" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7868" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. As before, Agda cannot infer the implicit type parameter to <code>length</code>, and it must be given explicitly. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>length-++ xs ys</code>, and it is promoted by the congruence <code>cong suc</code>.</p><h2 id="reverse">Reverse</h2>Using append, it is easy to formulate a function to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-8496" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8504" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8506" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8508" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8509" href="../Lists/#plfa_plfa-part1-Lists-8509" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8511" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8513" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8516" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8518" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8520" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8525" href="../Lists/#plfa_plfa-part1-Lists-8509" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8527" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8529" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8534" href="../Lists/#plfa_plfa-part1-Lists-8509" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-8536" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8544" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8554" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8557" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-8560" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8568" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8569" href="../Lists/#plfa_plfa-part1-Lists-8569" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8571" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8573" href="../Lists/#plfa_plfa-part1-Lists-8573" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8575" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8578" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8581" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8589" href="../Lists/#plfa_plfa-part1-Lists-8573" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-8592" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8595" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8597" href="../Lists/#plfa_plfa-part1-Lists-8569" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8599" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a>
</pre><p>The reverse of the empty list is the empty list. The reverse of a non-empty list is the reverse of its tail appended to a unit list containing its head.</p>Here is an example showing how to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-8817" href="../Lists/#plfa_plfa-part1-Lists-8817" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8819" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8821" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8829" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8831" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8833" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8835" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8837" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8839" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8841" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8843" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8845" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8847" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8849" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8851" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8853" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8855" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8857" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-8859" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8861" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8865" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8875" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8883" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8884" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8886" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8888" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8890" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8892" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8894" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8896" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8898" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8902" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8910" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8918" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8919" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8921" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8923" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8925" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8927" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8929" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8931" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8934" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8936" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8938" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8942" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8950" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8951" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8959" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8960" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8962" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8964" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8966" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8968" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8971" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8973" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8975" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8976" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8978" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8981" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8983" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8985" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8989" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8997" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8999" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-9007" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9010" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9013" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9015" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9017" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9018" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9020" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9023" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9025" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9027" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9028" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9030" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9033" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9035" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9037" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9041" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9049" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9051" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9054" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9057" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9059" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9061" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9062" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9064" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9067" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9069" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9071" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9072" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9074" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9077" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9079" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9081" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9085" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9093" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9095" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9098" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9101" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9103" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9105" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9107" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9109" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9112" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9114" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9116" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9118" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9120" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9123" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9125" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9127" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9132" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9140" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9141" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9143" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9145" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9148" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9151" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9153" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9155" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9157" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9159" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9162" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9164" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9166" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9171" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9179" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9181" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9183" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9184" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9187" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9190" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9192" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9194" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9196" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9198" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9201" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9203" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9205" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9210" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9218" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9219" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9221" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9223" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9225" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9227" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9229" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9231" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9234" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9236" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9238" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9243" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9251" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9253" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9255" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9256" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9258" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9260" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9263" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9266" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9268" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9270" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9272" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9276" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9284" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9286" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9288" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9290" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9292" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9293" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9296" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9299" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9301" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9303" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9305" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9309" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9317" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9319" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9321" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9323" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9325" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9327" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9329" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9334" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9342" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9344" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9346" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9348" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9350" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9352" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9354" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9358" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Reversing a list in this way takes time <em>quadratic</em> in the length of the list. This is because reverse ends up appending lists of lengths <code>1</code>, <code>2</code>, up to <code>n - 1</code>, where <code>n</code> is the length of the list being reversed, append takes time linear in the length of the first list, and the sum of the numbers up to <code>n - 1</code> is <code>n * (n - 1) / 2</code>. (We will validate that last fact in an exercise later in this chapter.)</p><h4 id="exercise-reverse--distrib-recommended">Exercise <code>reverse-++-distrib</code> (recommended)</h4><p>Show that the reverse of one list appended to another is the reverse of the second appended to the reverse of the first:</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-10004" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-reverse-involutive-recommended">Exercise <code>reverse-involutive</code> (recommended)</h4><p>A function is an <em>involution</em> if when applied twice it acts as the identity function. Show that reverse is an involution:</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-10246" class="Comment">-- Your code goes here</a>
</pre><h2 id="faster-reverse">Faster reverse</h2>The definition above, while easy to reason about, is less efficient than one might expect since it takes time quadratic in the length of the list. The idea is that we generalise reverse to take an additional argument:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-10520" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10526" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10528" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10530" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10531" href="../Lists/#plfa_plfa-part1-Lists-10531" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10533" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10535" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10538" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10540" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10542" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10547" href="../Lists/#plfa_plfa-part1-Lists-10531" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10549" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10551" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10556" href="../Lists/#plfa_plfa-part1-Lists-10531" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10558" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10560" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10565" href="../Lists/#plfa_plfa-part1-Lists-10531" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10567" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10573" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-10582" href="../Lists/#plfa_plfa-part1-Lists-10582" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10586" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10589" href="../Lists/#plfa_plfa-part1-Lists-10582" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10592" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10598" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10599" href="../Lists/#plfa_plfa-part1-Lists-10599" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10601" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10603" href="../Lists/#plfa_plfa-part1-Lists-10603" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10605" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10607" href="../Lists/#plfa_plfa-part1-Lists-10607" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10611" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10614" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10620" href="../Lists/#plfa_plfa-part1-Lists-10603" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10623" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10624" href="../Lists/#plfa_plfa-part1-Lists-10599" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10626" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10628" href="../Lists/#plfa_plfa-part1-Lists-10607" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10630" class="Symbol">)</a>
</pre><p>The definition is by recursion on the first argument. The second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we recurse becomes <em>smaller</em>.</p>Shunt is related to reverse as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-10872" href="../Lists/#plfa_plfa-part1-Lists-10872" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10886" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10888" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10890" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10891" href="../Lists/#plfa_plfa-part1-Lists-10891" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10893" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10895" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10898" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10900" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10901" href="../Lists/#plfa_plfa-part1-Lists-10901" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10904" href="../Lists/#plfa_plfa-part1-Lists-10904" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10907" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10909" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10914" href="../Lists/#plfa_plfa-part1-Lists-10891" class="Bound">A</a><a id="plfa_plfa-part1-Lists-10915" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10919" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10921" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10927" href="../Lists/#plfa_plfa-part1-Lists-10901" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10930" href="../Lists/#plfa_plfa-part1-Lists-10904" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10933" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-10935" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10943" href="../Lists/#plfa_plfa-part1-Lists-10901" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10946" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10949" href="../Lists/#plfa_plfa-part1-Lists-10904" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10952" href="../Lists/#plfa_plfa-part1-Lists-10872" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10966" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10969" href="../Lists/#plfa_plfa-part1-Lists-10969" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10972" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-10976" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-10986" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10992" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10995" href="../Lists/#plfa_plfa-part1-Lists-10969" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11000" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11008" href="../Lists/#plfa_plfa-part1-Lists-10969" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11013" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11021" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11029" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11032" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11035" href="../Lists/#plfa_plfa-part1-Lists-10969" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11040" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-11042" href="../Lists/#plfa_plfa-part1-Lists-10872" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-11056" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11057" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11059" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11061" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11063" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11065" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-11068" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11072" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11082" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11088" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11089" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11091" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11093" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11095" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11097" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11102" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11110" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11116" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11119" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11120" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11122" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11124" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11126" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11130" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-11133" href="../Lists/#plfa_plfa-part1-Lists-10872" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-11147" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11150" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11151" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11153" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11155" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11157" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11159" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-11165" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11173" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11176" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11179" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11180" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11182" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11184" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11186" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11190" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11198" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11206" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11209" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11212" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11213" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11215" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11217" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11219" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11222" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11224" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11228" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-11231" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-11235" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11236" href="../Lists/#plfa_plfa-part1-Lists-4700" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-11245" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11246" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11254" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11256" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11258" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11260" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11262" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11264" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11266" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11268" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-11274" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11275" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11283" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11286" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11289" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11291" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11293" href="../Lists/#plfa_plfa-part1-Lists-2987" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11294" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11296" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11299" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11304" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11312" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11320" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11321" href="../Lists/#plfa_plfa-part1-Lists-11057" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11323" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11325" href="../Lists/#plfa_plfa-part1-Lists-11061" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11327" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11329" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11332" href="../Lists/#plfa_plfa-part1-Lists-11065" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11337" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code> and follows by the inductive hypothesis and associativity of append. When we invoke the inductive hypothesis, the second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we induct becomes <em>smaller</em>.</p><p>Generalising on an auxiliary argument, which becomes larger as the argument on which we recurse or induct becomes smaller, is a common trick. It belongs in your quiver of arrows, ready to slay the right problem.</p>Having defined shunt by generalisation, it is now easy to respecialise to give a more efficient definition of reverse:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-12100" href="../Lists/#plfa_plfa-part1-Lists-12100" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12109" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12111" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12113" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12114" href="../Lists/#plfa_plfa-part1-Lists-12114" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12116" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12118" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12121" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12123" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12125" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12130" href="../Lists/#plfa_plfa-part1-Lists-12114" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12132" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12134" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12139" href="../Lists/#plfa_plfa-part1-Lists-12114" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-12141" href="../Lists/#plfa_plfa-part1-Lists-12100" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12150" href="../Lists/#plfa_plfa-part1-Lists-12150" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12153" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-12155" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12161" href="../Lists/#plfa_plfa-part1-Lists-12150" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12164" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
</pre>Given our previous lemma, it is straightforward to show the two definitions equivalent:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-12268" href="../Lists/#plfa_plfa-part1-Lists-12268" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12277" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12279" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12281" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12282" href="../Lists/#plfa_plfa-part1-Lists-12282" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12284" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12286" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12289" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12291" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12292" href="../Lists/#plfa_plfa-part1-Lists-12292" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12295" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12297" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12302" href="../Lists/#plfa_plfa-part1-Lists-12282" class="Bound">A</a><a id="plfa_plfa-part1-Lists-12303" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12307" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12309" href="../Lists/#plfa_plfa-part1-Lists-12100" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12318" href="../Lists/#plfa_plfa-part1-Lists-12292" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12321" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12323" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12331" href="../Lists/#plfa_plfa-part1-Lists-12292" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-12334" href="../Lists/#plfa_plfa-part1-Lists-12268" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12343" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12346" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12350" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12360" href="../Lists/#plfa_plfa-part1-Lists-12100" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12369" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12374" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12382" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12388" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12391" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12396" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12399" href="../Lists/#plfa_plfa-part1-Lists-10872" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-12413" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12416" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12419" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12425" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12433" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12436" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-12439" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12444" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12447" href="../Lists/#plfa_plfa-part1-Lists-6079" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-12460" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12461" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12469" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-12471" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12473" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12479" href="../Lists/#plfa_plfa-part1-Lists-8496" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12487" href="../Lists/#plfa_plfa-part1-Lists-12343" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12492" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre>Here is an example showing fast reverse of the list <code>[ 0 , 1 , 2 ]</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-12576" href="../Lists/#plfa_plfa-part1-Lists-12576" class="Function">_</a> <a id="plfa_plfa-part1-Lists-12578" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12580" href="../Lists/#plfa_plfa-part1-Lists-12100" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12589" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12591" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12593" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12595" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12597" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12599" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12601" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-12603" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12605" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12607" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12609" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12611" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12613" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12615" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12617" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-12619" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-12621" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12625" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12635" href="../Lists/#plfa_plfa-part1-Lists-12100" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12644" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12645" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12647" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12649" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12651" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12653" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12655" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12657" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12659" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12663" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12671" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12677" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12678" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12680" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12682" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12684" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12686" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12688" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12690" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12692" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12694" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12699" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12707" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12713" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12714" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12716" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12718" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12720" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12722" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12724" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12726" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12727" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12729" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12731" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12733" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12737" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12745" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12751" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12752" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12754" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12756" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12758" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12760" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12761" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12763" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12765" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12767" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12769" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12771" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12775" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12783" href="../Lists/#plfa_plfa-part1-Lists-10520" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12789" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12792" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12793" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12795" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12797" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12799" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12801" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12803" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12805" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12807" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12811" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12819" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12821" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12823" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12825" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12827" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12829" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12831" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12836" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Now the time to reverse a list is linear in the length of the list.</p><h2 id="Map">Map</h2>Map applies a function to every element of a list to generate a corresponding list. Map is an example of a <em>higher-order function</em>, one which takes a function as an argument or returns a function as a result:<pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-13143" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13147" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13149" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13151" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13152" href="../Lists/#plfa_plfa-part1-Lists-13152" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13154" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-13156" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13158" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13161" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13163" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13166" href="../Lists/#plfa_plfa-part1-Lists-13152" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13168" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13170" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">B</a><a id="plfa_plfa-part1-Lists-13171" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13173" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13175" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13180" href="../Lists/#plfa_plfa-part1-Lists-13152" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13182" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13184" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13189" href="../Lists/#plfa_plfa-part1-Lists-13154" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-13191" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13195" href="../Lists/#plfa_plfa-part1-Lists-13195" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13197" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-13207" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13210" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-13213" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13217" href="../Lists/#plfa_plfa-part1-Lists-13217" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13220" href="../Lists/#plfa_plfa-part1-Lists-13220" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13222" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13224" href="../Lists/#plfa_plfa-part1-Lists-13224" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13226" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-13229" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13232" href="../Lists/#plfa_plfa-part1-Lists-13217" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13234" href="../Lists/#plfa_plfa-part1-Lists-13220" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13236" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13238" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13242" href="../Lists/#plfa_plfa-part1-Lists-13217" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13244" href="../Lists/#plfa_plfa-part1-Lists-13224" class="Bound">xs</a>
</pre><p>Map of the empty list is the empty list. Map of a non-empty list yields a list with head the same as the function applied to the head of the given list, and tail the same as map of the function applied to the tail of the given list.</p>Here is an example showing how to use map to increment every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-13573" href="../Lists/#plfa_plfa-part1-Lists-13573" class="Function">_</a> <a id="plfa_plfa-part1-Lists-13575" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13577" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13581" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13585" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13587" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13589" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13591" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13593" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13595" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13597" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13599" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13601" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13603" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13605" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13607" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13609" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13611" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13613" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-13615" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-13617" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13621" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13631" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13635" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13639" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13640" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13642" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13644" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13646" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13648" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13650" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13652" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13654" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13658" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13666" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13670" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13672" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13674" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13678" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13682" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13683" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13685" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13687" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13689" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13691" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13693" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13697" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13705" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13709" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13711" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13713" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13717" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13719" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13721" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13725" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13729" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13730" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13732" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13734" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13736" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13740" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13748" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13752" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13754" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13756" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13760" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13762" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13764" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13768" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13770" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13772" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13776" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13780" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13785" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13793" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13797" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13799" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13801" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13805" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13807" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13809" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13813" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13815" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13817" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13822" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13830" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13832" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13834" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13836" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13838" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13840" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13842" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13847" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Map requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying map to a function to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-14066" href="../Lists/#plfa_plfa-part1-Lists-14066" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14071" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14073" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-14078" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-14080" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-14082" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-14087" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-14089" href="../Lists/#plfa_plfa-part1-Lists-14066" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14094" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-14096" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-14100" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-14105" href="../Lists/#plfa_plfa-part1-Lists-14105" class="Function">_</a> <a id="plfa_plfa-part1-Lists-14107" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14109" href="../Lists/#plfa_plfa-part1-Lists-14066" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14114" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14116" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14118" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14120" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14122" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14124" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14126" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14128" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-14130" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14132" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14134" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14136" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14138" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14140" class="Number">3</a> <a id="plfa_plfa-part1-Lists-14142" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-14144" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-14146" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-14150" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-14160" href="../Lists/#plfa_plfa-part1-Lists-14066" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14165" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14167" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14169" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14171" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14173" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14175" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14177" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14181" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14189" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-14193" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-14197" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14199" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14201" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14203" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14205" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14207" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14209" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14213" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14221" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14223" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14225" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14227" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14229" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14231" class="Number">3</a> <a id="plfa_plfa-part1-Lists-14233" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14237" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>A type that is parameterised on another type, such as list, often has a corresponding map, which accepts a function and returns a function from the type parameterised on the domain of the function to the type parameterised on the range of the function. Further, a type that is parameterised on <em>n</em> types often has a map that is parameterised on <em>n</em> functions.</p><h4 id="exercise-map-compose-practice">Exercise <code>map-compose</code> (practice)</h4><p>Prove that the map of a composition is equal to the composition of two maps:</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>The last step of the proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-14818" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map--distribute-practice">Exercise <code>map-++-distribute</code> (practice)</h4><p>Prove the following relationship between map and append:</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-15003" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-tree-practice">Exercise <code>map-Tree</code> (practice)</h4>Define a type of trees with leaves of type <code>A</code> and internal nodes of type <code>B</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-15155" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-15160" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15166" href="../Lists/#plfa_plfa-part1-Lists-15166" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15168" href="../Lists/#plfa_plfa-part1-Lists-15168" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15170" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15172" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15175" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15177" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15179" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-15183" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-15191" href="../Lists/#plfa_plfa-part1-Lists-15191" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-15196" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15198" href="../Lists/#plfa_plfa-part1-Lists-15166" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15200" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15202" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15207" href="../Lists/#plfa_plfa-part1-Lists-15166" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15209" href="../Lists/#plfa_plfa-part1-Lists-15168" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-15213" href="../Lists/#plfa_plfa-part1-Lists-15213" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-15218" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15220" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15225" href="../Lists/#plfa_plfa-part1-Lists-15166" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15227" href="../Lists/#plfa_plfa-part1-Lists-15168" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15229" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15231" href="../Lists/#plfa_plfa-part1-Lists-15168" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15233" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15235" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15240" href="../Lists/#plfa_plfa-part1-Lists-15166" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15242" href="../Lists/#plfa_plfa-part1-Lists-15168" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15244" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15246" href="../Lists/#plfa_plfa-part1-Lists-15160" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15251" href="../Lists/#plfa_plfa-part1-Lists-15166" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15253" href="../Lists/#plfa_plfa-part1-Lists-15168" class="Bound">B</a>
</pre><p>Define a suitable map operator over trees:</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-15387" class="Comment">-- Your code goes here</a>
</pre><h2 id="Fold">Fold</h2>Fold takes an operator and a value, and uses the operator to combine each of the elements of the list, taking the given value as the result for the empty list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-15600" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15606" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15608" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15610" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15611" href="../Lists/#plfa_plfa-part1-Lists-15611" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15613" href="../Lists/#plfa_plfa-part1-Lists-15613" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15615" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15617" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15620" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15622" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15624" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15625" href="../Lists/#plfa_plfa-part1-Lists-15611" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15627" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15629" href="../Lists/#plfa_plfa-part1-Lists-15613" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15631" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15633" href="../Lists/#plfa_plfa-part1-Lists-15613" class="Bound">B</a><a id="plfa_plfa-part1-Lists-15634" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15636" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15638" href="../Lists/#plfa_plfa-part1-Lists-15613" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15640" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15642" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15647" href="../Lists/#plfa_plfa-part1-Lists-15611" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15649" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15651" href="../Lists/#plfa_plfa-part1-Lists-15613" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-15653" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15659" href="../Lists/#plfa_plfa-part1-Lists-15659" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15663" href="../Lists/#plfa_plfa-part1-Lists-15663" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15665" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-15675" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15678" href="../Lists/#plfa_plfa-part1-Lists-15663" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-15680" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15686" href="../Lists/#plfa_plfa-part1-Lists-15686" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15690" href="../Lists/#plfa_plfa-part1-Lists-15690" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15692" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15693" href="../Lists/#plfa_plfa-part1-Lists-15693" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15695" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15697" href="../Lists/#plfa_plfa-part1-Lists-15697" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15699" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-15702" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15705" href="../Lists/#plfa_plfa-part1-Lists-15693" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15707" href="../Lists/#plfa_plfa-part1-Lists-15686" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-15709" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15715" href="../Lists/#plfa_plfa-part1-Lists-15686" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15719" href="../Lists/#plfa_plfa-part1-Lists-15690" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15721" href="../Lists/#plfa_plfa-part1-Lists-15697" class="Bound">xs</a>
</pre><p>Fold of the empty list is the given value. Fold of a non-empty list uses the operator to combine the head of the list and the fold of the tail of the list.</p>Here is an example showing how to use fold to find the sum of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-15963" href="../Lists/#plfa_plfa-part1-Lists-15963" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15965" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15967" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15973" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15977" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15979" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15981" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15983" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15985" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15987" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15989" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15991" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15993" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15995" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15997" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15999" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-16002" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16004" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16008" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16018" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16024" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16028" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16030" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16031" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16033" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16035" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16037" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16039" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16041" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16043" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16045" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16047" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16049" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16053" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16061" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16063" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16065" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16071" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16075" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16077" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16078" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16080" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16082" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16084" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16086" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16088" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16090" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16092" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16096" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16104" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16106" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16108" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16109" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16111" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16113" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16119" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16123" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16125" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16126" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16128" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16130" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16132" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16134" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16136" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-16141" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16149" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16151" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16153" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16154" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16156" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16158" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16159" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16161" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16163" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16169" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16173" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16175" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16176" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16178" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16180" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16182" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16188" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16196" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16198" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16200" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16201" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16203" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16205" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16206" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16208" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16210" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16211" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16213" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16215" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16221" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16225" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16227" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16229" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16235" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16243" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16245" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16247" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16248" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16250" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16252" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16253" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16255" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16257" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16258" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16260" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16262" class="Number">0</a><a id="plfa_plfa-part1-Lists-16263" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16269" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Here we have an instance of <code>foldr</code> where <code>A</code> and <code>B</code> are both <code>ℕ</code>. Fold requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying fold to an operator and a value to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-16571" href="../Lists/#plfa_plfa-part1-Lists-16571" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16575" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16577" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16582" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-16584" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16586" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-16588" href="../Lists/#plfa_plfa-part1-Lists-16571" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16592" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-16594" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16600" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16604" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-16607" href="../Lists/#plfa_plfa-part1-Lists-16607" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16609" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16611" href="../Lists/#plfa_plfa-part1-Lists-16571" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16615" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16617" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16619" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16621" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16623" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16625" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16627" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16629" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16631" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16633" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16635" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-16638" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16640" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16644" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16654" href="../Lists/#plfa_plfa-part1-Lists-16571" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16658" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16660" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16662" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16664" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16666" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16668" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16670" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16672" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16674" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16678" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16686" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16692" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16696" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16698" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16700" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16702" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16704" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16706" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16708" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16710" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16712" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16714" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16718" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16726" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-16731" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Just as the list type has two constructors, <code>[]</code> and <code>_∷_</code>, so the fold function takes two arguments, <code>e</code> and <code>_⊗_</code> (in addition to the list argument). In general, a data type with <em>n</em> constructors will have a corresponding fold function that takes <em>n</em> arguments.</p><p>As another example, observe that</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Here, if <code>xs</code> is of type <code>List A</code>, then we see we have an instance of <code>foldr</code> where <code>A</code> is <code>A</code> and <code>B</code> is <code>List A</code>. It follows that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>Demonstrating both these equations is left as an exercise.</p><h4 id="exercise-product-recommended">Exercise <code>product</code> (recommended)</h4><p>Use fold to define a function to find the product of a list of numbers. For example:</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17459" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--recommended">Exercise <code>foldr-++</code> (recommended)</h4>Show that fold and append are related as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-17585" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-17597" href="../Lists/#plfa_plfa-part1-Lists-17597" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-17606" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17608" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-17610" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-17611" href="../Lists/#plfa_plfa-part1-Lists-17611" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-17613" href="../Lists/#plfa_plfa-part1-Lists-17613" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-17615" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17617" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-17620" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-17622" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17623" href="../Lists/#plfa_plfa-part1-Lists-17623" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17627" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17629" href="../Lists/#plfa_plfa-part1-Lists-17611" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-17631" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17633" href="../Lists/#plfa_plfa-part1-Lists-17613" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-17635" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17637" href="../Lists/#plfa_plfa-part1-Lists-17613" class="Bound">B</a><a id="plfa_plfa-part1-Lists-17638" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17640" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17641" href="../Lists/#plfa_plfa-part1-Lists-17641" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17643" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17645" href="../Lists/#plfa_plfa-part1-Lists-17613" class="Bound">B</a><a id="plfa_plfa-part1-Lists-17646" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17648" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17649" href="../Lists/#plfa_plfa-part1-Lists-17649" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-17652" href="../Lists/#plfa_plfa-part1-Lists-17652" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-17655" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17657" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17662" href="../Lists/#plfa_plfa-part1-Lists-17611" class="Bound">A</a><a id="plfa_plfa-part1-Lists-17663" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17665" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-17671" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17677" href="../Lists/#plfa_plfa-part1-Lists-17623" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17681" href="../Lists/#plfa_plfa-part1-Lists-17641" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17683" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17684" href="../Lists/#plfa_plfa-part1-Lists-17649" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-17687" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-17690" href="../Lists/#plfa_plfa-part1-Lists-17652" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-17692" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17694" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17696" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17702" href="../Lists/#plfa_plfa-part1-Lists-17623" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17706" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17707" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17713" href="../Lists/#plfa_plfa-part1-Lists-17623" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17717" href="../Lists/#plfa_plfa-part1-Lists-17641" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17719" href="../Lists/#plfa_plfa-part1-Lists-17652" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-17721" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17723" href="../Lists/#plfa_plfa-part1-Lists-17649" class="Bound">xs</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17739" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17924" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-foldr-practice">Exercise <code>map-is-foldr</code> (practice)</h4><p>Show that map can be defined using fold:</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>The proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18121" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-fold-tree-practice">Exercise <code>fold-Tree</code> (practice)</h4><p>Define a suitable fold function for the type of trees given earlier:</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18342" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-fold-tree-practice">Exercise <code>map-is-fold-Tree</code> (practice)</h4><p>Demonstrate an analogue of <code>map-is-foldr</code> for the type of trees.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18489" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-sum-downfrom-stretch">Exercise <code>sum-downFrom</code> (stretch)</h4>Define a function that counts down as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-18612" href="../Lists/#plfa_plfa-part1-Lists-18612" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18621" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18623" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-18625" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18627" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-18632" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-18634" href="../Lists/#plfa_plfa-part1-Lists-18612" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18643" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-18652" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18655" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-18658" href="../Lists/#plfa_plfa-part1-Lists-18612" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18667" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18668" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-18672" href="../Lists/#plfa_plfa-part1-Lists-18672" class="Bound">n</a><a id="plfa_plfa-part1-Lists-18673" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-18676" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18679" href="../Lists/#plfa_plfa-part1-Lists-18672" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-18681" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-18683" href="../Lists/#plfa_plfa-part1-Lists-18612" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18692" href="../Lists/#plfa_plfa-part1-Lists-18672" class="Bound">n</a>
</pre>For example:<pre class="Agda"><a id="plfa_plfa-part1-Lists-18719" href="../Lists/#plfa_plfa-part1-Lists-18719" class="Function">_</a> <a id="plfa_plfa-part1-Lists-18721" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18723" href="../Lists/#plfa_plfa-part1-Lists-18612" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18732" class="Number">3</a> <a id="plfa_plfa-part1-Lists-18734" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18736" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-18738" class="Number">2</a> <a id="plfa_plfa-part1-Lists-18740" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18742" class="Number">1</a> <a id="plfa_plfa-part1-Lists-18744" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18746" class="Number">0</a> <a id="plfa_plfa-part1-Lists-18748" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-18750" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-18752" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-18754" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>Prove that the sum of the numbers <code>(n - 1) + ⋯ + 0</code> is equal to <code>n * (n ∸ 1) / 2</code>:</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18895" class="Comment">-- Your code goes here</a>
</pre><h2 id="monoids">Monoids</h2><p>Typically when we use a fold the operator is associative and the value is a left and right identity for the operator, meaning that the operator and the value form a <em>monoid</em>.</p>We can define a monoid as a suitable record type:<pre class="Agda"><a id="plfa_plfa-part1-Lists-19169" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-19176" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19185" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19186" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19188" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19190" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19193" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19195" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19196" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19200" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19202" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19204" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19206" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19208" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19210" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19211" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19213" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19214" href="../Lists/#plfa_plfa-part1-Lists-19214" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19216" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19218" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19219" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19221" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19223" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-19227" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-19235" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-19245" href="../Lists/#plfa_plfa-part1-Lists-19245" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19251" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19253" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19255" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19256" href="../Lists/#plfa_plfa-part1-Lists-19256" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19258" href="../Lists/#plfa_plfa-part1-Lists-19258" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19260" href="../Lists/#plfa_plfa-part1-Lists-19260" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-19262" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19264" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19265" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19267" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19269" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19270" href="../Lists/#plfa_plfa-part1-Lists-19256" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19272" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19274" href="../Lists/#plfa_plfa-part1-Lists-19258" class="Bound">y</a><a id="plfa_plfa-part1-Lists-19275" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19277" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19279" href="../Lists/#plfa_plfa-part1-Lists-19260" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-19281" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19283" href="../Lists/#plfa_plfa-part1-Lists-19256" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19285" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19287" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19288" href="../Lists/#plfa_plfa-part1-Lists-19258" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19290" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19292" href="../Lists/#plfa_plfa-part1-Lists-19260" class="Bound">z</a><a id="plfa_plfa-part1-Lists-19293" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-19299" href="../Lists/#plfa_plfa-part1-Lists-19299" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19309" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19311" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19313" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19314" href="../Lists/#plfa_plfa-part1-Lists-19314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19316" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19318" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19319" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19321" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19323" href="../Lists/#plfa_plfa-part1-Lists-19214" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19325" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19327" href="../Lists/#plfa_plfa-part1-Lists-19314" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19329" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19331" href="../Lists/#plfa_plfa-part1-Lists-19314" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-19337" href="../Lists/#plfa_plfa-part1-Lists-19337" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19347" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19349" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19351" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19352" href="../Lists/#plfa_plfa-part1-Lists-19352" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19354" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19356" href="../Lists/#plfa_plfa-part1-Lists-19186" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19357" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19359" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19361" href="../Lists/#plfa_plfa-part1-Lists-19352" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19363" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19365" href="../Lists/#plfa_plfa-part1-Lists-19214" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19367" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19369" href="../Lists/#plfa_plfa-part1-Lists-19352" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-19372" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-19377" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Module">IsMonoid</a>
</pre>As examples, sum and zero, multiplication and one, and append and the empty list, are all examples of monoids:<pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-19510" href="../Lists/#plfa_plfa-part1-Lists-19510" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19519" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19521" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19530" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19534" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-19536" href="../Lists/#plfa_plfa-part1-Lists-19510" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19545" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19549" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19560" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19562" href="../Lists/#plfa_plfa-part1-Lists-19245" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19568" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19570" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15113" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-19582" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19584" href="../Lists/#plfa_plfa-part1-Lists-19299" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19594" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19596" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15214" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19612" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19614" href="../Lists/#plfa_plfa-part1-Lists-19337" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19624" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19626" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15269" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19642" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-19645" href="../Lists/#plfa_plfa-part1-Lists-19645" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19654" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19656" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19665" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-19669" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-19671" href="../Lists/#plfa_plfa-part1-Lists-19645" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19680" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19684" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19695" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19697" href="../Lists/#plfa_plfa-part1-Lists-19245" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19703" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19705" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#22674" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-19717" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19719" href="../Lists/#plfa_plfa-part1-Lists-19299" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19729" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19731" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21574" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19747" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19749" href="../Lists/#plfa_plfa-part1-Lists-19337" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19759" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19761" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21638" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19777" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-19780" href="../Lists/#plfa_plfa-part1-Lists-19780" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19790" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19792" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19794" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19795" href="../Lists/#plfa_plfa-part1-Lists-19795" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19797" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19799" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19802" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19804" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19806" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19815" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19816" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19821" href="../Lists/#plfa_plfa-part1-Lists-19795" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19822" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19824" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-19829" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-19832" href="../Lists/#plfa_plfa-part1-Lists-19780" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19842" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19846" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19857" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19859" href="../Lists/#plfa_plfa-part1-Lists-19245" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19865" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19867" href="../Lists/#plfa_plfa-part1-Lists-4700" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-19880" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19882" href="../Lists/#plfa_plfa-part1-Lists-19299" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19892" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19894" href="../Lists/#plfa_plfa-part1-Lists-5897" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19911" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19913" href="../Lists/#plfa_plfa-part1-Lists-19337" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19923" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19925" href="../Lists/#plfa_plfa-part1-Lists-6079" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19942" class="Symbol">}</a>
</pre>If <code>_⊗_</code> and <code>e</code> form a monoid, then we can re-express fold on the same operator and an arbitrary value:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-20062" href="../Lists/#plfa_plfa-part1-Lists-20062" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20075" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20077" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20079" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20080" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20082" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20084" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20087" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20089" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20090" href="../Lists/#plfa_plfa-part1-Lists-20090" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20094" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20096" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20098" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20100" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20102" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20104" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20105" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20107" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20108" href="../Lists/#plfa_plfa-part1-Lists-20108" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20110" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20112" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20113" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20115" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20117" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-20126" href="../Lists/#plfa_plfa-part1-Lists-20090" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20130" href="../Lists/#plfa_plfa-part1-Lists-20108" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20132" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-20136" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20138" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20139" href="../Lists/#plfa_plfa-part1-Lists-20139" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20142" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20144" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20149" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20150" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20152" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20153" href="../Lists/#plfa_plfa-part1-Lists-20153" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20155" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20157" href="../Lists/#plfa_plfa-part1-Lists-20080" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20158" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20160" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20162" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20168" href="../Lists/#plfa_plfa-part1-Lists-20090" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20172" href="../Lists/#plfa_plfa-part1-Lists-20153" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20174" href="../Lists/#plfa_plfa-part1-Lists-20139" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20177" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20179" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20185" href="../Lists/#plfa_plfa-part1-Lists-20090" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20189" href="../Lists/#plfa_plfa-part1-Lists-20108" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20191" href="../Lists/#plfa_plfa-part1-Lists-20139" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20194" href="../Lists/#plfa_plfa-part1-Lists-20090" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20196" href="../Lists/#plfa_plfa-part1-Lists-20153" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-20198" href="../Lists/#plfa_plfa-part1-Lists-20062" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20211" href="../Lists/#plfa_plfa-part1-Lists-20211" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20215" href="../Lists/#plfa_plfa-part1-Lists-20215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20217" href="../Lists/#plfa_plfa-part1-Lists-20217" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20226" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-20229" href="../Lists/#plfa_plfa-part1-Lists-20229" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20231" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20235" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20245" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20251" href="../Lists/#plfa_plfa-part1-Lists-20211" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20255" href="../Lists/#plfa_plfa-part1-Lists-20229" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20257" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-20262" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20270" href="../Lists/#plfa_plfa-part1-Lists-20229" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20274" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20277" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20281" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20282" href="../Lists/#plfa_plfa-part1-Lists-19299" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-20292" href="../Lists/#plfa_plfa-part1-Lists-20217" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20301" href="../Lists/#plfa_plfa-part1-Lists-20229" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20302" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20304" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20310" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20311" href="../Lists/#plfa_plfa-part1-Lists-20215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20313" href="../Lists/#plfa_plfa-part1-Lists-20211" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20315" href="../Lists/#plfa_plfa-part1-Lists-20229" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20316" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20320" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20328" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20334" href="../Lists/#plfa_plfa-part1-Lists-20211" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20338" href="../Lists/#plfa_plfa-part1-Lists-20215" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20340" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-20343" href="../Lists/#plfa_plfa-part1-Lists-20211" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20345" href="../Lists/#plfa_plfa-part1-Lists-20229" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20349" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-20351" href="../Lists/#plfa_plfa-part1-Lists-20062" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20364" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20368" href="../Lists/#plfa_plfa-part1-Lists-20368" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20370" href="../Lists/#plfa_plfa-part1-Lists-20370" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20379" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20380" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20382" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20384" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20386" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20388" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20390" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20394" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20404" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20410" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20414" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20416" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20417" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20419" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20421" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20423" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20427" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20435" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20437" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20439" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20440" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20446" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20450" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20452" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20454" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20458" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20461" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-20466" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20467" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20469" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-20471" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20473" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20474" href="../Lists/#plfa_plfa-part1-Lists-20062" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20487" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20491" href="../Lists/#plfa_plfa-part1-Lists-20368" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20493" href="../Lists/#plfa_plfa-part1-Lists-20370" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20502" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20505" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20506" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20508" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20514" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20516" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20518" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20519" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20525" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20529" href="../Lists/#plfa_plfa-part1-Lists-20368" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20531" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20534" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20536" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20537" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20541" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20544" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20548" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20549" href="../Lists/#plfa_plfa-part1-Lists-19245" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-20555" href="../Lists/#plfa_plfa-part1-Lists-20370" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20564" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20566" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20567" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20573" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20577" href="../Lists/#plfa_plfa-part1-Lists-20368" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20579" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20581" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20583" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20584" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20586" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20592" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20593" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20595" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20597" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20603" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20607" href="../Lists/#plfa_plfa-part1-Lists-20368" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20609" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20611" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20613" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20615" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20619" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20627" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20633" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20637" href="../Lists/#plfa_plfa-part1-Lists-20368" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20639" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20640" href="../Lists/#plfa_plfa-part1-Lists-20380" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20642" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20644" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20646" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20648" href="../Lists/#plfa_plfa-part1-Lists-20364" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20650" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20654" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>In exercise <code>foldr-++</code> above we showed the following:</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre>As a consequence we can decompose fold over append in a monoid into two folds as follows.<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-20874" href="../Lists/#plfa_plfa-part1-Lists-20874" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-20890" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20892" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20894" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20895" href="../Lists/#plfa_plfa-part1-Lists-20895" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20897" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20899" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20902" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20904" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20905" href="../Lists/#plfa_plfa-part1-Lists-20905" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20909" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20911" href="../Lists/#plfa_plfa-part1-Lists-20895" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20913" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20915" href="../Lists/#plfa_plfa-part1-Lists-20895" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20917" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20919" href="../Lists/#plfa_plfa-part1-Lists-20895" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20920" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20922" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20923" href="../Lists/#plfa_plfa-part1-Lists-20923" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20925" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20927" href="../Lists/#plfa_plfa-part1-Lists-20895" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20928" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20930" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20932" href="../Lists/#plfa_plfa-part1-Lists-19176" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-20941" href="../Lists/#plfa_plfa-part1-Lists-20905" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20945" href="../Lists/#plfa_plfa-part1-Lists-20923" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20947" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-20951" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20953" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20954" href="../Lists/#plfa_plfa-part1-Lists-20954" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20957" href="../Lists/#plfa_plfa-part1-Lists-20957" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20960" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20962" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20967" href="../Lists/#plfa_plfa-part1-Lists-20895" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20968" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20970" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20972" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20978" href="../Lists/#plfa_plfa-part1-Lists-20905" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20982" href="../Lists/#plfa_plfa-part1-Lists-20923" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20984" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20985" href="../Lists/#plfa_plfa-part1-Lists-20954" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20988" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-20991" href="../Lists/#plfa_plfa-part1-Lists-20957" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20993" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20995" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20997" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21003" href="../Lists/#plfa_plfa-part1-Lists-20905" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21007" href="../Lists/#plfa_plfa-part1-Lists-20923" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21009" href="../Lists/#plfa_plfa-part1-Lists-20954" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21012" href="../Lists/#plfa_plfa-part1-Lists-20905" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-21014" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21020" href="../Lists/#plfa_plfa-part1-Lists-20905" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21024" href="../Lists/#plfa_plfa-part1-Lists-20923" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21026" href="../Lists/#plfa_plfa-part1-Lists-20957" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-21029" href="../Lists/#plfa_plfa-part1-Lists-20874" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-21045" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21049" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21051" href="../Lists/#plfa_plfa-part1-Lists-21051" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-21060" href="../Lists/#plfa_plfa-part1-Lists-21060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21063" href="../Lists/#plfa_plfa-part1-Lists-21063" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-21066" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-21070" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-21080" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21086" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21090" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21092" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21093" href="../Lists/#plfa_plfa-part1-Lists-21060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21096" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-21099" href="../Lists/#plfa_plfa-part1-Lists-21063" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21101" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-21105" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-21108" href="../Lists/#plfa_plfa-part1-Lists-17597" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-21117" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21121" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21123" href="../Lists/#plfa_plfa-part1-Lists-21060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21126" href="../Lists/#plfa_plfa-part1-Lists-21063" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-21129" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-21135" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21141" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21145" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21146" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21152" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21156" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21158" href="../Lists/#plfa_plfa-part1-Lists-21063" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21160" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21162" href="../Lists/#plfa_plfa-part1-Lists-21060" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-21167" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-21170" href="../Lists/#plfa_plfa-part1-Lists-20062" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-21183" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21187" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21189" href="../Lists/#plfa_plfa-part1-Lists-21051" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-21198" href="../Lists/#plfa_plfa-part1-Lists-21060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21201" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21202" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21208" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21212" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21214" href="../Lists/#plfa_plfa-part1-Lists-21063" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21216" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21218" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-21224" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21230" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21234" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21236" href="../Lists/#plfa_plfa-part1-Lists-21060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21239" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-21241" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21247" href="../Lists/#plfa_plfa-part1-Lists-21045" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21251" href="../Lists/#plfa_plfa-part1-Lists-21049" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21253" href="../Lists/#plfa_plfa-part1-Lists-21063" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-21258" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><h4 id="exercise-foldl-practice">Exercise <code>foldl</code> (practice)</h4><p>Define a function <code>foldl</code> which is analogous to <code>foldr</code>, but where operations associate to the left rather than the right. For example:</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21550" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr-monoid-foldl-practice">Exercise <code>foldr-monoid-foldl</code> (practice)</h4><p>Show that if <code>_⊗_</code> and <code>e</code> form a monoid, then <code>foldr _⊗_ e</code> and <code>foldl _⊗_ e</code> always compute the same result.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-21746" class="Comment">-- Your code goes here</a>
</pre><h2 id="All">All</h2><p>We can also define predicates over lists. Two of the most important are <code>All</code> and <code>Any</code>.</p>Predicate <code>All P</code> holds if predicate <code>P</code> is satisfied by every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-21970" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-21975" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21979" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21980" href="../Lists/#plfa_plfa-part1-Lists-21980" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21982" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21984" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-21987" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21989" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21990" href="../Lists/#plfa_plfa-part1-Lists-21990" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21992" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21994" href="../Lists/#plfa_plfa-part1-Lists-21980" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21996" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21998" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-22001" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22003" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22005" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-22010" href="../Lists/#plfa_plfa-part1-Lists-21980" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-22012" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22014" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-22018" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-22026" href="../Lists/#plfa_plfa-part1-Lists-22026" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-22030" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22032" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22036" href="../Lists/#plfa_plfa-part1-Lists-21990" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22038" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-22043" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-22047" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22049" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-22051" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-22052" href="../Lists/#plfa_plfa-part1-Lists-22052" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-22054" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22056" href="../Lists/#plfa_plfa-part1-Lists-21980" class="Bound">A</a><a id="plfa_plfa-part1-Lists-22057" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-22059" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-22060" href="../Lists/#plfa_plfa-part1-Lists-22060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-22063" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22065" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-22070" href="../Lists/#plfa_plfa-part1-Lists-21980" class="Bound">A</a><a id="plfa_plfa-part1-Lists-22071" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-22073" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22075" href="../Lists/#plfa_plfa-part1-Lists-21990" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22077" href="../Lists/#plfa_plfa-part1-Lists-22052" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-22079" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22081" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22085" href="../Lists/#plfa_plfa-part1-Lists-21990" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22087" href="../Lists/#plfa_plfa-part1-Lists-22060" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-22090" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22092" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22096" href="../Lists/#plfa_plfa-part1-Lists-21990" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22098" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22099" href="../Lists/#plfa_plfa-part1-Lists-22052" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-22101" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22103" href="../Lists/#plfa_plfa-part1-Lists-22060" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-22105" class="Symbol">)</a>
</pre><p>The type has two constructors, reusing the names of the same constructors for lists. The first asserts that <code>P</code> holds for every element of the empty list. The second asserts that if <code>P</code> holds of the head of a list and for every element of the tail of a list, then <code>P</code> holds for every element of the list. Agda uses types to disambiguate whether the constructor is building a list or evidence that <code>All P</code> holds.</p>For example, <code>All (_≤ 2)</code> holds of a list where every element is less than or equal to two. Recall that <code>z≤n</code> proves <code>zero ≤ n</code> for any <code>n</code>, and that if <code>m≤n</code> proves <code>m ≤ n</code> then <code>s≤s m≤n</code> proves <code>suc m ≤ suc n</code>, for any <code>m</code> and <code>n</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-22767" href="../Lists/#plfa_plfa-part1-Lists-22767" class="Function">_</a> <a id="plfa_plfa-part1-Lists-22769" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22771" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22775" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22776" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1691" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-22779" class="Number">2</a><a id="plfa_plfa-part1-Lists-22780" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22782" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-22784" class="Number">0</a> <a id="plfa_plfa-part1-Lists-22786" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22788" class="Number">1</a> <a id="plfa_plfa-part1-Lists-22790" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22792" class="Number">2</a> <a id="plfa_plfa-part1-Lists-22794" href="../Lists/#plfa_plfa-part1-Lists-3041" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-22796" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-22798" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-22800" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22804" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22806" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22810" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22814" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22816" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22820" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22821" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22825" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-22828" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22830" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22832" href="../Lists/#plfa_plfa-part1-Lists-22026" class="InductiveConstructor">[]</a>
</pre><p>Here <code>_∷_</code> and <code>[]</code> are the constructors of <code>All P</code> rather than of <code>List A</code>. The three items are proofs of <code>0 ≤ 2</code>, <code>1 ≤ 2</code>, and <code>2 ≤ 2</code>, respectively.</p><p>(One might wonder whether a pattern such as <code>[_,_,_]</code> can be used to construct values of type <code>All</code> as well as type <code>List</code>, since both use the same constructors. Indeed it can, so long as both types are in scope when the pattern is declared. That’s not the case here, since <code>List</code> is defined before <code>[_,_,_]</code>, but <code>All</code> is defined later.)</p><h2 id="any">Any</h2>Predicate <code>Any P</code> holds if predicate <code>P</code> is satisfied by some element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23431" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-23436" href="../Lists/#plfa_plfa-part1-Lists-23436" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23440" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23441" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23443" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23445" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23448" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23450" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23451" href="../Lists/#plfa_plfa-part1-Lists-23451" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23453" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23455" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23457" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23459" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23462" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23464" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23466" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23471" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23473" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23475" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-23479" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-23487" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-23493" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23495" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23497" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23498" href="../Lists/#plfa_plfa-part1-Lists-23498" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23500" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23502" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23503" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23505" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23506" href="../Lists/#plfa_plfa-part1-Lists-23506" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23509" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23511" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23516" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23517" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23519" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23521" href="../Lists/#plfa_plfa-part1-Lists-23451" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23523" href="../Lists/#plfa_plfa-part1-Lists-23498" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23525" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23527" href="../Lists/#plfa_plfa-part1-Lists-23436" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23531" href="../Lists/#plfa_plfa-part1-Lists-23451" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23533" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23534" href="../Lists/#plfa_plfa-part1-Lists-23498" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23536" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23538" href="../Lists/#plfa_plfa-part1-Lists-23506" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23540" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-23544" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-23550" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23552" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23554" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23555" href="../Lists/#plfa_plfa-part1-Lists-23555" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23557" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23559" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23560" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23562" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23563" href="../Lists/#plfa_plfa-part1-Lists-23563" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23566" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23568" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23573" href="../Lists/#plfa_plfa-part1-Lists-23441" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23574" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23576" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23578" href="../Lists/#plfa_plfa-part1-Lists-23436" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23582" href="../Lists/#plfa_plfa-part1-Lists-23451" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23584" href="../Lists/#plfa_plfa-part1-Lists-23563" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23587" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23589" href="../Lists/#plfa_plfa-part1-Lists-23436" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23593" href="../Lists/#plfa_plfa-part1-Lists-23451" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23595" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23596" href="../Lists/#plfa_plfa-part1-Lists-23555" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23598" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23600" href="../Lists/#plfa_plfa-part1-Lists-23563" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23602" class="Symbol">)</a>
</pre>The first constructor provides evidence that the head of the list satisfies <code>P</code>, while the second provides evidence that some element of the tail of the list satisfies <code>P</code>. For example, we can define list membership as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23845" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-23851" class="Number">4</a> <a id="plfa_plfa-part1-Lists-23853" href="../Lists/#plfa_plfa-part1-Lists-23862" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23857" href="../Lists/#plfa_plfa-part1-Lists-23932" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-23862" href="../Lists/#plfa_plfa-part1-Lists-23862" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23866" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23868" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23870" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23871" href="../Lists/#plfa_plfa-part1-Lists-23871" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23873" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23875" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23878" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23880" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23881" href="../Lists/#plfa_plfa-part1-Lists-23881" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23883" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23885" href="../Lists/#plfa_plfa-part1-Lists-23871" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23886" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23888" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23889" href="../Lists/#plfa_plfa-part1-Lists-23889" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23892" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23894" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23899" href="../Lists/#plfa_plfa-part1-Lists-23871" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23900" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23902" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23904" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23908" href="../Lists/#plfa_plfa-part1-Lists-23908" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23910" href="../Lists/#plfa_plfa-part1-Lists-23862" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23912" href="../Lists/#plfa_plfa-part1-Lists-23912" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23915" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23917" href="../Lists/#plfa_plfa-part1-Lists-23436" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23921" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23922" href="../Lists/#plfa_plfa-part1-Lists-23908" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23924" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-23926" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23928" href="../Lists/#plfa_plfa-part1-Lists-23912" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-23932" href="../Lists/#plfa_plfa-part1-Lists-23932" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-23936" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23938" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23940" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23941" href="../Lists/#plfa_plfa-part1-Lists-23941" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23943" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23945" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23948" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23950" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23951" href="../Lists/#plfa_plfa-part1-Lists-23951" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23953" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23955" href="../Lists/#plfa_plfa-part1-Lists-23941" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23956" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23958" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23959" href="../Lists/#plfa_plfa-part1-Lists-23959" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23962" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23964" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23969" href="../Lists/#plfa_plfa-part1-Lists-23941" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23970" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23972" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23974" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23978" href="../Lists/#plfa_plfa-part1-Lists-23978" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23980" href="../Lists/#plfa_plfa-part1-Lists-23932" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-23982" href="../Lists/#plfa_plfa-part1-Lists-23982" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23985" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23987" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-23989" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23990" href="../Lists/#plfa_plfa-part1-Lists-23978" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23992" href="../Lists/#plfa_plfa-part1-Lists-23862" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23994" href="../Lists/#plfa_plfa-part1-Lists-23982" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23996" class="Symbol">)</a>
</pre>For example, zero is an element of the list <code>[ 0 , 1 , 0 , 2 ]</code>. Indeed, we can demonstrate this fact in two different ways, corresponding to the two different occurrences of zero in the list, as the first element and as the third element:<pre class="Agda"><a id="plfa_plfa-part1-Lists-24251" href="../Lists/#plfa_plfa-part1-Lists-24251" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24253" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24255" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24257" href="../Lists/#plfa_plfa-part1-Lists-23862" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24259" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24261" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24263" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24265" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24267" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24269" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24271" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24273" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24275" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24277" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24279" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24281" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24286" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-24292" href="../Lists/#plfa_plfa-part1-Lists-24292" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24294" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24296" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24298" href="../Lists/#plfa_plfa-part1-Lists-23862" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24300" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24302" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24304" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24306" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24308" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24310" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24312" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24314" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24316" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24318" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24320" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24322" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24328" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24329" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24335" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24336" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24341" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-24345" class="Symbol">))</a>
</pre>Further, we can demonstrate that three is not in the list, because any possible proof that it is in the list leads to contradiction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-24493" href="../Lists/#plfa_plfa-part1-Lists-24493" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24500" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24502" class="Number">3</a> <a id="plfa_plfa-part1-Lists-24504" href="../Lists/#plfa_plfa-part1-Lists-23932" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-24506" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24508" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24510" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24512" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24514" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24516" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24518" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24520" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24522" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24524" href="../Lists/#plfa_plfa-part1-Lists-24493" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24531" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24532" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24537" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-24541" href="../Lists/#plfa_plfa-part1-Lists-24493" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24548" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24549" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24555" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24556" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24561" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-24566" href="../Lists/#plfa_plfa-part1-Lists-24493" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24573" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24574" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24580" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24581" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24587" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24588" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24593" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-24599" href="../Lists/#plfa_plfa-part1-Lists-24493" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24606" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24607" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24613" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24614" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24620" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24621" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24627" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24628" href="../Lists/#plfa_plfa-part1-Lists-23487" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24633" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-24640" href="../Lists/#plfa_plfa-part1-Lists-24493" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24647" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24648" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24654" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24655" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24661" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24662" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24668" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24669" href="../Lists/#plfa_plfa-part1-Lists-23544" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24675" class="Symbol">()))))</a>
</pre><p>The five occurrences of <code>()</code> attest to the fact that there is no possible evidence for <code>3 ≡ 0</code>, <code>3 ≡ 1</code>, <code>3 ≡ 0</code>, <code>3 ≡ 2</code>, and <code>3 ∈ []</code>, respectively.</p><h2 id="all-and-append">All and append</h2>A predicate holds for every element of one list appended to another if and only if it holds for every element of both lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-24990" href="../Lists/#plfa_plfa-part1-Lists-24990" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-24999" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25001" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25003" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25004" href="../Lists/#plfa_plfa-part1-Lists-25004" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25006" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25008" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25011" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25013" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25014" href="../Lists/#plfa_plfa-part1-Lists-25014" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25016" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25018" href="../Lists/#plfa_plfa-part1-Lists-25004" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25020" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25022" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25025" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25027" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25028" href="../Lists/#plfa_plfa-part1-Lists-25028" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25031" href="../Lists/#plfa_plfa-part1-Lists-25031" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25034" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25036" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25041" href="../Lists/#plfa_plfa-part1-Lists-25004" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25042" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25044" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25048" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25052" href="../Lists/#plfa_plfa-part1-Lists-25014" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25054" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25055" href="../Lists/#plfa_plfa-part1-Lists-25028" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25058" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25061" href="../Lists/#plfa_plfa-part1-Lists-25031" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25063" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25065" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12028" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-25067" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25068" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25072" href="../Lists/#plfa_plfa-part1-Lists-25014" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25074" href="../Lists/#plfa_plfa-part1-Lists-25028" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25077" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25079" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25083" href="../Lists/#plfa_plfa-part1-Lists-25014" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25085" href="../Lists/#plfa_plfa-part1-Lists-25031" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25087" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-25089" href="../Lists/#plfa_plfa-part1-Lists-24990" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-25098" href="../Lists/#plfa_plfa-part1-Lists-25098" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25101" href="../Lists/#plfa_plfa-part1-Lists-25101" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25104" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25108" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-25119" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25121" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12068" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-25130" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25133" href="../Lists/#plfa_plfa-part1-Lists-25188" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25136" href="../Lists/#plfa_plfa-part1-Lists-25098" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25139" href="../Lists/#plfa_plfa-part1-Lists-25101" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-25146" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25148" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12085" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-25157" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25160" href="../Lists/#plfa_plfa-part1-Lists-25413" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25165" href="../Lists/#plfa_plfa-part1-Lists-25098" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25168" href="../Lists/#plfa_plfa-part1-Lists-25101" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-25175" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-25179" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-25188" href="../Lists/#plfa_plfa-part1-Lists-25188" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25191" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25193" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25195" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25196" href="../Lists/#plfa_plfa-part1-Lists-25196" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25198" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25200" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25203" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25205" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25206" href="../Lists/#plfa_plfa-part1-Lists-25206" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25208" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25210" href="../Lists/#plfa_plfa-part1-Lists-25196" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25212" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25214" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25217" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25219" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25220" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25223" href="../Lists/#plfa_plfa-part1-Lists-25223" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25226" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25228" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25233" href="../Lists/#plfa_plfa-part1-Lists-25196" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25234" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25236" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25242" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25246" href="../Lists/#plfa_plfa-part1-Lists-25206" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25248" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25249" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25252" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25255" href="../Lists/#plfa_plfa-part1-Lists-25223" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25257" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25259" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25261" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25262" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25266" href="../Lists/#plfa_plfa-part1-Lists-25206" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25268" href="../Lists/#plfa_plfa-part1-Lists-25220" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25271" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25273" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25277" href="../Lists/#plfa_plfa-part1-Lists-25206" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25279" href="../Lists/#plfa_plfa-part1-Lists-25223" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25281" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25285" href="../Lists/#plfa_plfa-part1-Lists-25188" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25288" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25291" href="../Lists/#plfa_plfa-part1-Lists-25291" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25294" href="../Lists/#plfa_plfa-part1-Lists-25294" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25298" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25300" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25302" href="../Lists/#plfa_plfa-part1-Lists-22026" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25305" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25307" href="../Lists/#plfa_plfa-part1-Lists-25294" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25311" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-25315" href="../Lists/#plfa_plfa-part1-Lists-25188" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25318" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25319" href="../Lists/#plfa_plfa-part1-Lists-25319" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25321" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25323" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25325" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25327" href="../Lists/#plfa_plfa-part1-Lists-25327" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25330" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25331" href="../Lists/#plfa_plfa-part1-Lists-25331" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25334" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25336" href="../Lists/#plfa_plfa-part1-Lists-25336" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-25343" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25345" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-25350" href="../Lists/#plfa_plfa-part1-Lists-25188" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25353" href="../Lists/#plfa_plfa-part1-Lists-25323" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25356" href="../Lists/#plfa_plfa-part1-Lists-25327" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25359" href="../Lists/#plfa_plfa-part1-Lists-25336" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-25369" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-25373" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-25375" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25377" href="../Lists/#plfa_plfa-part1-Lists-25377" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25381" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25383" href="../Lists/#plfa_plfa-part1-Lists-25383" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25387" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25389" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25391" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25393" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25396" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25398" href="../Lists/#plfa_plfa-part1-Lists-25377" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25402" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25404" href="../Lists/#plfa_plfa-part1-Lists-25383" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25408" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-25413" href="../Lists/#plfa_plfa-part1-Lists-25413" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25418" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25420" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25422" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25424" href="../Lists/#plfa_plfa-part1-Lists-25424" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25426" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25428" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25431" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25433" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25434" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25436" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25438" href="../Lists/#plfa_plfa-part1-Lists-25424" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25440" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25442" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25445" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25447" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25448" href="../Lists/#plfa_plfa-part1-Lists-25448" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25451" href="../Lists/#plfa_plfa-part1-Lists-25451" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25454" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25456" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25461" href="../Lists/#plfa_plfa-part1-Lists-25424" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25462" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25464" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25470" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25474" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25476" href="../Lists/#plfa_plfa-part1-Lists-25448" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25479" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25481" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25485" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25487" href="../Lists/#plfa_plfa-part1-Lists-25451" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25490" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25492" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25496" href="../Lists/#plfa_plfa-part1-Lists-25434" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25498" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25499" href="../Lists/#plfa_plfa-part1-Lists-25448" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25502" href="../Lists/#plfa_plfa-part1-Lists-3631" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25505" href="../Lists/#plfa_plfa-part1-Lists-25451" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25507" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25511" href="../Lists/#plfa_plfa-part1-Lists-25413" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25516" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25519" href="../Lists/#plfa_plfa-part1-Lists-25519" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25522" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25524" href="../Lists/#plfa_plfa-part1-Lists-22026" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25527" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25529" href="../Lists/#plfa_plfa-part1-Lists-25529" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25533" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25535" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25537" href="../Lists/#plfa_plfa-part1-Lists-25529" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-25543" href="../Lists/#plfa_plfa-part1-Lists-25413" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25548" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25549" href="../Lists/#plfa_plfa-part1-Lists-25549" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25551" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25553" href="../Lists/#plfa_plfa-part1-Lists-25553" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25555" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25557" href="../Lists/#plfa_plfa-part1-Lists-25557" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25560" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25562" href="../Lists/#plfa_plfa-part1-Lists-25562" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25565" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25567" href="../Lists/#plfa_plfa-part1-Lists-25567" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25571" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25573" href="../Lists/#plfa_plfa-part1-Lists-25573" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25577" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25579" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25582" href="../Lists/#plfa_plfa-part1-Lists-25562" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25585" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25587" href="../Lists/#plfa_plfa-part1-Lists-25413" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25592" href="../Lists/#plfa_plfa-part1-Lists-25553" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25595" href="../Lists/#plfa_plfa-part1-Lists-25557" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25598" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25600" href="../Lists/#plfa_plfa-part1-Lists-25567" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25604" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25606" href="../Lists/#plfa_plfa-part1-Lists-25573" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25610" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="exercise-any---recommended">Exercise <code>Any-++-⇔</code> (recommended)</h4><p>Prove a result similar to <code>All-++-⇔</code>, but with <code>Any</code> in place of <code>All</code>, and a suitable replacement for <code>_×_</code>. As a consequence, demonstrate an equivalence relating <code>_∈_</code> and <code>_++_</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25849" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all---stretch">Exercise <code>All-++-≃</code> (stretch)</h4><p>Show that the equivalence <code>All-++-⇔</code> can be extended to an isomorphism.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25994" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-recommended">Exercise <code>¬Any⇔All¬</code> (recommended)</h4><p>Show that <code>Any</code> and <code>All</code> satisfy a version of De Morgan’s Law:</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>(Can you see why it is important that here <code>_∘_</code> is generalised to arbitrary levels, as described in the section on <a href="../Equality/#unipoly">universe polymorphism</a>?)</p><p>Do we also have the following?</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>If so, prove; if not, explain why.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26446" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-stretch">Exercise <code>¬Any≃All¬</code> (stretch)</h4><p>Show that the equivalence <code>¬Any⇔All¬</code> can be extended to an isomorphism. You will need to use extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26630" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all--practice">Exercise <code>All-∀</code> (practice)</h4><p>Show that <code>All P xs</code> is isomorphic to <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26761" class="Comment">-- You code goes here</a>
</pre><h4 id="exercise-any--practice">Exercise <code>Any-∃</code> (practice)</h4><p>Show that <code>Any P xs</code> is isomorphic to <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26895" class="Comment">-- You code goes here</a>
</pre><h2 id="decidability-of-all">Decidability of All</h2>If we consider a predicate as a function that yields a boolean, it is easy to define an analogue of <code>All</code>, which returns true if a given predicate returns true for every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-27144" href="../Lists/#plfa_plfa-part1-Lists-27144" class="Function">all</a> <a id="plfa_plfa-part1-Lists-27148" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27150" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27152" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27153" href="../Lists/#plfa_plfa-part1-Lists-27153" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27155" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27157" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27160" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27162" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27164" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27165" href="../Lists/#plfa_plfa-part1-Lists-27153" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27167" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27169" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-27173" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27175" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27177" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27182" href="../Lists/#plfa_plfa-part1-Lists-27153" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27184" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27186" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-27191" href="../Lists/#plfa_plfa-part1-Lists-27144" class="Function">all</a> <a id="plfa_plfa-part1-Lists-27195" href="../Lists/#plfa_plfa-part1-Lists-27195" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-27198" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27201" href="../Lists/#plfa_plfa-part1-Lists-15600" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-27207" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#995" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-27211" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-27216" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-27218" href="../Lists/#plfa_plfa-part1-Lists-13143" class="Function">map</a> <a id="plfa_plfa-part1-Lists-27222" href="../Lists/#plfa_plfa-part1-Lists-27195" class="Bound">p</a>
</pre><p>The function can be written in a particularly compact style by using the higher-order functions <code>map</code> and <code>foldr</code>.</p>As one would hope, if we replace booleans by decidables there is again an analogue of <code>All</code>. First, return to the notion of a predicate <code>P</code> as a function of type <code>A → Set</code>, taking a value <code>x</code> of type <code>A</code> into evidence <code>P x</code> that a property holds for <code>x</code>. Say that a predicate <code>P</code> is <em>decidable</em> if we have a function that for a given <code>x</code> can decide <code>P x</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-27710" href="../Lists/#plfa_plfa-part1-Lists-27710" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27720" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27722" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27724" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27725" href="../Lists/#plfa_plfa-part1-Lists-27725" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27727" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27729" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27732" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27734" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27736" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27737" href="../Lists/#plfa_plfa-part1-Lists-27725" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27739" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27741" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27744" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27746" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27748" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-27752" href="../Lists/#plfa_plfa-part1-Lists-27710" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27762" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27763" href="../Lists/#plfa_plfa-part1-Lists-27763" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27764" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27766" href="../Lists/#plfa_plfa-part1-Lists-27766" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-27769" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27772" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27774" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27775" href="../Lists/#plfa_plfa-part1-Lists-27775" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27777" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27779" href="../Lists/#plfa_plfa-part1-Lists-27763" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27780" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27782" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27784" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-27788" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27789" href="../Lists/#plfa_plfa-part1-Lists-27766" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27791" href="../Lists/#plfa_plfa-part1-Lists-27775" class="Bound">x</a><a id="plfa_plfa-part1-Lists-27792" class="Symbol">)</a>
</pre>Then if predicate <code>P</code> is decidable, it is also decidable whether every element of a list satisfies the predicate:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-27920" href="../Lists/#plfa_plfa-part1-Lists-27920" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27925" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27927" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27929" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27930" href="../Lists/#plfa_plfa-part1-Lists-27930" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27932" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27934" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27937" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27939" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27940" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27942" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27944" href="../Lists/#plfa_plfa-part1-Lists-27930" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27946" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27948" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27951" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27953" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27955" href="../Lists/#plfa_plfa-part1-Lists-27710" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27965" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27967" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27969" href="../Lists/#plfa_plfa-part1-Lists-27710" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27979" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27980" href="../Lists/#plfa_plfa-part1-Lists-21975" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27984" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Bound">P</a><a id="plfa_plfa-part1-Lists-27985" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-27987" href="../Lists/#plfa_plfa-part1-Lists-27920" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27992" href="../Lists/#plfa_plfa-part1-Lists-27992" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27995" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-28030" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28033" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28037" href="../Lists/#plfa_plfa-part1-Lists-22026" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-28040" href="../Lists/#plfa_plfa-part1-Lists-27920" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-28045" href="../Lists/#plfa_plfa-part1-Lists-28045" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28048" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28049" href="../Lists/#plfa_plfa-part1-Lists-28049" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28051" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28053" href="../Lists/#plfa_plfa-part1-Lists-28053" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-28055" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28057" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-28062" href="../Lists/#plfa_plfa-part1-Lists-28045" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28065" href="../Lists/#plfa_plfa-part1-Lists-28049" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-28069" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28071" href="../Lists/#plfa_plfa-part1-Lists-27920" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-28076" href="../Lists/#plfa_plfa-part1-Lists-28045" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28079" href="../Lists/#plfa_plfa-part1-Lists-28053" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-28082" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-28102" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28104" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28108" href="../Lists/#plfa_plfa-part1-Lists-28108" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28111" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28113" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28117" href="../Lists/#plfa_plfa-part1-Lists-28117" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-28125" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28128" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28132" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28133" href="../Lists/#plfa_plfa-part1-Lists-28108" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28136" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28138" href="../Lists/#plfa_plfa-part1-Lists-28117" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28141" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-28143" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-28163" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28165" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28168" href="../Lists/#plfa_plfa-part1-Lists-28168" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-28172" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28174" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-28186" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28189" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28192" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-28195" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28196" href="../Lists/#plfa_plfa-part1-Lists-28196" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28199" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28201" href="../Lists/#plfa_plfa-part1-Lists-28201" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28204" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28206" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28208" href="../Lists/#plfa_plfa-part1-Lists-28168" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-28212" href="../Lists/#plfa_plfa-part1-Lists-28196" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-28217" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-28219" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-28222" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-28239" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-28240" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28241" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-28242" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-28248" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-28249" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28250" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-28252" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28253" href="../Lists/#plfa_plfa-part1-Lists-28253" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-28262" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28265" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28268" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-28271" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28272" href="../Lists/#plfa_plfa-part1-Lists-28272" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28275" href="../Lists/#plfa_plfa-part1-Lists-22043" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28277" href="../Lists/#plfa_plfa-part1-Lists-28277" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28280" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28282" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28284" href="../Lists/#plfa_plfa-part1-Lists-28253" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-28289" href="../Lists/#plfa_plfa-part1-Lists-28277" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-28293" class="Symbol">}</a>
</pre><p>If the list is empty, then trivially <code>P</code> holds for every element of the list. Otherwise, the structure of the proof is similar to that showing that the conjunction of two decidable propositions is itself decidable, using <code>_∷_</code> rather than <code>⟨_,_⟩</code> to combine the evidence for the head and tail of the list.</p><h4 id="exercise-any-stretch">Exercise <code>Any?</code> (stretch)</h4><p>Just as <code>All</code> has analogues <code>all</code> and <code>All?</code> which determine whether a predicate holds for every element of a list, so does <code>Any</code> have analogues <code>any</code> and <code>Any?</code> which determine whether a predicate holds for some element of a list. Give their definitions.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28906" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-split-stretch">Exercise <code>split</code> (stretch)</h4>The relation <code>merge</code> holds when two lists merge to give a third list.<pre class="Agda"><a id="plfa_plfa-part1-Lists-29046" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-29051" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29057" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29058" href="../Lists/#plfa_plfa-part1-Lists-29058" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29060" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29062" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29065" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29067" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29069" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29070" href="../Lists/#plfa_plfa-part1-Lists-29070" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29073" href="../Lists/#plfa_plfa-part1-Lists-29073" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29076" href="../Lists/#plfa_plfa-part1-Lists-29076" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-29079" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29081" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29086" href="../Lists/#plfa_plfa-part1-Lists-29058" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29087" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29089" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29091" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-29095" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-29104" href="../Lists/#plfa_plfa-part1-Lists-29104" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-29107" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-29115" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-29136" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29142" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-29145" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-29148" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-29154" href="../Lists/#plfa_plfa-part1-Lists-29154" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29161" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29163" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29165" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29166" href="../Lists/#plfa_plfa-part1-Lists-29166" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29168" href="../Lists/#plfa_plfa-part1-Lists-29168" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29171" href="../Lists/#plfa_plfa-part1-Lists-29171" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29174" href="../Lists/#plfa_plfa-part1-Lists-29174" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29176" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-29182" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29184" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29190" href="../Lists/#plfa_plfa-part1-Lists-29168" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29193" href="../Lists/#plfa_plfa-part1-Lists-29171" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29196" href="../Lists/#plfa_plfa-part1-Lists-29174" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29205" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29236" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29238" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29244" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29245" href="../Lists/#plfa_plfa-part1-Lists-29166" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29247" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29249" href="../Lists/#plfa_plfa-part1-Lists-29168" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29251" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29253" href="../Lists/#plfa_plfa-part1-Lists-29171" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29256" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29257" href="../Lists/#plfa_plfa-part1-Lists-29166" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29259" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29261" href="../Lists/#plfa_plfa-part1-Lists-29174" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29263" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-29268" href="../Lists/#plfa_plfa-part1-Lists-29268" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29276" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29278" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29280" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29281" href="../Lists/#plfa_plfa-part1-Lists-29281" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29283" href="../Lists/#plfa_plfa-part1-Lists-29283" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29286" href="../Lists/#plfa_plfa-part1-Lists-29286" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29289" href="../Lists/#plfa_plfa-part1-Lists-29289" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29291" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-29297" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29299" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29305" href="../Lists/#plfa_plfa-part1-Lists-29283" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29308" href="../Lists/#plfa_plfa-part1-Lists-29286" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29311" href="../Lists/#plfa_plfa-part1-Lists-29289" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29320" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29351" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29353" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29359" href="../Lists/#plfa_plfa-part1-Lists-29283" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29362" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29363" href="../Lists/#plfa_plfa-part1-Lists-29281" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29365" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29367" href="../Lists/#plfa_plfa-part1-Lists-29286" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-29369" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29371" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29372" href="../Lists/#plfa_plfa-part1-Lists-29281" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29374" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29376" href="../Lists/#plfa_plfa-part1-Lists-29289" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29378" class="Symbol">)</a>
</pre>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-29406" href="../Lists/#plfa_plfa-part1-Lists-29406" class="Function">_</a> <a id="plfa_plfa-part1-Lists-29408" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29410" href="../Lists/#plfa_plfa-part1-Lists-29051" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29416" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29418" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29420" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29422" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29424" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29426" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29428" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29430" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29432" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29434" href="../Lists/#plfa_plfa-part1-Lists-3010" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29436" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29438" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29440" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29442" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29444" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29446" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29448" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29450" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29452" href="../Lists/#plfa_plfa-part1-Lists-3080" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-29454" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-29456" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-29458" href="../Lists/#plfa_plfa-part1-Lists-29154" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29465" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29466" href="../Lists/#plfa_plfa-part1-Lists-29268" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29474" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29475" href="../Lists/#plfa_plfa-part1-Lists-29268" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29483" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29484" href="../Lists/#plfa_plfa-part1-Lists-29154" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29491" href="../Lists/#plfa_plfa-part1-Lists-29104" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-29493" class="Symbol">)))</a>

</pre><p>Given a decidable predicate and a list, we can split the list into two lists that merge to give the original list, where all elements of one list satisfy the predicate, and all elements of the other do not satisfy the predicate.</p><p>Define the following variant of the traditional <code>filter</code> function on lists, which given a decidable predicate and a list returns a list of elements that satisfy the predicate and a list of elements that don’t, with their corresponding proofs.</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-30129" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard Library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Lists-30269" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30276" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-30286" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30292" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30293" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.List.html#147" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-30297" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30299" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#1734" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-30303" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30305" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#5044" class="Function">length</a><a id="plfa_plfa-part1-Lists-30311" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30313" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#7225" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-30320" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30322" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#1634" class="Function">map</a><a id="plfa_plfa-part1-Lists-30325" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30327" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#4148" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-30332" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30334" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#6728" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-30342" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30344" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30351" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-30380" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30386" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30387" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html#1639" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-30390" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30392" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html#1702" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-30394" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30396" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html#1719" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-30399" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30401" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30408" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-30437" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30443" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30444" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html#1148" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-30447" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30449" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html#1211" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-30453" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30455" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html#1264" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-30460" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30462" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30469" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-30504" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30510" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30511" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Membership.Setoid.html#925" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-30514" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30516" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30523" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-30546" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30552" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30553" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#58792" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-30571" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30573" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#58210" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-30584" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30586" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#58341" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-30600" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30602" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#22620" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-30610" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30612" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#22811" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-30624" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30626" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30633" href="https://agda.github.io/agda-stdlib/v2.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-30652" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30658" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30659" href="https://agda.github.io/agda-stdlib/v2.1/Algebra.Structures.html#4825" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-30667" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30669" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30676" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-30691" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30697" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30698" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Unary.html#4543" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30707" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30709" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30716" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-30732" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30738" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30739" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Definitions.html#6713" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30748" class="Symbol">)</a>
</pre><p>The standard library version of <code>IsMonoid</code> differs from the one given here, in that it is also parameterised on an equivalence relation.</p><p>Both <code>Relation.Unary</code> and <code>Relation.Binary</code> define a version of <code>Decidable</code>, one for unary relations (as used in this chapter where <code>P</code> ranges over unary predicates) and one for binary relations (as used earlier, where <code>_≤_</code> ranges over a binary relation).</p><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>