<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Lists: Lists and higher-order functions</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-92" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-99" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-116" class="Keyword">where</a>
</pre><p>This chapter discusses the list data type. It gives further examples of many of the techniques we have developed so far, and provides examples of polymorphic types and higher-order functions.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-341" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-348" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-386" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-389" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-392" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-397" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-400" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-406" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-407" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-410" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-412" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-416" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-418" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a><a id="plfa_plfa-part1-Lists-421" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-423" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1938" class="Function">trans</a><a id="plfa_plfa-part1-Lists-428" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-430" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a><a id="plfa_plfa-part1-Lists-434" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-436" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-441" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Properties.html#6731" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-456" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-461" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-468" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="plfa_plfa-part1-Lists-483" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-489" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-490" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-494" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-496" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-500" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-502" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-507" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-509" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#1348" class="Function">T</a><a id="plfa_plfa-part1-Lists-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-512" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#995" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-515" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-517" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-520" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-522" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#941" class="Function">not</a><a id="plfa_plfa-part1-Lists-525" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-527" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-532" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-539" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="plfa_plfa-part1-Lists-553" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-559" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-560" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-561" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-563" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-567" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-569" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-582" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-584" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#4456" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-587" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-589" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1691" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-592" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-594" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-597" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-599" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-602" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-604" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-609" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-616" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-636" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-644" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-645" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15113" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-652" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-654" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15214" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-665" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-667" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15269" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-678" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-680" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#22674" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-687" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-689" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21574" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-700" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-702" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21638" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-713" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-715" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#22188" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-727" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-729" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-734" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-741" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-758" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-764" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-765" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-767" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-769" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-772" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-774" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-777" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-779" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-781" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-783" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-788" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-795" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="plfa_plfa-part1-Lists-813" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-819" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-820" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-823" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-825" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#852" class="Function">∃</a><a id="plfa_plfa-part1-Lists-826" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-828" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1371" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-836" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-838" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-847" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-848" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-852" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-860" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-862" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-867" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-874" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html" class="Module">Function.Base</a> <a id="plfa_plfa-part1-Lists-888" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-894" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-895" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html#1115" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-898" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-900" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-905" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-912" href="https://agda.github.io/agda-stdlib/v2.1/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-918" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-924" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-925" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#742" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-930" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-932" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-937" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-944" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-967" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-973" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-974" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4308" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-977" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-979" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12028" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-982" class="Symbol">)</a>
</pre><h2 id="lists">Lists</h2>Lists are defined in Agda as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-1046" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1051" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1056" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1057" href="../Lists/#plfa_plfa-part1-Lists-1057" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1059" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1061" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1064" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1066" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1068" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1072" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1080" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1084" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1086" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1091" href="../Lists/#plfa_plfa-part1-Lists-1057" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1095" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1099" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1101" href="../Lists/#plfa_plfa-part1-Lists-1057" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1103" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1105" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1110" href="../Lists/#plfa_plfa-part1-Lists-1057" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1112" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1114" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1119" href="../Lists/#plfa_plfa-part1-Lists-1057" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1122" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1129" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1131" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">_∷_</a>
</pre><p>Let’s unpack this definition. If <code>A</code> is a set, then <code>List A</code> is a set. The next two lines tell us that <code>[]</code> (pronounced <em>nil</em>) is a list of type <code>A</code> (often called the <em>empty</em> list), and that <code>_∷_</code> (pronounced <em>cons</em>, short for <em>constructor</em>) takes a value of type <code>A</code> and a value of type <code>List A</code> and returns a value of type <code>List A</code>. Operator <code>_∷_</code> has precedence level 5 and associates to the right.</p>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-1564" href="../Lists/#plfa_plfa-part1-Lists-1564" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1566" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1568" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1573" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1575" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1577" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1579" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1581" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1583" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1585" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1587" class="Number">2</a> <a id="plfa_plfa-part1-Lists-1589" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1591" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
</pre><p>denotes the list of the first three natural numbers. Since <code>_∷_</code> associates to the right, the term parses as <code>0 ∷ (1 ∷ (2 ∷ []))</code>. Here <code>0</code> is the first element of the list, called the <em>head</em>, and <code>1 ∷ (2 ∷ [])</code> is a list of the remaining elements, called the <em>tail</em>. A list is a strange beast: it has a head and a tail, nothing in between, and the tail is itself another list!</p>As we’ve seen, some parameterised types can be translated to indexed types. The definition above translates to the following:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2112" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2117" href="../Lists/#plfa_plfa-part1-Lists-2117" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2123" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2125" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2129" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2131" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set₁</a> <a id="plfa_plfa-part1-Lists-2136" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2144" href="../Lists/#plfa_plfa-part1-Lists-2144" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2149" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2151" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2153" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2154" href="../Lists/#plfa_plfa-part1-Lists-2154" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2156" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2158" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2161" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2163" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2165" href="../Lists/#plfa_plfa-part1-Lists-2117" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2171" href="../Lists/#plfa_plfa-part1-Lists-2154" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2175" href="../Lists/#plfa_plfa-part1-Lists-2175" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2180" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2182" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2184" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2185" href="../Lists/#plfa_plfa-part1-Lists-2185" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2187" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2189" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2192" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2194" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2196" href="../Lists/#plfa_plfa-part1-Lists-2185" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2198" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2200" href="../Lists/#plfa_plfa-part1-Lists-2117" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2206" href="../Lists/#plfa_plfa-part1-Lists-2185" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2208" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2210" href="../Lists/#plfa_plfa-part1-Lists-2117" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2216" href="../Lists/#plfa_plfa-part1-Lists-2185" class="Bound">A</a>
</pre><p>This is almost equivalent, save that with parametrised types the result can be in <code>Set</code>, whereas for technical reasons indexed types require the result to be <code>Set₁</code>.</p>Each constructor of <code>List</code> takes the parameter as an implicit argument. Thus, our example list could also be written:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2515" href="../Lists/#plfa_plfa-part1-Lists-2515" class="Function">_</a> <a id="plfa_plfa-part1-Lists-2517" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2519" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-2524" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-2526" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-2528" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2530" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2534" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2535" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2536" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2538" class="Number">0</a> <a id="plfa_plfa-part1-Lists-2540" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2541" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2545" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2546" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2547" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2549" class="Number">1</a> <a id="plfa_plfa-part1-Lists-2551" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2552" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2556" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2557" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2558" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2560" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2562" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2563" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-2566" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2567" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2568" class="Symbol">})))</a>
</pre><p>where here we have provided the implicit parameters explicitly.</p><p>Including the pragma:</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>tells Agda that the type <code>List</code> corresponds to the Haskell type list, and the constructors <code>[]</code> and <code>_∷_</code> correspond to nil and cons respectively, allowing a more efficient representation of lists.</p><h2 id="list-syntax">List syntax</h2>We can write lists more conveniently by introducing the following definitions:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2999" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-3007" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-3011" href="../Lists/#plfa_plfa-part1-Lists-3015" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3013" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3015" href="../Lists/#plfa_plfa-part1-Lists-3015" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3017" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3019" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3022" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-3030" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-3036" href="../Lists/#plfa_plfa-part1-Lists-3042" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3038" href="../Lists/#plfa_plfa-part1-Lists-3046" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3040" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3042" href="../Lists/#plfa_plfa-part1-Lists-3042" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3044" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3046" href="../Lists/#plfa_plfa-part1-Lists-3046" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3048" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3050" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3053" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-3061" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-3069" href="../Lists/#plfa_plfa-part1-Lists-3077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3071" href="../Lists/#plfa_plfa-part1-Lists-3081" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3073" href="../Lists/#plfa_plfa-part1-Lists-3085" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3075" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3077" href="../Lists/#plfa_plfa-part1-Lists-3077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3079" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3081" href="../Lists/#plfa_plfa-part1-Lists-3081" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3083" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3085" href="../Lists/#plfa_plfa-part1-Lists-3085" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3087" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3089" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3092" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3100" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3110" href="../Lists/#plfa_plfa-part1-Lists-3120" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3112" href="../Lists/#plfa_plfa-part1-Lists-3124" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3114" href="../Lists/#plfa_plfa-part1-Lists-3128" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3116" href="../Lists/#plfa_plfa-part1-Lists-3132" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3118" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3120" href="../Lists/#plfa_plfa-part1-Lists-3120" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3122" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3124" href="../Lists/#plfa_plfa-part1-Lists-3124" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3126" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3128" href="../Lists/#plfa_plfa-part1-Lists-3128" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3130" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3132" href="../Lists/#plfa_plfa-part1-Lists-3132" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3134" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3136" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3139" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3147" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3159" href="../Lists/#plfa_plfa-part1-Lists-3171" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3161" href="../Lists/#plfa_plfa-part1-Lists-3175" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3163" href="../Lists/#plfa_plfa-part1-Lists-3179" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3165" href="../Lists/#plfa_plfa-part1-Lists-3183" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3167" href="../Lists/#plfa_plfa-part1-Lists-3187" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3169" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3171" href="../Lists/#plfa_plfa-part1-Lists-3171" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3173" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3175" href="../Lists/#plfa_plfa-part1-Lists-3175" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3177" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3179" href="../Lists/#plfa_plfa-part1-Lists-3179" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3181" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3183" href="../Lists/#plfa_plfa-part1-Lists-3183" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3185" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3187" href="../Lists/#plfa_plfa-part1-Lists-3187" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3189" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3191" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-3194" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3202" href="../Lists/#plfa_plfa-part1-Lists-3202" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3216" href="../Lists/#plfa_plfa-part1-Lists-3230" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3218" href="../Lists/#plfa_plfa-part1-Lists-3234" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3220" href="../Lists/#plfa_plfa-part1-Lists-3238" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3222" href="../Lists/#plfa_plfa-part1-Lists-3242" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3224" href="../Lists/#plfa_plfa-part1-Lists-3246" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3226" href="../Lists/#plfa_plfa-part1-Lists-3250" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3228" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3230" href="../Lists/#plfa_plfa-part1-Lists-3230" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3232" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3234" href="../Lists/#plfa_plfa-part1-Lists-3234" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3236" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3238" href="../Lists/#plfa_plfa-part1-Lists-3238" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3240" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3242" href="../Lists/#plfa_plfa-part1-Lists-3242" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3244" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3246" href="../Lists/#plfa_plfa-part1-Lists-3246" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3248" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3250" href="../Lists/#plfa_plfa-part1-Lists-3250" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3252" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3254" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
</pre><p>This is our first use of pattern declarations. For instance, the third line tells us that <code>[ x , y , z ]</code> is equivalent to <code>x ∷ y ∷ z ∷ []</code>, and permits the former to appear either in a pattern on the left-hand side of an equation, or a term on the right-hand side of an equation.</p><h2 id="append">Append</h2><p>Our first function on lists is written <code>_++_</code> and pronounced <em>append</em>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3636" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-3643" class="Number">5</a> <a id="plfa_plfa-part1-Lists-3645" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-3651" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-3656" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3658" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-3660" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3661" href="../Lists/#plfa_plfa-part1-Lists-3661" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3663" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3665" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-3668" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3670" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3672" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3677" href="../Lists/#plfa_plfa-part1-Lists-3661" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3679" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3681" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3686" href="../Lists/#plfa_plfa-part1-Lists-3661" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3688" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3690" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3695" href="../Lists/#plfa_plfa-part1-Lists-3661" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-3697" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-3706" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3709" href="../Lists/#plfa_plfa-part1-Lists-3709" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3713" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3716" href="../Lists/#plfa_plfa-part1-Lists-3709" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-3719" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3720" href="../Lists/#plfa_plfa-part1-Lists-3720" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3722" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3724" href="../Lists/#plfa_plfa-part1-Lists-3724" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-3726" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-3728" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3731" href="../Lists/#plfa_plfa-part1-Lists-3731" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3735" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3738" href="../Lists/#plfa_plfa-part1-Lists-3720" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3740" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3742" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3743" href="../Lists/#plfa_plfa-part1-Lists-3724" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-3746" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3749" href="../Lists/#plfa_plfa-part1-Lists-3731" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-3751" class="Symbol">)</a>
</pre><p>The type <code>A</code> is an implicit argument to append, making it a <em>polymorphic</em> function (one that can be used at many types). A list appended to the empty list yields the list itself. A list appended to a non-empty list yields a list with the head the same as the head of the non-empty list, and a tail the same as the other list appended to tail of the non-empty list.</p>Here is an example, showing how to compute the result of appending two lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-4209" href="../Lists/#plfa_plfa-part1-Lists-4209" class="Function">_</a> <a id="plfa_plfa-part1-Lists-4211" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4213" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4215" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4217" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4219" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4221" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4223" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4225" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4227" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4230" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4232" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4234" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4236" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4238" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4240" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4242" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4244" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4246" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4248" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4250" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4252" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4254" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4256" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4258" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4260" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4262" href="../Lists/#plfa_plfa-part1-Lists-3147" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-4264" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-4266" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4270" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4280" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4282" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4284" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4286" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4288" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4290" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4292" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4295" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4298" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4300" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4302" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4304" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4306" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4311" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4319" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4321" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4323" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4324" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4326" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4328" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4330" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4332" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4335" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4338" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4340" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4342" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4344" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4346" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4348" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4352" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4360" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4362" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4364" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4366" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4368" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4369" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4371" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4373" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4376" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4379" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4381" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4383" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4385" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4387" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4389" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4393" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4401" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4403" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4405" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4407" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4409" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4411" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4413" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4414" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4417" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4420" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4422" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4424" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4426" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4428" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4430" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4434" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4442" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4444" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4446" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4448" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4450" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4452" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4454" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4456" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4458" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4460" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4462" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4467" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Appending two lists requires time linear in the number of elements in the first list.</p><h2 id="reasoning-about-append">Reasoning about append</h2>We can reason about lists in much the same way that we reason about numbers. Here is the proof that append is associative:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-4720" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4729" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4731" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4733" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4734" href="../Lists/#plfa_plfa-part1-Lists-4734" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4736" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4738" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4741" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4743" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4744" href="../Lists/#plfa_plfa-part1-Lists-4744" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4747" href="../Lists/#plfa_plfa-part1-Lists-4747" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4750" href="../Lists/#plfa_plfa-part1-Lists-4750" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4753" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4755" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4760" href="../Lists/#plfa_plfa-part1-Lists-4734" class="Bound">A</a><a id="plfa_plfa-part1-Lists-4761" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4765" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4767" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4768" href="../Lists/#plfa_plfa-part1-Lists-4744" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4771" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4774" href="../Lists/#plfa_plfa-part1-Lists-4747" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4776" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4778" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4781" href="../Lists/#plfa_plfa-part1-Lists-4750" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4784" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4786" href="../Lists/#plfa_plfa-part1-Lists-4744" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4789" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4792" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4793" href="../Lists/#plfa_plfa-part1-Lists-4747" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4796" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4799" href="../Lists/#plfa_plfa-part1-Lists-4750" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4801" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-4803" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4812" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4815" href="../Lists/#plfa_plfa-part1-Lists-4815" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4818" href="../Lists/#plfa_plfa-part1-Lists-4818" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4821" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4825" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4835" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4836" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4839" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4842" href="../Lists/#plfa_plfa-part1-Lists-4815" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4844" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4846" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4849" href="../Lists/#plfa_plfa-part1-Lists-4818" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4854" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4862" href="../Lists/#plfa_plfa-part1-Lists-4815" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4865" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4868" href="../Lists/#plfa_plfa-part1-Lists-4818" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4873" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4881" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4884" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4887" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4888" href="../Lists/#plfa_plfa-part1-Lists-4815" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4891" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4894" href="../Lists/#plfa_plfa-part1-Lists-4818" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4896" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4900" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-4902" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4911" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4912" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4914" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4916" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4918" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4920" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4923" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4926" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4930" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4940" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4941" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4943" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4945" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4948" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4951" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4953" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4955" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4958" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4963" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4971" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4973" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4975" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4976" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4979" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4982" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4984" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4986" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4989" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4994" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5002" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5004" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5006" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-5008" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5011" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5014" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-5016" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5018" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5021" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5023" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5027" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-5030" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-5035" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5036" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5038" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-5040" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5042" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5043" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-5052" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5055" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5058" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5060" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5062" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-5068" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5070" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5072" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5073" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5076" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5079" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5080" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5083" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5086" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5088" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-5093" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5101" href="../Lists/#plfa_plfa-part1-Lists-4912" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-5103" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-5105" href="../Lists/#plfa_plfa-part1-Lists-4916" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5108" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5111" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5112" href="../Lists/#plfa_plfa-part1-Lists-4920" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-5115" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5118" href="../Lists/#plfa_plfa-part1-Lists-4923" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-5120" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-5124" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>++-assoc xs ys zs</code>.</p><p>Recall that Agda supports <a href="../Induction/#sections">sections</a>. Applying <code>cong (x ∷_)</code> promotes the inductive hypothesis:</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>to the equality:</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>which is needed in the proof.</p>It is also easy to show that <code>[]</code> is a left and right identity for <code>_++_</code>. That it is a left identity is immediate from the definition:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-5917" href="../Lists/#plfa_plfa-part1-Lists-5917" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5930" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5932" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5934" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5935" href="../Lists/#plfa_plfa-part1-Lists-5935" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5937" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5939" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5942" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5944" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5945" href="../Lists/#plfa_plfa-part1-Lists-5945" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5948" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5950" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5955" href="../Lists/#plfa_plfa-part1-Lists-5935" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5956" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5958" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5960" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5963" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5966" href="../Lists/#plfa_plfa-part1-Lists-5945" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5969" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5971" href="../Lists/#plfa_plfa-part1-Lists-5945" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-5974" href="../Lists/#plfa_plfa-part1-Lists-5917" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5987" href="../Lists/#plfa_plfa-part1-Lists-5987" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5990" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5994" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6004" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6007" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6010" href="../Lists/#plfa_plfa-part1-Lists-5987" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6015" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6023" href="../Lists/#plfa_plfa-part1-Lists-5987" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6028" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre>That it is a right identity follows by simple induction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-6099" href="../Lists/#plfa_plfa-part1-Lists-6099" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6112" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6114" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6116" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6117" href="../Lists/#plfa_plfa-part1-Lists-6117" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6119" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6121" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6124" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6126" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6127" href="../Lists/#plfa_plfa-part1-Lists-6127" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6130" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6132" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6137" href="../Lists/#plfa_plfa-part1-Lists-6117" class="Bound">A</a><a id="plfa_plfa-part1-Lists-6138" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6140" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6142" href="../Lists/#plfa_plfa-part1-Lists-6127" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6145" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6148" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6151" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6153" href="../Lists/#plfa_plfa-part1-Lists-6127" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-6156" href="../Lists/#plfa_plfa-part1-Lists-6099" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6169" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6172" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6176" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6186" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-6189" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6192" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6197" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6205" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6210" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6212" href="../Lists/#plfa_plfa-part1-Lists-6099" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6225" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6226" href="../Lists/#plfa_plfa-part1-Lists-6226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6228" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6230" href="../Lists/#plfa_plfa-part1-Lists-6230" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6232" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6234" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6238" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6248" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6249" href="../Lists/#plfa_plfa-part1-Lists-6226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6251" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6253" href="../Lists/#plfa_plfa-part1-Lists-6230" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6255" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6257" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6260" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6265" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6273" href="../Lists/#plfa_plfa-part1-Lists-6226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6275" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6277" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6278" href="../Lists/#plfa_plfa-part1-Lists-6230" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6281" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6284" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6286" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6290" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6293" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6298" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6299" href="../Lists/#plfa_plfa-part1-Lists-6226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6301" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6303" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6305" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6306" href="../Lists/#plfa_plfa-part1-Lists-6099" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6319" href="../Lists/#plfa_plfa-part1-Lists-6230" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6321" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6323" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6329" href="../Lists/#plfa_plfa-part1-Lists-6226" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6331" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6333" href="../Lists/#plfa_plfa-part1-Lists-6230" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6338" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>As we will see later, these three properties establish that <code>_++_</code> and <code>[]</code> form a <em>monoid</em> over lists.</p><h2 id="length">Length</h2>Our next function finds the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-6514" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6521" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6523" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6525" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6526" href="../Lists/#plfa_plfa-part1-Lists-6526" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6528" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6530" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6533" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6535" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6537" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6542" href="../Lists/#plfa_plfa-part1-Lists-6526" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6544" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6546" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-6548" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6555" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-6565" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6568" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-6573" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6580" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6581" href="../Lists/#plfa_plfa-part1-Lists-6581" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6583" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6585" href="../Lists/#plfa_plfa-part1-Lists-6585" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6587" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-6590" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6593" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6597" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6598" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6605" href="../Lists/#plfa_plfa-part1-Lists-6585" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6607" class="Symbol">)</a>
</pre><p>Again, it takes an implicit parameter <code>A</code>. The length of the empty list is zero. The length of a non-empty list is one greater than the length of the tail of the list.</p>Here is an example showing how to compute the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-6854" href="../Lists/#plfa_plfa-part1-Lists-6854" class="Function">_</a> <a id="plfa_plfa-part1-Lists-6856" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6858" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6865" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-6867" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6869" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6871" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6873" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6875" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6877" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-6879" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6881" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-6883" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-6885" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6889" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6899" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6906" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6907" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6909" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6911" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6913" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6915" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6917" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6919" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6921" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6925" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6933" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6937" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6938" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6945" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6946" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6948" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6950" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6952" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6954" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6956" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6961" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6969" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6973" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6974" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6978" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6979" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6986" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6987" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6989" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6991" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6993" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-6999" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7007" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7011" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7012" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7016" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7017" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7021" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7022" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7029" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7030" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-7031" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7033" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-7035" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-7041" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7049" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7053" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7054" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7058" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7059" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7063" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-7067" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-7072" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Computing the length of a list requires time linear in the number of elements in the list.</p><p>In the second-to-last line, we cannot write simply <code>length []</code> but must instead write <code>length {ℕ} []</code>. Since <code>[]</code> has no elements, Agda has insufficient information to infer the implicit parameter.</p><h2 id="reasoning-about-length">Reasoning about length</h2>The length of one list appended to another is the sum of the lengths of the lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-7489" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7499" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7501" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7503" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7504" href="../Lists/#plfa_plfa-part1-Lists-7504" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7506" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7508" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7511" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7513" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7514" href="../Lists/#plfa_plfa-part1-Lists-7514" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7517" href="../Lists/#plfa_plfa-part1-Lists-7517" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7520" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7522" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7527" href="../Lists/#plfa_plfa-part1-Lists-7504" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7528" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7532" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7534" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7541" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7542" href="../Lists/#plfa_plfa-part1-Lists-7514" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7545" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7548" href="../Lists/#plfa_plfa-part1-Lists-7517" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7550" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7552" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7554" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7561" href="../Lists/#plfa_plfa-part1-Lists-7514" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7564" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7566" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7573" href="../Lists/#plfa_plfa-part1-Lists-7517" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-7576" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7586" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7587" href="../Lists/#plfa_plfa-part1-Lists-7587" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7588" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7590" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7593" href="../Lists/#plfa_plfa-part1-Lists-7593" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7596" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7600" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7610" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7617" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7618" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7621" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7624" href="../Lists/#plfa_plfa-part1-Lists-7593" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7626" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7630" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7638" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7645" href="../Lists/#plfa_plfa-part1-Lists-7593" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7650" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7658" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7665" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7666" href="../Lists/#plfa_plfa-part1-Lists-7587" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7667" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7669" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7672" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7674" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7681" href="../Lists/#plfa_plfa-part1-Lists-7593" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7686" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7688" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7698" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7699" href="../Lists/#plfa_plfa-part1-Lists-7699" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7701" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7703" href="../Lists/#plfa_plfa-part1-Lists-7703" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7705" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7707" href="../Lists/#plfa_plfa-part1-Lists-7707" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7710" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7714" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7724" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7731" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-7733" href="../Lists/#plfa_plfa-part1-Lists-7699" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7735" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7737" href="../Lists/#plfa_plfa-part1-Lists-7703" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7739" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7741" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7744" href="../Lists/#plfa_plfa-part1-Lists-7707" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7746" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7750" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7758" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7762" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7763" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7770" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7771" href="../Lists/#plfa_plfa-part1-Lists-7703" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7774" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7777" href="../Lists/#plfa_plfa-part1-Lists-7707" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7779" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-7784" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7787" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7792" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7796" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7797" href="../Lists/#plfa_plfa-part1-Lists-7489" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7807" href="../Lists/#plfa_plfa-part1-Lists-7703" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7810" href="../Lists/#plfa_plfa-part1-Lists-7707" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7812" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7814" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7820" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7824" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7825" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7832" href="../Lists/#plfa_plfa-part1-Lists-7703" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7835" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7837" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7844" href="../Lists/#plfa_plfa-part1-Lists-7707" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7846" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7850" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7858" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7865" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7866" href="../Lists/#plfa_plfa-part1-Lists-7699" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7868" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7870" href="../Lists/#plfa_plfa-part1-Lists-7703" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7872" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7874" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7876" href="../Lists/#plfa_plfa-part1-Lists-6514" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7883" href="../Lists/#plfa_plfa-part1-Lists-7707" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7888" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. As before, Agda cannot infer the implicit type parameter to <code>length</code>, and it must be given explicitly. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>length-++ xs ys</code>, and it is promoted by the congruence <code>cong suc</code>.</p><h2 id="reverse">Reverse</h2>Using append, it is easy to formulate a function to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-8516" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8524" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8526" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8528" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8529" href="../Lists/#plfa_plfa-part1-Lists-8529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8531" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8533" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8536" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8538" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8540" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8545" href="../Lists/#plfa_plfa-part1-Lists-8529" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8547" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8549" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8554" href="../Lists/#plfa_plfa-part1-Lists-8529" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-8556" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8564" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8574" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8577" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-8580" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8588" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8589" href="../Lists/#plfa_plfa-part1-Lists-8589" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8591" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8593" href="../Lists/#plfa_plfa-part1-Lists-8593" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8595" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8598" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8601" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8609" href="../Lists/#plfa_plfa-part1-Lists-8593" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-8612" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8615" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8617" href="../Lists/#plfa_plfa-part1-Lists-8589" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8619" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a>
</pre><p>The reverse of the empty list is the empty list. The reverse of a non-empty list is the reverse of its tail appended to a unit list containing its head.</p>Here is an example showing how to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-8837" href="../Lists/#plfa_plfa-part1-Lists-8837" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8839" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8841" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8849" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8851" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8853" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8855" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8857" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8859" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8861" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8863" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8865" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8867" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8869" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8871" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8873" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8875" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8877" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-8879" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8881" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8885" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8895" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8903" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8904" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8906" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8908" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8910" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8912" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8914" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8916" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8918" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8922" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8930" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8938" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8939" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8941" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8943" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8945" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8947" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8949" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8951" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8954" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8956" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8958" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8962" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8970" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8971" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8979" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8980" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8982" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8984" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8986" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8988" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8991" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8993" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8995" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8996" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8998" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9001" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9003" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9005" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9009" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9017" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9019" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-9027" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9030" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9033" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9035" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9037" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9038" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9040" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9043" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9045" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9047" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9048" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9050" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9053" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9055" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9057" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9061" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9069" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9071" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9074" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9077" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9079" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9081" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9082" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9084" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9087" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9089" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9091" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-9092" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9094" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9097" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9099" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9101" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9105" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9113" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-9115" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9118" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9121" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9123" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9125" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9127" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9129" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9132" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9134" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9136" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9138" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9140" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9143" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9145" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9147" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9152" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9160" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9161" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9163" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9165" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9168" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9171" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9173" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9175" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9177" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9179" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9182" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9184" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9186" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9191" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9199" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9201" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9203" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9204" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9207" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9210" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9212" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9214" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9216" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9218" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9221" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9223" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9225" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9230" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9238" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9239" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9241" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9243" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9245" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9247" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9249" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9251" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9254" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9256" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9258" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9263" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9271" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9273" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9275" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9276" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9278" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9280" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9283" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9286" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9288" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9290" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9292" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9296" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9304" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9306" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9308" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9310" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9312" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9313" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9316" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9319" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9321" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9323" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9325" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9329" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9337" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9339" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9341" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9343" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9345" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9347" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9349" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9354" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9362" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9364" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9366" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9368" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9370" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9372" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9374" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9378" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Reversing a list in this way takes time <em>quadratic</em> in the length of the list. This is because reverse ends up appending lists of lengths <code>1</code>, <code>2</code>, up to <code>n - 1</code>, where <code>n</code> is the length of the list being reversed, append takes time linear in the length of the first list, and the sum of the numbers up to <code>n - 1</code> is <code>n * (n - 1) / 2</code>. (We will validate that last fact in an exercise later in this chapter.)</p><h4 id="exercise-reverse--distrib-recommended">Exercise <code>reverse-++-distrib</code> (recommended)</h4><p>Show that the reverse of one list appended to another is the reverse of the second appended to the reverse of the first:</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-10024" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-reverse-involutive-recommended">Exercise <code>reverse-involutive</code> (recommended)</h4><p>A function is an <em>involution</em> if when applied twice it acts as the identity function. Show that reverse is an involution:</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-10266" class="Comment">-- Your code goes here</a>
</pre><h2 id="faster-reverse">Faster reverse</h2>The definition above, while easy to reason about, is less efficient than one might expect since it takes time quadratic in the length of the list. The idea is that we generalise reverse to take an additional argument:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-10540" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10546" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10548" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10550" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10551" href="../Lists/#plfa_plfa-part1-Lists-10551" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10553" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10555" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10558" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10560" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10562" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10567" href="../Lists/#plfa_plfa-part1-Lists-10551" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10569" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10571" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10576" href="../Lists/#plfa_plfa-part1-Lists-10551" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10578" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10580" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10585" href="../Lists/#plfa_plfa-part1-Lists-10551" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10587" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10593" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-10602" href="../Lists/#plfa_plfa-part1-Lists-10602" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10606" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10609" href="../Lists/#plfa_plfa-part1-Lists-10602" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10612" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10618" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10619" href="../Lists/#plfa_plfa-part1-Lists-10619" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10621" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10623" href="../Lists/#plfa_plfa-part1-Lists-10623" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10625" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10627" href="../Lists/#plfa_plfa-part1-Lists-10627" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10631" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10634" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10640" href="../Lists/#plfa_plfa-part1-Lists-10623" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10643" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10644" href="../Lists/#plfa_plfa-part1-Lists-10619" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10646" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10648" href="../Lists/#plfa_plfa-part1-Lists-10627" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10650" class="Symbol">)</a>
</pre><p>The definition is by recursion on the first argument. The second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we recurse becomes <em>smaller</em>.</p>Shunt is related to reverse as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-10892" href="../Lists/#plfa_plfa-part1-Lists-10892" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10906" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10908" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10910" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10911" href="../Lists/#plfa_plfa-part1-Lists-10911" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10913" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10915" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10918" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10920" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10921" href="../Lists/#plfa_plfa-part1-Lists-10921" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10924" href="../Lists/#plfa_plfa-part1-Lists-10924" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10927" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10929" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10934" href="../Lists/#plfa_plfa-part1-Lists-10911" class="Bound">A</a><a id="plfa_plfa-part1-Lists-10935" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10939" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10941" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10947" href="../Lists/#plfa_plfa-part1-Lists-10921" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10950" href="../Lists/#plfa_plfa-part1-Lists-10924" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10953" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-10955" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10963" href="../Lists/#plfa_plfa-part1-Lists-10921" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10966" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10969" href="../Lists/#plfa_plfa-part1-Lists-10924" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10972" href="../Lists/#plfa_plfa-part1-Lists-10892" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10986" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10989" href="../Lists/#plfa_plfa-part1-Lists-10989" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10992" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-10996" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11006" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11012" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11015" href="../Lists/#plfa_plfa-part1-Lists-10989" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11020" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11028" href="../Lists/#plfa_plfa-part1-Lists-10989" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11033" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11041" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11049" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-11052" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11055" href="../Lists/#plfa_plfa-part1-Lists-10989" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11060" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-11062" href="../Lists/#plfa_plfa-part1-Lists-10892" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-11076" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11077" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11079" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11081" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11083" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11085" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-11088" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-11092" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-11102" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11108" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11109" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11111" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11113" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11115" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11117" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11122" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11130" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11136" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11139" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11140" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11142" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11144" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11146" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11150" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-11153" href="../Lists/#plfa_plfa-part1-Lists-10892" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-11167" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11170" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11171" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11173" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11175" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11177" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11179" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-11185" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11193" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11196" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11199" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11200" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11202" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11204" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11206" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11210" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11218" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11226" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11229" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11232" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11233" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11235" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11237" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11239" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11242" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11244" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11248" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-11251" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-11255" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11256" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-11265" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11266" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11274" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11276" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11278" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11280" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11282" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11284" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11286" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11288" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-11294" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11295" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11303" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11306" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11309" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11311" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11313" href="../Lists/#plfa_plfa-part1-Lists-3007" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11314" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11316" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11319" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11324" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11332" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11340" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11341" href="../Lists/#plfa_plfa-part1-Lists-11077" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11343" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11345" href="../Lists/#plfa_plfa-part1-Lists-11081" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11347" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11349" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11352" href="../Lists/#plfa_plfa-part1-Lists-11085" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11357" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code> and follows by the inductive hypothesis and associativity of append. When we invoke the inductive hypothesis, the second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we induct becomes <em>smaller</em>.</p><p>Generalising on an auxiliary argument, which becomes larger as the argument on which we recurse or induct becomes smaller, is a common trick. It belongs in your quiver of arrows, ready to slay the right problem.</p>Having defined shunt by generalisation, it is now easy to respecialise to give a more efficient definition of reverse:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-12120" href="../Lists/#plfa_plfa-part1-Lists-12120" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12129" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12131" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12133" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12134" href="../Lists/#plfa_plfa-part1-Lists-12134" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12136" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12138" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12141" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12143" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12145" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12150" href="../Lists/#plfa_plfa-part1-Lists-12134" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12152" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12154" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12159" href="../Lists/#plfa_plfa-part1-Lists-12134" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-12161" href="../Lists/#plfa_plfa-part1-Lists-12120" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12170" href="../Lists/#plfa_plfa-part1-Lists-12170" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12173" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-12175" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12181" href="../Lists/#plfa_plfa-part1-Lists-12170" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12184" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
</pre>Given our previous lemma, it is straightforward to show the two definitions equivalent:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-12288" href="../Lists/#plfa_plfa-part1-Lists-12288" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12297" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12299" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12301" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12302" href="../Lists/#plfa_plfa-part1-Lists-12302" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12304" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12306" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12309" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12311" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12312" href="../Lists/#plfa_plfa-part1-Lists-12312" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12315" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12317" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12322" href="../Lists/#plfa_plfa-part1-Lists-12302" class="Bound">A</a><a id="plfa_plfa-part1-Lists-12323" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12327" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12329" href="../Lists/#plfa_plfa-part1-Lists-12120" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12338" href="../Lists/#plfa_plfa-part1-Lists-12312" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12341" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12343" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12351" href="../Lists/#plfa_plfa-part1-Lists-12312" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-12354" href="../Lists/#plfa_plfa-part1-Lists-12288" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12363" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12366" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12370" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12380" href="../Lists/#plfa_plfa-part1-Lists-12120" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12389" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12394" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12402" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12408" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12411" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12416" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12419" href="../Lists/#plfa_plfa-part1-Lists-10892" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-12433" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12436" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12439" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12445" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12453" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12456" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-12459" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12464" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12467" href="../Lists/#plfa_plfa-part1-Lists-6099" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-12480" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12481" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12489" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-12491" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12493" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12499" href="../Lists/#plfa_plfa-part1-Lists-8516" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12507" href="../Lists/#plfa_plfa-part1-Lists-12363" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12512" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre>Here is an example showing fast reverse of the list <code>[ 0 , 1 , 2 ]</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-12596" href="../Lists/#plfa_plfa-part1-Lists-12596" class="Function">_</a> <a id="plfa_plfa-part1-Lists-12598" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12600" href="../Lists/#plfa_plfa-part1-Lists-12120" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12609" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12611" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12613" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12615" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12617" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12619" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12621" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-12623" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12625" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12627" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12629" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12631" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12633" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12635" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12637" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-12639" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-12641" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12645" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12655" href="../Lists/#plfa_plfa-part1-Lists-12120" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12664" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12665" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12667" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12669" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12671" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12673" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12675" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12677" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12679" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12683" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12691" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12697" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12698" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12700" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12702" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12704" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12706" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12708" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12710" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12712" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12714" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12719" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12727" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12733" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12734" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12736" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12738" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12740" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12742" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12744" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12746" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12747" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12749" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12751" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12753" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12757" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12765" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12771" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12772" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12774" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12776" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12778" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12780" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12781" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12783" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12785" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12787" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12789" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12791" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12795" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12803" href="../Lists/#plfa_plfa-part1-Lists-10540" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12809" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12812" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12813" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12815" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12817" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12819" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12821" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12823" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12825" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12827" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12831" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12839" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12841" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12843" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12845" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12847" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12849" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12851" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12856" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Now the time to reverse a list is linear in the length of the list.</p><h2 id="Map">Map</h2>Map applies a function to every element of a list to generate a corresponding list. Map is an example of a <em>higher-order function</em>, one which takes a function as an argument or returns a function as a result:<pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-13163" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13167" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13169" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-13171" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-13172" href="../Lists/#plfa_plfa-part1-Lists-13172" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13174" href="../Lists/#plfa_plfa-part1-Lists-13174" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-13176" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13178" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-13181" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-13183" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13185" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13186" href="../Lists/#plfa_plfa-part1-Lists-13172" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13188" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13190" href="../Lists/#plfa_plfa-part1-Lists-13174" class="Bound">B</a><a id="plfa_plfa-part1-Lists-13191" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-13193" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13195" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13200" href="../Lists/#plfa_plfa-part1-Lists-13172" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13202" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13204" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13209" href="../Lists/#plfa_plfa-part1-Lists-13174" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-13211" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13215" href="../Lists/#plfa_plfa-part1-Lists-13215" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13217" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-13227" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13230" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-13233" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13237" href="../Lists/#plfa_plfa-part1-Lists-13237" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13239" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13240" href="../Lists/#plfa_plfa-part1-Lists-13240" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13242" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13244" href="../Lists/#plfa_plfa-part1-Lists-13244" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13246" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-13249" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13252" href="../Lists/#plfa_plfa-part1-Lists-13237" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13254" href="../Lists/#plfa_plfa-part1-Lists-13240" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13256" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13258" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13262" href="../Lists/#plfa_plfa-part1-Lists-13237" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13264" href="../Lists/#plfa_plfa-part1-Lists-13244" class="Bound">xs</a>
</pre><p>Map of the empty list is the empty list. Map of a non-empty list yields a list with head the same as the function applied to the head of the given list, and tail the same as map of the function applied to the tail of the given list.</p>Here is an example showing how to use map to increment every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-13593" href="../Lists/#plfa_plfa-part1-Lists-13593" class="Function">_</a> <a id="plfa_plfa-part1-Lists-13595" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13597" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13601" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13605" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13607" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13609" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13611" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13613" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13615" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13617" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13619" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13621" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13623" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13625" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13627" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13629" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13631" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13633" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-13635" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-13637" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13641" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13651" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13655" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13659" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13660" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13662" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13664" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13666" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13668" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13670" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13672" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13674" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13678" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13686" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13690" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13692" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13694" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13698" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13702" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13703" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13705" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13707" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13709" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13711" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13713" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13717" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13725" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13729" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13731" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13733" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13737" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13739" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13741" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13745" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13749" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13750" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13752" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13754" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13756" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13760" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13768" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13772" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13774" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13776" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13780" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13782" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13784" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13788" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13790" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13792" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13796" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13800" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13805" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13813" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13817" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13819" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13821" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13825" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13827" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13829" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13833" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13835" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13837" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13842" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13850" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13852" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13854" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13856" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13858" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13860" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13862" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13867" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Map requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying map to a function to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-14086" href="../Lists/#plfa_plfa-part1-Lists-14086" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14091" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14093" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-14098" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-14100" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-14102" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-14107" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-14109" href="../Lists/#plfa_plfa-part1-Lists-14086" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14114" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-14116" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-14120" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-14125" href="../Lists/#plfa_plfa-part1-Lists-14125" class="Function">_</a> <a id="plfa_plfa-part1-Lists-14127" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14129" href="../Lists/#plfa_plfa-part1-Lists-14086" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14134" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14136" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14138" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14140" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14142" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14144" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14146" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-14148" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-14150" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14152" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14154" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14156" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14158" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14160" class="Number">3</a> <a id="plfa_plfa-part1-Lists-14162" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-14164" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-14166" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-14170" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-14180" href="../Lists/#plfa_plfa-part1-Lists-14086" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-14185" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14187" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14189" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14191" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14193" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14195" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14197" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14201" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14209" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-14213" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-14217" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14219" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14221" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14223" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14225" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14227" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14229" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14233" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14241" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14243" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14245" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14247" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14249" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14251" class="Number">3</a> <a id="plfa_plfa-part1-Lists-14253" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14257" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>A type that is parameterised on another type, such as list, often has a corresponding map, which accepts a function and returns a function from the type parameterised on the domain of the function to the type parameterised on the range of the function. Further, a type that is parameterised on <em>n</em> types often has a map that is parameterised on <em>n</em> functions.</p><h4 id="exercise-map-compose-practice">Exercise <code>map-compose</code> (practice)</h4><p>Prove that the map of a composition is equal to the composition of two maps:</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>The last step of the proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-14838" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map--distribute-practice">Exercise <code>map-++-distribute</code> (practice)</h4><p>Prove the following relationship between map and append:</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-15023" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-tree-practice">Exercise <code>map-Tree</code> (practice)</h4>Define a type of trees with leaves of type <code>A</code> and internal nodes of type <code>B</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-15175" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-15180" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15185" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15186" href="../Lists/#plfa_plfa-part1-Lists-15186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15188" href="../Lists/#plfa_plfa-part1-Lists-15188" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15190" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15192" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15195" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15197" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15199" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-15203" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-15211" href="../Lists/#plfa_plfa-part1-Lists-15211" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-15216" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15218" href="../Lists/#plfa_plfa-part1-Lists-15186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15220" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15222" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15227" href="../Lists/#plfa_plfa-part1-Lists-15186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15229" href="../Lists/#plfa_plfa-part1-Lists-15188" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-15233" href="../Lists/#plfa_plfa-part1-Lists-15233" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-15238" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15240" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15245" href="../Lists/#plfa_plfa-part1-Lists-15186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15247" href="../Lists/#plfa_plfa-part1-Lists-15188" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15249" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15251" href="../Lists/#plfa_plfa-part1-Lists-15188" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15253" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15255" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15260" href="../Lists/#plfa_plfa-part1-Lists-15186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15262" href="../Lists/#plfa_plfa-part1-Lists-15188" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15264" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15266" href="../Lists/#plfa_plfa-part1-Lists-15180" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15271" href="../Lists/#plfa_plfa-part1-Lists-15186" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15273" href="../Lists/#plfa_plfa-part1-Lists-15188" class="Bound">B</a>
</pre><p>Define a suitable map operator over trees:</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-15407" class="Comment">-- Your code goes here</a>
</pre><h2 id="Fold">Fold</h2>Fold takes an operator and a value, and uses the operator to combine each of the elements of the list, taking the given value as the result for the empty list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-15620" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15626" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15628" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15630" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15631" href="../Lists/#plfa_plfa-part1-Lists-15631" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15633" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15635" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15637" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15640" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15642" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15644" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15645" href="../Lists/#plfa_plfa-part1-Lists-15631" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15647" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15649" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15651" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15653" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">B</a><a id="plfa_plfa-part1-Lists-15654" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15656" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15658" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15660" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15662" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15667" href="../Lists/#plfa_plfa-part1-Lists-15631" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15669" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15671" href="../Lists/#plfa_plfa-part1-Lists-15633" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-15673" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15679" href="../Lists/#plfa_plfa-part1-Lists-15679" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15683" href="../Lists/#plfa_plfa-part1-Lists-15683" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15685" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-15695" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15698" href="../Lists/#plfa_plfa-part1-Lists-15683" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-15700" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15706" href="../Lists/#plfa_plfa-part1-Lists-15706" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15710" href="../Lists/#plfa_plfa-part1-Lists-15710" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15712" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15713" href="../Lists/#plfa_plfa-part1-Lists-15713" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15715" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15717" href="../Lists/#plfa_plfa-part1-Lists-15717" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15719" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-15722" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15725" href="../Lists/#plfa_plfa-part1-Lists-15713" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15727" href="../Lists/#plfa_plfa-part1-Lists-15706" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-15729" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15735" href="../Lists/#plfa_plfa-part1-Lists-15706" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15739" href="../Lists/#plfa_plfa-part1-Lists-15710" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15741" href="../Lists/#plfa_plfa-part1-Lists-15717" class="Bound">xs</a>
</pre><p>Fold of the empty list is the given value. Fold of a non-empty list uses the operator to combine the head of the list and the fold of the tail of the list.</p>Here is an example showing how to use fold to find the sum of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-15983" href="../Lists/#plfa_plfa-part1-Lists-15983" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15985" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15987" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15993" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15997" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15999" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16001" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16003" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16005" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16007" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16009" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16011" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16013" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16015" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16017" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16019" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-16022" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16024" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16028" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16038" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16044" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16048" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16050" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16051" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16053" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16055" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16057" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16059" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16061" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16063" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16065" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16067" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16069" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16073" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16081" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16083" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16085" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16091" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16095" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16097" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16098" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16100" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16102" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16104" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16106" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16108" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16110" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16112" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-16116" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16124" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16126" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16128" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16129" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16131" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16133" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16139" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16143" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16145" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16146" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16148" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16150" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16152" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16154" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16156" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-16161" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16169" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16171" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16173" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16174" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16176" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16178" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16179" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16181" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16183" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16189" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16193" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16195" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16196" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16198" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16200" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16202" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16208" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16216" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16218" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16220" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16221" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16223" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16225" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16226" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16228" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16230" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16231" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16233" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16235" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16241" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16245" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16247" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16249" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16255" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16263" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16265" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16267" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16268" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16270" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16272" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16273" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16275" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16277" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16278" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16280" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16282" class="Number">0</a><a id="plfa_plfa-part1-Lists-16283" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16289" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Here we have an instance of <code>foldr</code> where <code>A</code> and <code>B</code> are both <code>ℕ</code>. Fold requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying fold to an operator and a value to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-16591" href="../Lists/#plfa_plfa-part1-Lists-16591" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16595" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16597" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16602" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-16604" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16606" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-16608" href="../Lists/#plfa_plfa-part1-Lists-16591" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16612" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-16614" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16620" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16624" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-16627" href="../Lists/#plfa_plfa-part1-Lists-16627" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16629" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16631" href="../Lists/#plfa_plfa-part1-Lists-16591" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16635" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16637" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16639" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16641" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16643" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16645" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16647" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16649" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16651" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16653" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16655" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-16658" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16660" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16664" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16674" href="../Lists/#plfa_plfa-part1-Lists-16591" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16678" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16680" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16682" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16684" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16686" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16688" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16690" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16692" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16694" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16698" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16706" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16712" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16716" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16718" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16720" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16722" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16724" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16726" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16728" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16730" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16732" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16734" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16738" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16746" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-16751" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>Just as the list type has two constructors, <code>[]</code> and <code>_∷_</code>, so the fold function takes two arguments, <code>e</code> and <code>_⊗_</code> (in addition to the list argument). In general, a data type with <em>n</em> constructors will have a corresponding fold function that takes <em>n</em> arguments.</p><p>As another example, observe that</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Here, if <code>xs</code> is of type <code>List A</code>, then we see we have an instance of <code>foldr</code> where <code>A</code> is <code>A</code> and <code>B</code> is <code>List A</code>. It follows that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>Demonstrating both these equations is left as an exercise.</p><h4 id="exercise-product-recommended">Exercise <code>product</code> (recommended)</h4><p>Use fold to define a function to find the product of a list of numbers. For example:</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17479" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--recommended">Exercise <code>foldr-++</code> (recommended)</h4>Show that fold and append are related as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-17605" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-17617" href="../Lists/#plfa_plfa-part1-Lists-17617" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-17626" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17628" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-17630" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-17631" href="../Lists/#plfa_plfa-part1-Lists-17631" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-17633" href="../Lists/#plfa_plfa-part1-Lists-17633" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-17635" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17637" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-17640" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-17642" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17643" href="../Lists/#plfa_plfa-part1-Lists-17643" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17647" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17649" href="../Lists/#plfa_plfa-part1-Lists-17631" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-17651" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17653" href="../Lists/#plfa_plfa-part1-Lists-17633" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-17655" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17657" href="../Lists/#plfa_plfa-part1-Lists-17633" class="Bound">B</a><a id="plfa_plfa-part1-Lists-17658" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17660" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17661" href="../Lists/#plfa_plfa-part1-Lists-17661" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17663" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17665" href="../Lists/#plfa_plfa-part1-Lists-17633" class="Bound">B</a><a id="plfa_plfa-part1-Lists-17666" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17668" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17669" href="../Lists/#plfa_plfa-part1-Lists-17669" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-17672" href="../Lists/#plfa_plfa-part1-Lists-17672" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-17675" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17677" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17682" href="../Lists/#plfa_plfa-part1-Lists-17631" class="Bound">A</a><a id="plfa_plfa-part1-Lists-17683" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17685" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-17691" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17697" href="../Lists/#plfa_plfa-part1-Lists-17643" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17701" href="../Lists/#plfa_plfa-part1-Lists-17661" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17703" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17704" href="../Lists/#plfa_plfa-part1-Lists-17669" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-17707" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-17710" href="../Lists/#plfa_plfa-part1-Lists-17672" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-17712" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17714" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17716" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17722" href="../Lists/#plfa_plfa-part1-Lists-17643" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17726" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17727" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17733" href="../Lists/#plfa_plfa-part1-Lists-17643" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17737" href="../Lists/#plfa_plfa-part1-Lists-17661" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17739" href="../Lists/#plfa_plfa-part1-Lists-17672" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-17741" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17743" href="../Lists/#plfa_plfa-part1-Lists-17669" class="Bound">xs</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17759" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17944" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-foldr-practice">Exercise <code>map-is-foldr</code> (practice)</h4><p>Show that map can be defined using fold:</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>The proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18141" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-fold-tree-practice">Exercise <code>fold-Tree</code> (practice)</h4><p>Define a suitable fold function for the type of trees given earlier:</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18362" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-fold-tree-practice">Exercise <code>map-is-fold-Tree</code> (practice)</h4><p>Demonstrate an analogue of <code>map-is-foldr</code> for the type of trees.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18509" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-sum-downfrom-stretch">Exercise <code>sum-downFrom</code> (stretch)</h4>Define a function that counts down as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-18632" href="../Lists/#plfa_plfa-part1-Lists-18632" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18641" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18643" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-18645" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18647" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-18652" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-18654" href="../Lists/#plfa_plfa-part1-Lists-18632" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18663" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-18672" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18675" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-18678" href="../Lists/#plfa_plfa-part1-Lists-18632" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18687" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18688" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-18692" href="../Lists/#plfa_plfa-part1-Lists-18692" class="Bound">n</a><a id="plfa_plfa-part1-Lists-18693" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-18696" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18699" href="../Lists/#plfa_plfa-part1-Lists-18692" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-18701" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-18703" href="../Lists/#plfa_plfa-part1-Lists-18632" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18712" href="../Lists/#plfa_plfa-part1-Lists-18692" class="Bound">n</a>
</pre>For example:<pre class="Agda"><a id="plfa_plfa-part1-Lists-18739" href="../Lists/#plfa_plfa-part1-Lists-18739" class="Function">_</a> <a id="plfa_plfa-part1-Lists-18741" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18743" href="../Lists/#plfa_plfa-part1-Lists-18632" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18752" class="Number">3</a> <a id="plfa_plfa-part1-Lists-18754" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18756" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-18758" class="Number">2</a> <a id="plfa_plfa-part1-Lists-18760" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18762" class="Number">1</a> <a id="plfa_plfa-part1-Lists-18764" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18766" class="Number">0</a> <a id="plfa_plfa-part1-Lists-18768" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-18770" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-18772" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-18774" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
</pre><p>Prove that the sum of the numbers <code>(n - 1) + ⋯ + 0</code> is equal to <code>n * (n ∸ 1) / 2</code>:</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18915" class="Comment">-- Your code goes here</a>
</pre><h2 id="monoids">Monoids</h2><p>Typically when we use a fold the operator is associative and the value is a left and right identity for the operator, meaning that the operator and the value form a <em>monoid</em>.</p>We can define a monoid as a suitable record type:<pre class="Agda"><a id="plfa_plfa-part1-Lists-19189" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-19196" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19205" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19206" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19208" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19210" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19213" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19215" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19216" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19220" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19222" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19224" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19226" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19228" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19230" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19231" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19233" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19234" href="../Lists/#plfa_plfa-part1-Lists-19234" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19236" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19238" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19239" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19241" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19243" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-19247" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-19255" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-19265" href="../Lists/#plfa_plfa-part1-Lists-19265" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19271" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19273" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19275" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19276" href="../Lists/#plfa_plfa-part1-Lists-19276" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19278" href="../Lists/#plfa_plfa-part1-Lists-19278" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19280" href="../Lists/#plfa_plfa-part1-Lists-19280" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-19282" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19284" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19285" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19287" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19289" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19290" href="../Lists/#plfa_plfa-part1-Lists-19276" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19292" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19294" href="../Lists/#plfa_plfa-part1-Lists-19278" class="Bound">y</a><a id="plfa_plfa-part1-Lists-19295" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19297" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19299" href="../Lists/#plfa_plfa-part1-Lists-19280" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-19301" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19303" href="../Lists/#plfa_plfa-part1-Lists-19276" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19305" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19307" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19308" href="../Lists/#plfa_plfa-part1-Lists-19278" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19310" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19312" href="../Lists/#plfa_plfa-part1-Lists-19280" class="Bound">z</a><a id="plfa_plfa-part1-Lists-19313" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-19319" href="../Lists/#plfa_plfa-part1-Lists-19319" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19329" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19331" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19333" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19334" href="../Lists/#plfa_plfa-part1-Lists-19334" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19336" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19338" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19339" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19341" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19343" href="../Lists/#plfa_plfa-part1-Lists-19234" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19345" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19347" href="../Lists/#plfa_plfa-part1-Lists-19334" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19349" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19351" href="../Lists/#plfa_plfa-part1-Lists-19334" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-19357" href="../Lists/#plfa_plfa-part1-Lists-19357" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19367" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19369" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19371" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19372" href="../Lists/#plfa_plfa-part1-Lists-19372" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19374" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19376" href="../Lists/#plfa_plfa-part1-Lists-19206" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19377" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19379" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19381" href="../Lists/#plfa_plfa-part1-Lists-19372" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19383" href="../Lists/#plfa_plfa-part1-Lists-19216" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19385" href="../Lists/#plfa_plfa-part1-Lists-19234" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19387" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19389" href="../Lists/#plfa_plfa-part1-Lists-19372" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-19392" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-19397" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Module">IsMonoid</a>
</pre>As examples, sum and zero, multiplication and one, and append and the empty list, are all examples of monoids:<pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-19530" href="../Lists/#plfa_plfa-part1-Lists-19530" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19539" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19541" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19550" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#336" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19554" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-19556" href="../Lists/#plfa_plfa-part1-Lists-19530" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19565" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19569" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19580" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19582" href="../Lists/#plfa_plfa-part1-Lists-19265" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19588" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19590" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15113" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-19602" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19604" href="../Lists/#plfa_plfa-part1-Lists-19319" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19614" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19616" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15214" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19632" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19634" href="../Lists/#plfa_plfa-part1-Lists-19357" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19644" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19646" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#15269" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19662" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-19665" href="../Lists/#plfa_plfa-part1-Lists-19665" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19674" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19676" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19685" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Nat.html#539" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-19689" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-19691" href="../Lists/#plfa_plfa-part1-Lists-19665" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19700" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19704" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19715" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19717" href="../Lists/#plfa_plfa-part1-Lists-19265" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19723" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19725" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#22674" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-19737" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19739" href="../Lists/#plfa_plfa-part1-Lists-19319" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19749" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19751" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21574" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19767" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19769" href="../Lists/#plfa_plfa-part1-Lists-19357" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19779" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19781" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Properties.html#21638" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19797" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-19800" href="../Lists/#plfa_plfa-part1-Lists-19800" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19810" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19812" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19814" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19815" href="../Lists/#plfa_plfa-part1-Lists-19815" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19817" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19819" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19822" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19824" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19826" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19835" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19836" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19841" href="../Lists/#plfa_plfa-part1-Lists-19815" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19842" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19844" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-19849" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-19852" href="../Lists/#plfa_plfa-part1-Lists-19800" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19862" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19866" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19877" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19879" href="../Lists/#plfa_plfa-part1-Lists-19265" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19885" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19887" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-19900" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19902" href="../Lists/#plfa_plfa-part1-Lists-19319" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19912" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19914" href="../Lists/#plfa_plfa-part1-Lists-5917" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19931" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19933" href="../Lists/#plfa_plfa-part1-Lists-19357" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19943" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19945" href="../Lists/#plfa_plfa-part1-Lists-6099" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19962" class="Symbol">}</a>
</pre>If <code>_⊗_</code> and <code>e</code> form a monoid, then we can re-express fold on the same operator and an arbitrary value:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-20082" href="../Lists/#plfa_plfa-part1-Lists-20082" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20095" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20097" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20099" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20100" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20102" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20104" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20107" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20109" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20110" href="../Lists/#plfa_plfa-part1-Lists-20110" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20114" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20116" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20118" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20120" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20122" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20124" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20125" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20127" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20128" href="../Lists/#plfa_plfa-part1-Lists-20128" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20130" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20132" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20133" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20135" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20137" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-20146" href="../Lists/#plfa_plfa-part1-Lists-20110" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20150" href="../Lists/#plfa_plfa-part1-Lists-20128" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20152" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-20156" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20158" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20159" href="../Lists/#plfa_plfa-part1-Lists-20159" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20162" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20164" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20169" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20170" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20172" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20173" href="../Lists/#plfa_plfa-part1-Lists-20173" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20175" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20177" href="../Lists/#plfa_plfa-part1-Lists-20100" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20178" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20180" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20182" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20188" href="../Lists/#plfa_plfa-part1-Lists-20110" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20192" href="../Lists/#plfa_plfa-part1-Lists-20173" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20194" href="../Lists/#plfa_plfa-part1-Lists-20159" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20197" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20199" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20205" href="../Lists/#plfa_plfa-part1-Lists-20110" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20209" href="../Lists/#plfa_plfa-part1-Lists-20128" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20211" href="../Lists/#plfa_plfa-part1-Lists-20159" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20214" href="../Lists/#plfa_plfa-part1-Lists-20110" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20216" href="../Lists/#plfa_plfa-part1-Lists-20173" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-20218" href="../Lists/#plfa_plfa-part1-Lists-20082" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20231" href="../Lists/#plfa_plfa-part1-Lists-20231" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20235" href="../Lists/#plfa_plfa-part1-Lists-20235" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20237" href="../Lists/#plfa_plfa-part1-Lists-20237" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20246" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-20249" href="../Lists/#plfa_plfa-part1-Lists-20249" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20251" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20255" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20265" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20271" href="../Lists/#plfa_plfa-part1-Lists-20231" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20275" href="../Lists/#plfa_plfa-part1-Lists-20249" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20277" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-20282" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20290" href="../Lists/#plfa_plfa-part1-Lists-20249" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20294" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20297" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20301" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20302" href="../Lists/#plfa_plfa-part1-Lists-19319" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-20312" href="../Lists/#plfa_plfa-part1-Lists-20237" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20321" href="../Lists/#plfa_plfa-part1-Lists-20249" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20322" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20324" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20330" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20331" href="../Lists/#plfa_plfa-part1-Lists-20235" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20333" href="../Lists/#plfa_plfa-part1-Lists-20231" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20335" href="../Lists/#plfa_plfa-part1-Lists-20249" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20336" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20340" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20348" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20354" href="../Lists/#plfa_plfa-part1-Lists-20231" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20358" href="../Lists/#plfa_plfa-part1-Lists-20235" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20360" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-20363" href="../Lists/#plfa_plfa-part1-Lists-20231" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20365" href="../Lists/#plfa_plfa-part1-Lists-20249" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20369" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-20371" href="../Lists/#plfa_plfa-part1-Lists-20082" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20384" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20388" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20390" href="../Lists/#plfa_plfa-part1-Lists-20390" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20399" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20400" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20402" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20404" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20406" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20408" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20410" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20414" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20424" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20430" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20434" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20436" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20437" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20439" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20441" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20443" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20447" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20455" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20457" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20459" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20460" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20466" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20470" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20472" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20474" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20478" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20481" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1339" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-20486" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20487" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20489" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-20491" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20493" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20494" href="../Lists/#plfa_plfa-part1-Lists-20082" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20507" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20511" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20513" href="../Lists/#plfa_plfa-part1-Lists-20390" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20522" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20525" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20526" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20528" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20534" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20536" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20538" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20539" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20545" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20549" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20551" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20554" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20556" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20557" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20561" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20564" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.PropositionalEquality.Core.html#1893" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20568" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20569" href="../Lists/#plfa_plfa-part1-Lists-19265" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-20575" href="../Lists/#plfa_plfa-part1-Lists-20390" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20584" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20586" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20587" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20593" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20597" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20599" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20601" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20603" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20604" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20606" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20612" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20613" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20615" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20617" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20623" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20627" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20629" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20631" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20633" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20635" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20639" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11079" class="Function">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20647" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20653" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20657" href="../Lists/#plfa_plfa-part1-Lists-20388" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20659" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20660" href="../Lists/#plfa_plfa-part1-Lists-20400" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20662" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20664" href="../Lists/#plfa_plfa-part1-Lists-20404" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20666" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20668" href="../Lists/#plfa_plfa-part1-Lists-20384" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20670" href="../Lists/#plfa_plfa-part1-Lists-20408" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20674" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><p>In exercise <code>foldr-++</code> above we showed the following:</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre>As a consequence we can decompose fold over append in a monoid into two folds as follows.<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-20894" href="../Lists/#plfa_plfa-part1-Lists-20894" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-20910" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20912" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20914" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20915" href="../Lists/#plfa_plfa-part1-Lists-20915" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20917" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20919" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20922" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20924" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20925" href="../Lists/#plfa_plfa-part1-Lists-20925" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20929" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20931" href="../Lists/#plfa_plfa-part1-Lists-20915" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20933" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20935" href="../Lists/#plfa_plfa-part1-Lists-20915" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20937" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20939" href="../Lists/#plfa_plfa-part1-Lists-20915" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20940" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20942" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20943" href="../Lists/#plfa_plfa-part1-Lists-20943" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20945" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20947" href="../Lists/#plfa_plfa-part1-Lists-20915" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20948" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20950" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20952" href="../Lists/#plfa_plfa-part1-Lists-19196" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-20961" href="../Lists/#plfa_plfa-part1-Lists-20925" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20965" href="../Lists/#plfa_plfa-part1-Lists-20943" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20967" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-20971" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20973" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20974" href="../Lists/#plfa_plfa-part1-Lists-20974" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20977" href="../Lists/#plfa_plfa-part1-Lists-20977" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20980" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20982" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20987" href="../Lists/#plfa_plfa-part1-Lists-20915" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20988" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20990" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20992" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20998" href="../Lists/#plfa_plfa-part1-Lists-20925" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21002" href="../Lists/#plfa_plfa-part1-Lists-20943" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21004" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21005" href="../Lists/#plfa_plfa-part1-Lists-20974" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21008" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-21011" href="../Lists/#plfa_plfa-part1-Lists-20977" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21013" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21015" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-21017" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21023" href="../Lists/#plfa_plfa-part1-Lists-20925" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21027" href="../Lists/#plfa_plfa-part1-Lists-20943" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21029" href="../Lists/#plfa_plfa-part1-Lists-20974" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21032" href="../Lists/#plfa_plfa-part1-Lists-20925" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-21034" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21040" href="../Lists/#plfa_plfa-part1-Lists-20925" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21044" href="../Lists/#plfa_plfa-part1-Lists-20943" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21046" href="../Lists/#plfa_plfa-part1-Lists-20977" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-21049" href="../Lists/#plfa_plfa-part1-Lists-20894" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-21065" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21069" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21071" href="../Lists/#plfa_plfa-part1-Lists-21071" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-21080" href="../Lists/#plfa_plfa-part1-Lists-21080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21083" href="../Lists/#plfa_plfa-part1-Lists-21083" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-21086" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-21090" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#1572" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-21100" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21106" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21110" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21112" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21113" href="../Lists/#plfa_plfa-part1-Lists-21080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21116" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-21119" href="../Lists/#plfa_plfa-part1-Lists-21083" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21121" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-21125" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-21128" href="../Lists/#plfa_plfa-part1-Lists-17617" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-21137" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21141" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21143" href="../Lists/#plfa_plfa-part1-Lists-21080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21146" href="../Lists/#plfa_plfa-part1-Lists-21083" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-21149" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-21155" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21161" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21165" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21166" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21172" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21176" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21178" href="../Lists/#plfa_plfa-part1-Lists-21083" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21180" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21182" href="../Lists/#plfa_plfa-part1-Lists-21080" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-21187" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-21190" href="../Lists/#plfa_plfa-part1-Lists-20082" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-21203" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21207" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21209" href="../Lists/#plfa_plfa-part1-Lists-21071" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-21218" href="../Lists/#plfa_plfa-part1-Lists-21080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21221" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21222" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21228" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21232" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21234" href="../Lists/#plfa_plfa-part1-Lists-21083" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21236" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21238" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#11048" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-21244" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21250" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21254" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21256" href="../Lists/#plfa_plfa-part1-Lists-21080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21259" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-21261" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21267" href="../Lists/#plfa_plfa-part1-Lists-21065" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21271" href="../Lists/#plfa_plfa-part1-Lists-21069" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21273" href="../Lists/#plfa_plfa-part1-Lists-21083" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-21278" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Reasoning.Syntax.html#12345" class="Function Operator">∎</a>
</pre><h4 id="exercise-foldl-practice">Exercise <code>foldl</code> (practice)</h4><p>Define a function <code>foldl</code> which is analogous to <code>foldr</code>, but where operations associate to the left rather than the right. For example:</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21570" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr-monoid-foldl-practice">Exercise <code>foldr-monoid-foldl</code> (practice)</h4><p>Show that if <code>_⊗_</code> and <code>e</code> form a monoid, then <code>foldr _⊗_ e</code> and <code>foldl _⊗_ e</code> always compute the same result.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-21766" class="Comment">-- Your code goes here</a>
</pre><h2 id="All">All</h2><p>We can also define predicates over lists. Two of the most important are <code>All</code> and <code>Any</code>.</p>Predicate <code>All P</code> holds if predicate <code>P</code> is satisfied by every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-21990" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-21995" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21999" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-22000" href="../Lists/#plfa_plfa-part1-Lists-22000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-22002" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22004" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-22007" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-22009" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22010" href="../Lists/#plfa_plfa-part1-Lists-22010" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22012" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22014" href="../Lists/#plfa_plfa-part1-Lists-22000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-22016" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22018" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-22021" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22023" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22025" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-22030" href="../Lists/#plfa_plfa-part1-Lists-22000" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-22032" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22034" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-22038" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-22046" href="../Lists/#plfa_plfa-part1-Lists-22046" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-22050" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22052" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22056" href="../Lists/#plfa_plfa-part1-Lists-22010" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22058" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-22063" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-22067" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22069" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-22071" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-22072" href="../Lists/#plfa_plfa-part1-Lists-22072" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-22074" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22076" href="../Lists/#plfa_plfa-part1-Lists-22000" class="Bound">A</a><a id="plfa_plfa-part1-Lists-22077" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-22079" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-22080" href="../Lists/#plfa_plfa-part1-Lists-22080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-22083" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22085" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-22090" href="../Lists/#plfa_plfa-part1-Lists-22000" class="Bound">A</a><a id="plfa_plfa-part1-Lists-22091" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-22093" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22095" href="../Lists/#plfa_plfa-part1-Lists-22010" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22097" href="../Lists/#plfa_plfa-part1-Lists-22072" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-22099" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22101" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22105" href="../Lists/#plfa_plfa-part1-Lists-22010" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22107" href="../Lists/#plfa_plfa-part1-Lists-22080" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-22110" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-22112" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22116" href="../Lists/#plfa_plfa-part1-Lists-22010" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-22118" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22119" href="../Lists/#plfa_plfa-part1-Lists-22072" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-22121" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22123" href="../Lists/#plfa_plfa-part1-Lists-22080" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-22125" class="Symbol">)</a>
</pre><p>The type has two constructors, reusing the names of the same constructors for lists. The first asserts that <code>P</code> holds for every element of the empty list. The second asserts that if <code>P</code> holds of the head of a list and for every element of the tail of a list, then <code>P</code> holds for every element of the list. Agda uses types to disambiguate whether the constructor is building a list or evidence that <code>All P</code> holds.</p>For example, <code>All (_≤ 2)</code> holds of a list where every element is less than or equal to two. Recall that <code>z≤n</code> proves <code>zero ≤ n</code> for any <code>n</code>, and that if <code>m≤n</code> proves <code>m ≤ n</code> then <code>s≤s m≤n</code> proves <code>suc m ≤ suc n</code>, for any <code>m</code> and <code>n</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-22787" href="../Lists/#plfa_plfa-part1-Lists-22787" class="Function">_</a> <a id="plfa_plfa-part1-Lists-22789" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22791" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22795" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22796" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1691" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-22799" class="Number">2</a><a id="plfa_plfa-part1-Lists-22800" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22802" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-22804" class="Number">0</a> <a id="plfa_plfa-part1-Lists-22806" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22808" class="Number">1</a> <a id="plfa_plfa-part1-Lists-22810" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22812" class="Number">2</a> <a id="plfa_plfa-part1-Lists-22814" href="../Lists/#plfa_plfa-part1-Lists-3061" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-22816" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-22818" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-22820" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22824" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22826" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22830" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22834" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22836" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22840" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22841" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1756" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22845" href="https://agda.github.io/agda-stdlib/v2.1/Data.Nat.Base.html#1714" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-22848" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22850" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22852" href="../Lists/#plfa_plfa-part1-Lists-22046" class="InductiveConstructor">[]</a>
</pre><p>Here <code>_∷_</code> and <code>[]</code> are the constructors of <code>All P</code> rather than of <code>List A</code>. The three items are proofs of <code>0 ≤ 2</code>, <code>1 ≤ 2</code>, and <code>2 ≤ 2</code>, respectively.</p><p>(One might wonder whether a pattern such as <code>[_,_,_]</code> can be used to construct values of type <code>All</code> as well as type <code>List</code>, since both use the same constructors. Indeed it can, so long as both types are in scope when the pattern is declared. That’s not the case here, since <code>List</code> is defined before <code>[_,_,_]</code>, but <code>All</code> is defined later.)</p><h2 id="any">Any</h2>Predicate <code>Any P</code> holds if predicate <code>P</code> is satisfied by some element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23451" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-23456" href="../Lists/#plfa_plfa-part1-Lists-23456" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23460" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23461" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23463" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23465" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23468" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23470" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23471" href="../Lists/#plfa_plfa-part1-Lists-23471" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23473" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23475" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23477" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23479" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23482" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23484" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23486" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23491" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23493" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23495" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-23499" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-23507" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-23513" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23515" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23517" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23518" href="../Lists/#plfa_plfa-part1-Lists-23518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23520" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23522" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23523" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23525" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23526" href="../Lists/#plfa_plfa-part1-Lists-23526" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23529" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23531" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23536" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23537" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23539" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23541" href="../Lists/#plfa_plfa-part1-Lists-23471" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23543" href="../Lists/#plfa_plfa-part1-Lists-23518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23545" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23547" href="../Lists/#plfa_plfa-part1-Lists-23456" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23551" href="../Lists/#plfa_plfa-part1-Lists-23471" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23553" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23554" href="../Lists/#plfa_plfa-part1-Lists-23518" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23556" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23558" href="../Lists/#plfa_plfa-part1-Lists-23526" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23560" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-23564" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-23570" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23572" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23574" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23575" href="../Lists/#plfa_plfa-part1-Lists-23575" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23577" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23579" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23580" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23582" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23583" href="../Lists/#plfa_plfa-part1-Lists-23583" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23586" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23588" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23593" href="../Lists/#plfa_plfa-part1-Lists-23461" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23594" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23596" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23598" href="../Lists/#plfa_plfa-part1-Lists-23456" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23602" href="../Lists/#plfa_plfa-part1-Lists-23471" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23604" href="../Lists/#plfa_plfa-part1-Lists-23583" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23607" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23609" href="../Lists/#plfa_plfa-part1-Lists-23456" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23613" href="../Lists/#plfa_plfa-part1-Lists-23471" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23615" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23616" href="../Lists/#plfa_plfa-part1-Lists-23575" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23618" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23620" href="../Lists/#plfa_plfa-part1-Lists-23583" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23622" class="Symbol">)</a>
</pre>The first constructor provides evidence that the head of the list satisfies <code>P</code>, while the second provides evidence that some element of the tail of the list satisfies <code>P</code>. For example, we can define list membership as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23865" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-23871" class="Number">4</a> <a id="plfa_plfa-part1-Lists-23873" href="../Lists/#plfa_plfa-part1-Lists-23882" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23877" href="../Lists/#plfa_plfa-part1-Lists-23952" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-23882" href="../Lists/#plfa_plfa-part1-Lists-23882" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23886" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23888" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23890" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23891" href="../Lists/#plfa_plfa-part1-Lists-23891" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23893" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23895" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23898" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23900" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23901" href="../Lists/#plfa_plfa-part1-Lists-23901" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23903" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23905" href="../Lists/#plfa_plfa-part1-Lists-23891" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23906" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23908" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23909" href="../Lists/#plfa_plfa-part1-Lists-23909" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23912" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23914" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23919" href="../Lists/#plfa_plfa-part1-Lists-23891" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23920" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23922" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23924" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23928" href="../Lists/#plfa_plfa-part1-Lists-23928" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23930" href="../Lists/#plfa_plfa-part1-Lists-23882" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23932" href="../Lists/#plfa_plfa-part1-Lists-23932" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23935" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23937" href="../Lists/#plfa_plfa-part1-Lists-23456" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23941" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23942" href="../Lists/#plfa_plfa-part1-Lists-23928" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23944" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#150" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-23946" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23948" href="../Lists/#plfa_plfa-part1-Lists-23932" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-23952" href="../Lists/#plfa_plfa-part1-Lists-23952" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-23956" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23958" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23960" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23961" href="../Lists/#plfa_plfa-part1-Lists-23961" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23963" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23965" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23968" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23970" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23971" href="../Lists/#plfa_plfa-part1-Lists-23971" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23973" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23975" href="../Lists/#plfa_plfa-part1-Lists-23961" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23976" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23978" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23979" href="../Lists/#plfa_plfa-part1-Lists-23979" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23982" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23984" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23989" href="../Lists/#plfa_plfa-part1-Lists-23961" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23990" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23992" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23994" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23998" href="../Lists/#plfa_plfa-part1-Lists-23998" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24000" href="../Lists/#plfa_plfa-part1-Lists-23952" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-24002" href="../Lists/#plfa_plfa-part1-Lists-24002" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24005" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24007" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-24009" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24010" href="../Lists/#plfa_plfa-part1-Lists-23998" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-24012" href="../Lists/#plfa_plfa-part1-Lists-23882" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24014" href="../Lists/#plfa_plfa-part1-Lists-24002" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-24016" class="Symbol">)</a>
</pre>For example, zero is an element of the list <code>[ 0 , 1 , 0 , 2 ]</code>. Indeed, we can demonstrate this fact in two different ways, corresponding to the two different occurrences of zero in the list, as the first element and as the third element:<pre class="Agda"><a id="plfa_plfa-part1-Lists-24271" href="../Lists/#plfa_plfa-part1-Lists-24271" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24273" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24275" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24277" href="../Lists/#plfa_plfa-part1-Lists-23882" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24279" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24281" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24283" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24285" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24287" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24289" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24291" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24293" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24295" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24297" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24299" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24301" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24306" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-24312" href="../Lists/#plfa_plfa-part1-Lists-24312" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24314" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24316" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24318" href="../Lists/#plfa_plfa-part1-Lists-23882" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24320" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24322" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24324" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24326" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24328" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24330" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24332" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24334" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24336" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24338" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24340" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24342" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24348" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24349" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24355" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24356" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24361" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-24365" class="Symbol">))</a>
</pre>Further, we can demonstrate that three is not in the list, because any possible proof that it is in the list leads to contradiction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-24513" href="../Lists/#plfa_plfa-part1-Lists-24513" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24520" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24522" class="Number">3</a> <a id="plfa_plfa-part1-Lists-24524" href="../Lists/#plfa_plfa-part1-Lists-23952" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-24526" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24528" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24530" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24532" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24534" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24536" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24538" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24540" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24542" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24544" href="../Lists/#plfa_plfa-part1-Lists-24513" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24551" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24552" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24557" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-24561" href="../Lists/#plfa_plfa-part1-Lists-24513" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24568" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24569" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24575" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24576" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24581" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-24586" href="../Lists/#plfa_plfa-part1-Lists-24513" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24593" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24594" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24600" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24601" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24607" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24608" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24613" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-24619" href="../Lists/#plfa_plfa-part1-Lists-24513" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24626" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24627" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24633" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24634" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24640" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24641" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24647" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24648" href="../Lists/#plfa_plfa-part1-Lists-23507" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24653" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-24660" href="../Lists/#plfa_plfa-part1-Lists-24513" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24667" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24668" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24674" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24675" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24681" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24682" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24688" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24689" href="../Lists/#plfa_plfa-part1-Lists-23564" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24695" class="Symbol">()))))</a>
</pre><p>The five occurrences of <code>()</code> attest to the fact that there is no possible evidence for <code>3 ≡ 0</code>, <code>3 ≡ 1</code>, <code>3 ≡ 0</code>, <code>3 ≡ 2</code>, and <code>3 ∈ []</code>, respectively.</p><h2 id="all-and-append">All and append</h2>A predicate holds for every element of one list appended to another if and only if it holds for every element of both lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-25010" href="../Lists/#plfa_plfa-part1-Lists-25010" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-25019" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25021" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25023" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25024" href="../Lists/#plfa_plfa-part1-Lists-25024" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25026" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25028" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25031" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25033" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25034" href="../Lists/#plfa_plfa-part1-Lists-25034" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25036" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25038" href="../Lists/#plfa_plfa-part1-Lists-25024" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25040" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25042" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25045" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25047" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25048" href="../Lists/#plfa_plfa-part1-Lists-25048" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25051" href="../Lists/#plfa_plfa-part1-Lists-25051" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25054" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25056" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25061" href="../Lists/#plfa_plfa-part1-Lists-25024" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25062" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25064" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-25068" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25072" href="../Lists/#plfa_plfa-part1-Lists-25034" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25074" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25075" href="../Lists/#plfa_plfa-part1-Lists-25048" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25078" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25081" href="../Lists/#plfa_plfa-part1-Lists-25051" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25083" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25085" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12028" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-25087" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25088" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25092" href="../Lists/#plfa_plfa-part1-Lists-25034" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25094" href="../Lists/#plfa_plfa-part1-Lists-25048" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25097" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25099" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25103" href="../Lists/#plfa_plfa-part1-Lists-25034" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25105" href="../Lists/#plfa_plfa-part1-Lists-25051" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25107" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-25109" href="../Lists/#plfa_plfa-part1-Lists-25010" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-25118" href="../Lists/#plfa_plfa-part1-Lists-25118" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25121" href="../Lists/#plfa_plfa-part1-Lists-25121" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25124" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-25128" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-25139" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25141" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12068" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-25150" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25153" href="../Lists/#plfa_plfa-part1-Lists-25208" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25156" href="../Lists/#plfa_plfa-part1-Lists-25118" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25159" href="../Lists/#plfa_plfa-part1-Lists-25121" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-25166" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-25168" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12085" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-25177" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25180" href="../Lists/#plfa_plfa-part1-Lists-25433" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25185" href="../Lists/#plfa_plfa-part1-Lists-25118" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25188" href="../Lists/#plfa_plfa-part1-Lists-25121" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-25195" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-25199" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-25208" href="../Lists/#plfa_plfa-part1-Lists-25208" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25211" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25213" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25215" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25216" href="../Lists/#plfa_plfa-part1-Lists-25216" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25218" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25220" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25223" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25225" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25226" href="../Lists/#plfa_plfa-part1-Lists-25226" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25228" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25230" href="../Lists/#plfa_plfa-part1-Lists-25216" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25232" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25234" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25237" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25239" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25240" href="../Lists/#plfa_plfa-part1-Lists-25240" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25243" href="../Lists/#plfa_plfa-part1-Lists-25243" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25246" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25248" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25253" href="../Lists/#plfa_plfa-part1-Lists-25216" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25254" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25256" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25262" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25266" href="../Lists/#plfa_plfa-part1-Lists-25226" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25268" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25269" href="../Lists/#plfa_plfa-part1-Lists-25240" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25272" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25275" href="../Lists/#plfa_plfa-part1-Lists-25243" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25277" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25279" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25281" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25282" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25286" href="../Lists/#plfa_plfa-part1-Lists-25226" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25288" href="../Lists/#plfa_plfa-part1-Lists-25240" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25291" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25293" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25297" href="../Lists/#plfa_plfa-part1-Lists-25226" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25299" href="../Lists/#plfa_plfa-part1-Lists-25243" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25301" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25305" href="../Lists/#plfa_plfa-part1-Lists-25208" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25308" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25311" href="../Lists/#plfa_plfa-part1-Lists-25311" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25314" href="../Lists/#plfa_plfa-part1-Lists-25314" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25318" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25320" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25322" href="../Lists/#plfa_plfa-part1-Lists-22046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25325" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25327" href="../Lists/#plfa_plfa-part1-Lists-25314" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25331" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-25335" href="../Lists/#plfa_plfa-part1-Lists-25208" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25338" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25339" href="../Lists/#plfa_plfa-part1-Lists-25339" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25341" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25343" href="../Lists/#plfa_plfa-part1-Lists-25343" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25345" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25347" href="../Lists/#plfa_plfa-part1-Lists-25347" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25350" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25351" href="../Lists/#plfa_plfa-part1-Lists-25351" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25354" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25356" href="../Lists/#plfa_plfa-part1-Lists-25356" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-25363" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25365" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-25370" href="../Lists/#plfa_plfa-part1-Lists-25208" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25373" href="../Lists/#plfa_plfa-part1-Lists-25343" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25376" href="../Lists/#plfa_plfa-part1-Lists-25347" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25379" href="../Lists/#plfa_plfa-part1-Lists-25356" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-25389" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-25393" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-25395" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25397" href="../Lists/#plfa_plfa-part1-Lists-25397" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25401" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25403" href="../Lists/#plfa_plfa-part1-Lists-25403" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25407" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25409" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25411" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25413" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25416" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25418" href="../Lists/#plfa_plfa-part1-Lists-25397" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25422" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25424" href="../Lists/#plfa_plfa-part1-Lists-25403" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25428" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-25433" href="../Lists/#plfa_plfa-part1-Lists-25433" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25438" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25440" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25442" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25444" href="../Lists/#plfa_plfa-part1-Lists-25444" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25446" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25448" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25451" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25453" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25454" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25456" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25458" href="../Lists/#plfa_plfa-part1-Lists-25444" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25460" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25462" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25465" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25467" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25468" href="../Lists/#plfa_plfa-part1-Lists-25468" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25471" href="../Lists/#plfa_plfa-part1-Lists-25471" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25474" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25476" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25481" href="../Lists/#plfa_plfa-part1-Lists-25444" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25482" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25484" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25490" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25494" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25496" href="../Lists/#plfa_plfa-part1-Lists-25468" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25499" href="https://agda.github.io/agda-stdlib/v2.1/Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25501" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25505" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25507" href="../Lists/#plfa_plfa-part1-Lists-25471" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25510" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25512" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25516" href="../Lists/#plfa_plfa-part1-Lists-25454" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25518" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25519" href="../Lists/#plfa_plfa-part1-Lists-25468" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25522" href="../Lists/#plfa_plfa-part1-Lists-3651" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25525" href="../Lists/#plfa_plfa-part1-Lists-25471" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25527" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25531" href="../Lists/#plfa_plfa-part1-Lists-25433" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25536" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25539" href="../Lists/#plfa_plfa-part1-Lists-25539" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25542" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25544" href="../Lists/#plfa_plfa-part1-Lists-22046" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25547" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25549" href="../Lists/#plfa_plfa-part1-Lists-25549" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25553" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25555" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25557" href="../Lists/#plfa_plfa-part1-Lists-25549" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-25563" href="../Lists/#plfa_plfa-part1-Lists-25433" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25568" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25569" href="../Lists/#plfa_plfa-part1-Lists-25569" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25571" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25573" href="../Lists/#plfa_plfa-part1-Lists-25573" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25575" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25577" href="../Lists/#plfa_plfa-part1-Lists-25577" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25580" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25582" href="../Lists/#plfa_plfa-part1-Lists-25582" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25585" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25587" href="../Lists/#plfa_plfa-part1-Lists-25587" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25591" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25593" href="../Lists/#plfa_plfa-part1-Lists-25593" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25597" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25599" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25602" href="../Lists/#plfa_plfa-part1-Lists-25582" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25605" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25607" href="../Lists/#plfa_plfa-part1-Lists-25433" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25612" href="../Lists/#plfa_plfa-part1-Lists-25573" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25615" href="../Lists/#plfa_plfa-part1-Lists-25577" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25618" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25620" href="../Lists/#plfa_plfa-part1-Lists-25587" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25624" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25626" href="../Lists/#plfa_plfa-part1-Lists-25593" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25630" href="../Lists/#plfa_plfa-part1-Lists-855" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="exercise-any---recommended">Exercise <code>Any-++-⇔</code> (recommended)</h4><p>Prove a result similar to <code>All-++-⇔</code>, but with <code>Any</code> in place of <code>All</code>, and a suitable replacement for <code>_×_</code>. As a consequence, demonstrate an equivalence relating <code>_∈_</code> and <code>_++_</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25869" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all---stretch">Exercise <code>All-++-≃</code> (stretch)</h4><p>Show that the equivalence <code>All-++-⇔</code> can be extended to an isomorphism.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26014" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-recommended">Exercise <code>¬Any⇔All¬</code> (recommended)</h4><p>Show that <code>Any</code> and <code>All</code> satisfy a version of De Morgan’s Law:</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>(Can you see why it is important that here <code>_∘_</code> is generalised to arbitrary levels, as described in the section on <a href="../Equality/#unipoly">universe polymorphism</a>?)</p><p>Do we also have the following?</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>If so, prove; if not, explain why.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26466" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-stretch">Exercise <code>¬Any≃All¬</code> (stretch)</h4><p>Show that the equivalence <code>¬Any⇔All¬</code> can be extended to an isomorphism. You will need to use extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26650" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all--practice">Exercise <code>All-∀</code> (practice)</h4><p>Show that <code>All P xs</code> is isomorphic to <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26781" class="Comment">-- You code goes here</a>
</pre><h4 id="exercise-any--practice">Exercise <code>Any-∃</code> (practice)</h4><p>Show that <code>Any P xs</code> is isomorphic to <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26915" class="Comment">-- You code goes here</a>
</pre><h2 id="decidability-of-all">Decidability of All</h2>If we consider a predicate as a function that yields a boolean, it is easy to define an analogue of <code>All</code>, which returns true if a given predicate returns true for every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-27164" href="../Lists/#plfa_plfa-part1-Lists-27164" class="Function">all</a> <a id="plfa_plfa-part1-Lists-27168" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27170" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27172" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27173" href="../Lists/#plfa_plfa-part1-Lists-27173" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27175" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27177" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27180" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27182" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27184" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27185" href="../Lists/#plfa_plfa-part1-Lists-27173" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27187" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27189" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-27193" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27195" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27197" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27202" href="../Lists/#plfa_plfa-part1-Lists-27173" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27204" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27206" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-27211" href="../Lists/#plfa_plfa-part1-Lists-27164" class="Function">all</a> <a id="plfa_plfa-part1-Lists-27215" href="../Lists/#plfa_plfa-part1-Lists-27215" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-27218" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27221" href="../Lists/#plfa_plfa-part1-Lists-15620" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-27227" href="https://agda.github.io/agda-stdlib/v2.1/Data.Bool.Base.html#995" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-27231" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-27236" href="https://agda.github.io/agda-stdlib/v2.1/Function.Base.html#1115" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-27238" href="../Lists/#plfa_plfa-part1-Lists-13163" class="Function">map</a> <a id="plfa_plfa-part1-Lists-27242" href="../Lists/#plfa_plfa-part1-Lists-27215" class="Bound">p</a>
</pre><p>The function can be written in a particularly compact style by using the higher-order functions <code>map</code> and <code>foldr</code>.</p>As one would hope, if we replace booleans by decidables there is again an analogue of <code>All</code>. First, return to the notion of a predicate <code>P</code> as a function of type <code>A → Set</code>, taking a value <code>x</code> of type <code>A</code> into evidence <code>P x</code> that a property holds for <code>x</code>. Say that a predicate <code>P</code> is <em>decidable</em> if we have a function that for a given <code>x</code> can decide <code>P x</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-27730" href="../Lists/#plfa_plfa-part1-Lists-27730" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27740" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27742" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27744" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27745" href="../Lists/#plfa_plfa-part1-Lists-27745" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27747" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27749" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27752" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27754" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27756" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27757" href="../Lists/#plfa_plfa-part1-Lists-27745" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27759" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27761" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27764" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27766" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27768" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-27772" href="../Lists/#plfa_plfa-part1-Lists-27730" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27782" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27783" href="../Lists/#plfa_plfa-part1-Lists-27783" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27784" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27786" href="../Lists/#plfa_plfa-part1-Lists-27786" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-27789" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27792" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27794" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27795" href="../Lists/#plfa_plfa-part1-Lists-27795" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27797" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27799" href="../Lists/#plfa_plfa-part1-Lists-27783" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27800" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27802" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27804" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1861" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-27808" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27809" href="../Lists/#plfa_plfa-part1-Lists-27786" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27811" href="../Lists/#plfa_plfa-part1-Lists-27795" class="Bound">x</a><a id="plfa_plfa-part1-Lists-27812" class="Symbol">)</a>
</pre>Then if predicate <code>P</code> is decidable, it is also decidable whether every element of a list satisfies the predicate:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-27940" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27945" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27947" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27949" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27950" href="../Lists/#plfa_plfa-part1-Lists-27950" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27952" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27954" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27957" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27959" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27960" href="../Lists/#plfa_plfa-part1-Lists-27960" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27962" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27964" href="../Lists/#plfa_plfa-part1-Lists-27950" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27966" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27968" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27971" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27973" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27975" href="../Lists/#plfa_plfa-part1-Lists-27730" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27985" href="../Lists/#plfa_plfa-part1-Lists-27960" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27987" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27989" href="../Lists/#plfa_plfa-part1-Lists-27730" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27999" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28000" href="../Lists/#plfa_plfa-part1-Lists-21995" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-28004" href="../Lists/#plfa_plfa-part1-Lists-27960" class="Bound">P</a><a id="plfa_plfa-part1-Lists-28005" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-28007" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-28012" href="../Lists/#plfa_plfa-part1-Lists-28012" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28015" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-28050" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28053" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28057" href="../Lists/#plfa_plfa-part1-Lists-22046" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-28060" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-28065" href="../Lists/#plfa_plfa-part1-Lists-28065" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28068" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28069" href="../Lists/#plfa_plfa-part1-Lists-28069" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28071" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28073" href="../Lists/#plfa_plfa-part1-Lists-28073" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-28075" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28077" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-28082" href="../Lists/#plfa_plfa-part1-Lists-28065" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28085" href="../Lists/#plfa_plfa-part1-Lists-28069" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-28089" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28091" href="../Lists/#plfa_plfa-part1-Lists-27940" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-28096" href="../Lists/#plfa_plfa-part1-Lists-28065" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-28099" href="../Lists/#plfa_plfa-part1-Lists-28073" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-28102" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-28122" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28124" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28128" href="../Lists/#plfa_plfa-part1-Lists-28128" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28131" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28133" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28137" href="../Lists/#plfa_plfa-part1-Lists-28137" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-28145" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28148" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-28152" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28153" href="../Lists/#plfa_plfa-part1-Lists-28128" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28156" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28158" href="../Lists/#plfa_plfa-part1-Lists-28137" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28161" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-28163" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-28183" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28185" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28188" href="../Lists/#plfa_plfa-part1-Lists-28188" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-28192" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-28194" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-28206" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28209" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28212" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-28215" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28216" href="../Lists/#plfa_plfa-part1-Lists-28216" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28219" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28221" href="../Lists/#plfa_plfa-part1-Lists-28221" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28224" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28226" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28228" href="../Lists/#plfa_plfa-part1-Lists-28188" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-28232" href="../Lists/#plfa_plfa-part1-Lists-28216" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-28237" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-28239" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-28242" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-28259" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-28260" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28261" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-28262" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-28268" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-28269" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28270" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-28272" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28273" href="../Lists/#plfa_plfa-part1-Lists-28273" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-28282" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28285" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28288" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-28291" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28292" href="../Lists/#plfa_plfa-part1-Lists-28292" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28295" href="../Lists/#plfa_plfa-part1-Lists-22063" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28297" href="../Lists/#plfa_plfa-part1-Lists-28297" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28300" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28302" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28304" href="../Lists/#plfa_plfa-part1-Lists-28273" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-28309" href="../Lists/#plfa_plfa-part1-Lists-28297" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-28313" class="Symbol">}</a>
</pre><p>If the list is empty, then trivially <code>P</code> holds for every element of the list. Otherwise, the structure of the proof is similar to that showing that the conjunction of two decidable propositions is itself decidable, using <code>_∷_</code> rather than <code>⟨_,_⟩</code> to combine the evidence for the head and tail of the list.</p><h4 id="exercise-any-stretch">Exercise <code>Any?</code> (stretch)</h4><p>Just as <code>All</code> has analogues <code>all</code> and <code>All?</code> which determine whether a predicate holds for every element of a list, so does <code>Any</code> have analogues <code>any</code> and <code>Any?</code> which determine whether a predicate holds for some element of a list. Give their definitions.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28926" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-split-stretch">Exercise <code>split</code> (stretch)</h4>The relation <code>merge</code> holds when two lists merge to give a third list.<pre class="Agda"><a id="plfa_plfa-part1-Lists-29066" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-29071" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29077" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29078" href="../Lists/#plfa_plfa-part1-Lists-29078" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-29080" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29082" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-29085" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-29087" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29089" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29090" href="../Lists/#plfa_plfa-part1-Lists-29090" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29093" href="../Lists/#plfa_plfa-part1-Lists-29093" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29096" href="../Lists/#plfa_plfa-part1-Lists-29096" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-29099" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29101" href="../Lists/#plfa_plfa-part1-Lists-1051" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-29106" href="../Lists/#plfa_plfa-part1-Lists-29078" class="Bound">A</a><a id="plfa_plfa-part1-Lists-29107" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29109" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29111" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Primitive.html#388" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-29115" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-29124" href="../Lists/#plfa_plfa-part1-Lists-29124" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-29127" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-29135" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-29156" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29162" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-29165" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-29168" href="../Lists/#plfa_plfa-part1-Lists-1080" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-29174" href="../Lists/#plfa_plfa-part1-Lists-29174" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29181" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29183" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29185" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29186" href="../Lists/#plfa_plfa-part1-Lists-29186" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29188" href="../Lists/#plfa_plfa-part1-Lists-29188" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29191" href="../Lists/#plfa_plfa-part1-Lists-29191" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29194" href="../Lists/#plfa_plfa-part1-Lists-29194" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29196" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-29202" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29204" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29210" href="../Lists/#plfa_plfa-part1-Lists-29188" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29213" href="../Lists/#plfa_plfa-part1-Lists-29191" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29216" href="../Lists/#plfa_plfa-part1-Lists-29194" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29225" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29256" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29258" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29264" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29265" href="../Lists/#plfa_plfa-part1-Lists-29186" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29267" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29269" href="../Lists/#plfa_plfa-part1-Lists-29188" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29271" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29273" href="../Lists/#plfa_plfa-part1-Lists-29191" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29276" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29277" href="../Lists/#plfa_plfa-part1-Lists-29186" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29279" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29281" href="../Lists/#plfa_plfa-part1-Lists-29194" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29283" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-29288" href="../Lists/#plfa_plfa-part1-Lists-29288" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29296" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29298" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29300" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29301" href="../Lists/#plfa_plfa-part1-Lists-29301" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29303" href="../Lists/#plfa_plfa-part1-Lists-29303" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29306" href="../Lists/#plfa_plfa-part1-Lists-29306" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29309" href="../Lists/#plfa_plfa-part1-Lists-29309" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29311" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-29317" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29319" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29325" href="../Lists/#plfa_plfa-part1-Lists-29303" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29328" href="../Lists/#plfa_plfa-part1-Lists-29306" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29331" href="../Lists/#plfa_plfa-part1-Lists-29309" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29340" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29371" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29373" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29379" href="../Lists/#plfa_plfa-part1-Lists-29303" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29382" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29383" href="../Lists/#plfa_plfa-part1-Lists-29301" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29385" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29387" href="../Lists/#plfa_plfa-part1-Lists-29306" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-29389" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29391" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29392" href="../Lists/#plfa_plfa-part1-Lists-29301" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29394" href="../Lists/#plfa_plfa-part1-Lists-1095" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29396" href="../Lists/#plfa_plfa-part1-Lists-29309" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29398" class="Symbol">)</a>
</pre>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-29426" href="../Lists/#plfa_plfa-part1-Lists-29426" class="Function">_</a> <a id="plfa_plfa-part1-Lists-29428" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29430" href="../Lists/#plfa_plfa-part1-Lists-29071" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29436" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29438" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29440" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29442" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29444" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29446" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29448" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29450" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29452" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29454" href="../Lists/#plfa_plfa-part1-Lists-3030" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29456" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29458" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29460" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29462" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29464" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29466" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29468" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29470" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29472" href="../Lists/#plfa_plfa-part1-Lists-3100" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-29474" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-29476" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-29478" href="../Lists/#plfa_plfa-part1-Lists-29174" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29485" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29486" href="../Lists/#plfa_plfa-part1-Lists-29288" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29494" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29495" href="../Lists/#plfa_plfa-part1-Lists-29288" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29503" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29504" href="../Lists/#plfa_plfa-part1-Lists-29174" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29511" href="../Lists/#plfa_plfa-part1-Lists-29124" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-29513" class="Symbol">)))</a>

</pre><p>Given a decidable predicate and a list, we can split the list into two lists that merge to give the original list, where all elements of one list satisfy the predicate, and all elements of the other do not satisfy the predicate.</p><p>Define the following variant of the traditional <code>filter</code> function on lists, which given a decidable predicate and a list returns a list of elements that satisfy the predicate and a list of elements that don’t, with their corresponding proofs.</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-30149" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard Library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Lists-30289" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30296" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-30306" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30312" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30313" href="https://agda.github.io/agda-stdlib/v2.1/Agda.Builtin.List.html#147" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-30317" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30319" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#1734" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-30323" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30325" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#5044" class="Function">length</a><a id="plfa_plfa-part1-Lists-30331" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30333" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#7225" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-30340" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30342" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#1634" class="Function">map</a><a id="plfa_plfa-part1-Lists-30345" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30347" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#4148" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-30352" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30354" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Base.html#6728" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-30362" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30364" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30371" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-30400" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30406" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30407" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html#1639" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-30410" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30412" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html#1702" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-30414" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30416" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.All.html#1719" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-30419" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30421" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30428" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-30457" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30463" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30464" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html#1148" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-30467" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30469" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html#1211" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-30473" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30475" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Relation.Unary.Any.html#1264" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-30480" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30482" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30489" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-30524" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30530" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30531" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Membership.Setoid.html#925" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-30534" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30536" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30543" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-30566" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30572" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30573" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#58792" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-30591" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30593" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#58210" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-30604" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30606" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#58341" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-30620" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30622" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#22620" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-30630" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30632" href="https://agda.github.io/agda-stdlib/v2.1/Data.List.Properties.html#22811" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-30644" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30646" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30653" href="https://agda.github.io/agda-stdlib/v2.1/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-30672" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30678" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30679" href="https://agda.github.io/agda-stdlib/v2.1/Algebra.Structures.html#4825" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-30687" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30689" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30696" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-30711" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30717" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30718" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Unary.html#4543" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30727" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30729" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30736" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-30752" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30758" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30759" href="https://agda.github.io/agda-stdlib/v2.1/Relation.Binary.Definitions.html#6713" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30768" class="Symbol">)</a>
</pre><p>The standard library version of <code>IsMonoid</code> differs from the one given here, in that it is also parameterised on an equivalence relation.</p><p>Both <code>Relation.Unary</code> and <code>Relation.Binary</code> define a version of <code>Decidable</code>, one for unary relations (as used in this chapter where <code>P</code> ranges over unary predicates) and one for binary relations (as used earlier, where <code>_≤_</code> ranges over a binary relation).</p><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>